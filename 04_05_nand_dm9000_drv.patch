diff --git a/Makefile b/Makefile
index 046aded..7de2e54 100755
--- a/Makefile
+++ b/Makefile
@@ -356,7 +356,7 @@ CHECK		= sparse
 CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
 		  -Wbitwise -Wno-return-void -D__CHECK_ENDIAN__ $(CF)
 
-KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__
+KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__ -DDEBUG
 
 KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \
 		   -Wno-format-security \
diff --git a/arch/arm/dts/s5pc1xx-gec210.dts b/arch/arm/dts/s5pc1xx-gec210.dts
index 75bd6ec..5b84dba 100755
--- a/arch/arm/dts/s5pc1xx-gec210.dts
+++ b/arch/arm/dts/s5pc1xx-gec210.dts
@@ -29,7 +29,7 @@
 	serial@e2900000 {
 		compatible = "samsung,exynos4210-uart";
 		reg = <0xe2900000 0x400>;
-		interrupts = <0 51 0>;
+		interrupts = <10>;
 		id = <0>;
 	};
 
diff --git a/arch/arm/mach-s5pc1xx/include/mach/boot0.h b/arch/arm/mach-s5pc1xx/include/mach/boot0.h
index 3b96355..9d672cd 100755
--- a/arch/arm/mach-s5pc1xx/include/mach/boot0.h
+++ b/arch/arm/mach-s5pc1xx/include/mach/boot0.h
@@ -5,7 +5,7 @@
  */
 
 /* BOOT0 header information */
-	.word 0x2000		@ indicate BL1 size = 8KB
+	.word COPY_BL1_SIZE		@ indicate BL1 size for irom
 	.word 0x0
 	.word 0x0
 	.word 0x0
diff --git a/board/samsung/gec210/gec210.c b/board/samsung/gec210/gec210.c
index 8011259..f5a6249 100755
--- a/board/samsung/gec210/gec210.c
+++ b/board/samsung/gec210/gec210.c
@@ -18,6 +18,7 @@ DECLARE_GLOBAL_DATA_PTR;
 /*
  * Miscellaneous platform dependent initialisations
  */
+#ifdef CONFIG_SMC911X
 static void smc9115_pre_init(void)
 {
 	u32 smc_bw_conf, smc_bc_conf;
@@ -34,11 +35,34 @@ static void smc9115_pre_init(void)
 	/* Select and configure the SROMC bank */
 	s5p_config_sromc(CONFIG_ENV_SROM_BANK, smc_bw_conf, smc_bc_conf);
 }
+#endif
+
+#ifdef CONFIG_DRIVER_DM9000
+static void dm9000_pre_init(void)
+{
+	unsigned int tmp;
+
+	/* DM9000 on SROM BANK1, 16 bit */
+	SROM_BW_REG &= ~(0xf << 4);
+	SROM_BW_REG |= (0x1 << 4);
+	SROM_BC1_REG = ((0<<28)|(0<<24)|(5<<16)|(0<<12)|(0<<8)|(0<<4)|(0<<0));
+	/* Set MP01_1 as SROM_CSn[1] */
+	tmp = MP01CON_REG;
+	tmp &=~(0xf<<4);
+	tmp |=(2<<4);
+	MP01CON_REG = tmp;
+}
+#endif
 
 int board_init(void)
 {
+#ifdef CONFIG_SMC911X
 	smc9115_pre_init();
+#endif
 
+#ifdef CONFIG_DRIVER_DM9000
+	dm9000_pre_init();
+#endif
 	gd->bd->bi_arch_number = MACH_TYPE_SMDKC110;
 	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
 
@@ -75,8 +99,13 @@ int checkboard(void)
 int board_eth_init(bd_t *bis)
 {
 	int rc = 0;
+
 #ifdef CONFIG_SMC911X
 	rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
 #endif
+
+#ifdef CONFIG_DRIVER_DM9000
+	rc = dm9000_initialize(bis);
+#endif
 	return rc;
 }
diff --git a/board/samsung/gec210/lowlevel_init.S b/board/samsung/gec210/lowlevel_init.S
index 9fa1cf9..46076d1 100755
--- a/board/samsung/gec210/lowlevel_init.S
+++ b/board/samsung/gec210/lowlevel_init.S
@@ -231,6 +231,7 @@ tzpc_asm_init:
  * Nand Interface Init for GEC210
  */
 nand_asm_init:
+#if 0	/* own nand initial driver */
 	ldr	r0, =ELFIN_GPIO_BASE
 	/* pin CSn2 */
 	ldr	r1, [r0,#MP01CON_OFFSET]
@@ -261,5 +262,58 @@ nand_asm_init:
 	str	r1, [r0,#NFCONT_OFFSET]
 	 
 	mov	pc, lr
+#else
+	/* Setting GPIO for NAND */
+	/* This setting is NAND initialze code at booting time in iROM. */
 
+	ldr	r0, =ELFIN_GPIO_BASE
+
+	ldr	r1, [r0, #MP01CON_OFFSET]
+	bic	r1, r1, #(0xf<<8)
+	orr	r1, r1, #(0x3<<8)
+	str	r1, [r0, #MP01CON_OFFSET]
+
+	ldr	r1, [r0, #MP01PUD_OFFSET]
+	bic	r1, r1, #(0x3<<4)
+	str	r1, [r0, #MP01PUD_OFFSET]
+
+	ldr	r1, [r0, #MP03CON_OFFSET]
+	bic	r1, r1, #0xFFFFFF
+	ldr	r2, =0x22222222
+	orr	r1, r1, r2
+	str	r1, [r0, #MP03CON_OFFSET]
+
+	ldr	r1, [r0, #MP03PUD_OFFSET]
+	ldr	r2, =0x3fff
+	bic	r1, r1, r2
+	str	r1, [r0, #MP03PUD_OFFSET]
+
+	ldr	r0, =ELFIN_NAND_BASE
+
+	ldr	r1, [r0, #NFCONF_OFFSET]
+	ldr	r2, =0x777F
+	bic	r1, r1, r2
+	ldr	r2, =NFCONF_VAL
+	orr	r1, r1, r2
+	str	r1, [r0, #NFCONF_OFFSET]
+
+	ldr	r1, [r0, #NFCONT_OFFSET]
+	ldr	r2, =0x707C7
+	bic	r1, r1, r2
+	ldr	r2, =NFCONT_VAL
+	orr	r1, r1, r2
+	str	r1, [r0, #NFCONT_OFFSET]
+
+	ldr	r1, [r0, #NFCONF_OFFSET]
+	orr	r1, r1, #0x70
+	orr	r1, r1, #0x7700
+	str     r1, [r0, #NFCONF_OFFSET]
+
+	ldr	r1, [r0, #NFCONT_OFFSET]
+	orr	r1, r1, #0x03
+	str     r1, [r0, #NFCONT_OFFSET]
+
+	mov	pc, lr
+
+#endif
 
diff --git a/cmd/nand.c b/cmd/nand.c
index a22945d..234a7b7 100755
--- a/cmd/nand.c
+++ b/cmd/nand.c
@@ -1,4 +1,4 @@
-/*
+﻿/*
  * Driver for NAND support, Rick Bronson
  * borrowed heavily from:
  * (c) 1999 Machine Vision Holdings, Inc.
@@ -387,6 +387,11 @@ static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	int dev = nand_curr_device;
 	int repeat = flag & CMD_FLAG_REPEAT;
 
+#if defined(CONFIG_S5PC110) && !defined(CONFIG_FUSED) && !defined(CONFIG_SECURE)
+	ulong checksum;
+	uint8_t *ptr;
+#endif
+
 	/* at least two arguments please */
 	if (argc < 2)
 		goto usage;
@@ -611,11 +616,23 @@ static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 				ret = nand_read_skip_bad(mtd, off, &rwsize,
 							 NULL, maxsize,
 							 (u_char *)addr);
-			else
+			else {
+#if defined(CONFIG_S5PC110) && !defined(CONFIG_FUSED) && !defined(CONFIG_SECURE)
+				if (off == 0) {
+					ptr = (u_char *)(addr + 16);
+					for(i = 16, checksum = 0; i < COPY_BL1_SIZE; i++) {
+						checksum += *ptr;
+						ptr++;
+					}
+					*((volatile u32 *)(addr + 0x8)) = checksum;
+					pr_info("BL1's checksum is calculated.\n");
+				}
+#endif
 				ret = nand_write_skip_bad(mtd, off, &rwsize,
 							  NULL, maxsize,
 							  (u_char *)addr,
 							  WITH_WR_VERIFY);
+			}
 #ifdef CONFIG_CMD_NAND_TRIMFFS
 		} else if (!strcmp(s, ".trimffs")) {
 			if (read) {
diff --git a/configs/gec210_defconfig b/configs/gec210_defconfig
index 3b6104a..4f8d7a0 100755
--- a/configs/gec210_defconfig
+++ b/configs/gec210_defconfig
@@ -157,7 +157,7 @@ CONFIG_IDENT_STRING=" for GEC210"
 # CONFIG_DEBUG_LL is not set
 CONFIG_DEFAULT_DEVICE_TREE="s5pc1xx-gec210"
 CONFIG_SMBIOS_PRODUCT_NAME="smdkc100"
-# CONFIG_DEBUG_UART is not set
+CONFIG_DEBUG_UART=y
 # CONFIG_AHCI is not set
 
 #
@@ -218,8 +218,8 @@ CONFIG_BOOTARGS="root=/dev/mtdblock5 ubi.mtd=4 rootfstype=cramfs console=ttySAC0
 # Console
 #
 # CONFIG_CONSOLE_RECORD is not set
-CONFIG_LOGLEVEL=4
-CONFIG_SPL_LOGLEVEL=4
+CONFIG_LOGLEVEL=8
+CONFIG_SPL_LOGLEVEL=8
 # CONFIG_SILENT_CONSOLE is not set
 # CONFIG_PRE_CONSOLE_BUFFER is not set
 # CONFIG_CONSOLE_MUX is not set
@@ -369,7 +369,10 @@ CONFIG_CMD_FPGA=y
 CONFIG_CMD_LOADB=y
 CONFIG_CMD_LOADS=y
 # CONFIG_CMD_MMC is not set
-# CONFIG_CMD_NAND is not set
+CONFIG_CMD_NAND=y
+# CONFIG_CMD_NAND_TRIMFFS is not set
+# CONFIG_CMD_NAND_LOCK_UNLOCK is not set
+# CONFIG_CMD_NAND_TORTURE is not set
 # CONFIG_CMD_MMC_SPI is not set
 # CONFIG_CMD_ONENAND is not set
 # CONFIG_CMD_PART is not set
@@ -513,7 +516,7 @@ CONFIG_ENV_IS_NOWHERE=y
 # CONFIG_ENV_IS_IN_SPI_FLASH is not set
 # CONFIG_ENV_IS_IN_UBI is not set
 CONFIG_NET=y
-# CONFIG_NET_RANDOM_ETHADDR is not set
+CONFIG_NET_RANDOM_ETHADDR=y
 # CONFIG_NETCONSOLE is not set
 CONFIG_NET_TFTP_VARS=y
 CONFIG_BOOTP_PXE_CLIENTARCH=0x15
@@ -679,7 +682,19 @@ CONFIG_DM_I2C=y
 #
 # CONFIG_MTD is not set
 # CONFIG_MTD_NOR_FLASH is not set
-# CONFIG_NAND is not set
+CONFIG_NAND=y
+# CONFIG_NAND_DENALI_DT is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+# CONFIG_NAND_ZYNQ is not set
+CONFIG_NAND_S5P=y
+CONFIG_S5P_NAND_HWECC=y
+CONFIG_NAND_BL1_8BIT_ECC=y
+
+#
+# Generic NAND options
+#
 
 #
 # SPI Flash Support
@@ -704,10 +719,7 @@ CONFIG_NETDEVICES=y
 # CONFIG_RGMII is not set
 # CONFIG_RTL8139 is not set
 # CONFIG_RTL8169 is not set
-CONFIG_SMC911X=y
-CONFIG_SMC911X_BASE=0x98800300
-# CONFIG_SMC911X_32_BIT is not set
-CONFIG_SMC911X_16_BIT=y
+# CONFIG_SMC911X is not set
 # CONFIG_SUN7I_GMAC is not set
 # CONFIG_PCI is not set
 
@@ -766,6 +778,23 @@ CONFIG_DM_SERIAL=y
 # CONFIG_SERIAL_RX_BUFFER is not set
 # CONFIG_SPL_DM_SERIAL is not set
 # CONFIG_TPL_DM_SERIAL is not set
+# CONFIG_DEBUG_UART_ALTERA_JTAGUART is not set
+# CONFIG_DEBUG_UART_ALTERA_UART is not set
+# CONFIG_DEBUG_UART_ATMEL is not set
+# CONFIG_DEBUG_UART_NS16550 is not set
+CONFIG_DEBUG_UART_S5P=y
+# CONFIG_DEBUG_UART_UARTLITE is not set
+# CONFIG_DEBUG_UART_ARM_DCC is not set
+# CONFIG_DEBUG_MVEBU_A3700_UART is not set
+# CONFIG_DEBUG_UART_ZYNQ is not set
+# CONFIG_DEBUG_UART_PL010 is not set
+# CONFIG_DEBUG_UART_PL011 is not set
+# CONFIG_DEBUG_UART_OMAP is not set
+CONFIG_DEBUG_UART_BASE=0XE2900000
+CONFIG_DEBUG_UART_CLOCK=66000000
+CONFIG_DEBUG_UART_SHIFT=0
+# CONFIG_DEBUG_UART_BOARD_INIT is not set
+# CONFIG_DEBUG_UART_ANNOUNCE is not set
 # CONFIG_DEBUG_UART_SKIP_INIT is not set
 # CONFIG_ALTERA_JTAG_UART is not set
 # CONFIG_ALTERA_UART is not set
@@ -870,7 +899,7 @@ CONFIG_SYS_HZ=1000
 # CONFIG_USE_TINY_PRINTF is not set
 # CONFIG_PANIC_HANG is not set
 CONFIG_REGEX=y
-# CONFIG_LIB_RAND is not set
+CONFIG_LIB_RAND=y
 # CONFIG_SPL_TINY_MEMSET is not set
 # CONFIG_TPL_TINY_MEMSET is not set
 # CONFIG_BITREVERSE is not set
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 78a39ab..077fc5f 100755
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -160,6 +160,24 @@ config NAND_ZYNQ_USE_BOOTLOADER1_TIMINGS
 	  This flag prevent U-boot reconfigure NAND flash controller and reuse
 	  the NAND timing from 1st stage bootloader.
 
+config NAND_S5P
+	bool "Support for Samsung S5PV210 Nand controller"
+	imply CMD_NAND
+	help
+	  This enables Nand driver support for Nand flash controller
+	   on Samsung S5P1XX SoC.
+
+config S5P_NAND_HWECC
+	bool "Enable use of S5P1XX nand flash controller's hardware ecc"
+	depends on NAND_S5P
+
+config NAND_BL1_8BIT_ECC
+	bool "Enable write bootloader stage 1 in nand flash with 8-bit ecc"
+	depends on NAND_S5P
+	help
+	  Soc s5pc11x's BL0 require BL1 which located in block 0 on nand to carry
+	   with 8-bit ecc, otherwise it will be failed when boot the BL1 in nand.
+
 comment "Generic NAND options"
 
 # Enhance depends when converting drivers to Kconfig which use this config
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 9f7d9d6..43efb21 100755
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -66,6 +66,7 @@ obj-$(CONFIG_NAND_OMAP_ELM) += omap_elm.o
 obj-$(CONFIG_NAND_PLAT) += nand_plat.o
 obj-$(CONFIG_NAND_SUNXI) += sunxi_nand.o
 obj-$(CONFIG_NAND_ZYNQ) += zynq_nand.o
+obj-$(CONFIG_NAND_S5P) += s5p_nand.o
 
 else  # minimal SPL drivers
 
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index eb9f121..5383cd5 100755
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -1,4 +1,4 @@
-/*
+﻿/*
  *  Overview:
  *   This is the generic MTD driver for NAND flash devices. It should be
  *   capable of working with almost all NAND chips currently available.
@@ -353,6 +353,11 @@ static int nand_block_bad(struct mtd_info *mtd, loff_t ofs)
 		ofs += mtd->erasesize - mtd->writesize;
 
 	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
+	
+#if defined(CONFIG_NAND_BL1_8BIT_ECC) && defined(CONFIG_S5PC110)
+	if (page < CFG_NAND_PAGES_IN_BLOCK)
+		return 0;
+#endif
 
 	do {
 		if (chip->options & NAND_BUSWIDTH_16) {
@@ -1677,6 +1682,9 @@ static int nand_setup_read_retry(struct mtd_info *mtd, int retry_mode)
 	return chip->setup_read_retry(mtd, retry_mode);
 }
 
+extern int s3c_nand_read_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf);
+
 /**
  * nand_do_read_ops - [INTERN] Read data with ECC
  * @mtd: MTD device structure
@@ -1744,18 +1752,26 @@ read_retry:
 			 * Now read the page into the buffer.  Absent an error,
 			 * the read methods return max bitflips per ecc step.
 			 */
-			if (unlikely(ops->mode == MTD_OPS_RAW))
-				ret = chip->ecc.read_page_raw(mtd, chip, bufpoi,
-							      oob_required,
-							      page);
-			else if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&
-				 !oob)
-				ret = chip->ecc.read_subpage(mtd, chip,
-							col, bytes, bufpoi,
-							page);
-			else
-				ret = chip->ecc.read_page(mtd, chip, bufpoi,
-							  oob_required, page);
+#if defined(CONFIG_NAND_BL1_8BIT_ECC) && defined(CONFIG_S5PC110)
+			if (page < CFG_NAND_PAGES_IN_BLOCK) {
+				ret = s3c_nand_read_page_8bit(mtd, chip, bufpoi);
+			} else
+#endif
+			{
+				if (unlikely(ops->mode == MTD_OPS_RAW))
+					ret = chip->ecc.read_page_raw(mtd, chip, bufpoi,
+								      oob_required,
+								      page);
+				else if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&
+					 !oob)
+					ret = chip->ecc.read_subpage(mtd, chip,
+								col, bytes, bufpoi,
+								page);
+				else
+					ret = chip->ecc.read_page(mtd, chip, bufpoi,
+								  oob_required, page);
+			}
+
 			if (ret < 0) {
 				if (use_bufpoi)
 					/* Invalidate page cache */
@@ -2404,6 +2420,9 @@ static int nand_write_page_syndrome(struct mtd_info *mtd,
 
 	return 0;
 }
+				    
+extern int s3c_nand_write_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+			      const uint8_t *buf);
 
 /**
  * nand_write_page - [REPLACEABLE] write one page
@@ -2431,15 +2450,23 @@ static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 	if (nand_standard_page_accessors(&chip->ecc))
 		chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
 
-	if (unlikely(raw))
-		status = chip->ecc.write_page_raw(mtd, chip, buf,
-						  oob_required, page);
-	else if (subpage)
-		status = chip->ecc.write_subpage(mtd, chip, offset, data_len,
-						 buf, oob_required, page);
-	else
-		status = chip->ecc.write_page(mtd, chip, buf, oob_required,
-					      page);
+#if defined(CONFIG_NAND_BL1_8BIT_ECC) && defined(CONFIG_S5PC110)
+	if (page < CFG_NAND_PAGES_IN_BLOCK) {
+		memset(chip->oob_poi, 0xff, mtd->oobsize);
+		status = s3c_nand_write_page_8bit(mtd, chip, buf);
+	} else
+#endif
+	{
+		if (unlikely(raw))
+			status = chip->ecc.write_page_raw(mtd, chip, buf,
+							  oob_required, page);
+		else if (subpage)
+			status = chip->ecc.write_subpage(mtd, chip, offset, data_len,
+							 buf, oob_required, page);
+		else
+			status = chip->ecc.write_page(mtd, chip, buf, oob_required,
+						      page);
+	}
 
 	if (status < 0)
 		return status;
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index 4009d64..af83901 100755
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -1,4 +1,4 @@
-/*
+﻿/*
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
  *
  * This program is free software; you can redistribute it and/or modify
@@ -49,9 +49,11 @@ struct nand_flash_dev nand_flash_ids[] = {
 	{"TC58NVG2S0H 4G 3.3V 8-bit",
 		{ .id = {0x98, 0xdc, 0x90, 0x26, 0x76, 0x16, 0x08, 0x00} },
 		  SZ_4K, SZ_512, SZ_256K, 0, 8, 256, NAND_ECC_INFO(8, SZ_512) },
+#if 0	/* ignore this incompatible NAND chips */
 	{"TC58NVG3S0F 8G 3.3V 8-bit",
 		{ .id = {0x98, 0xd3, 0x90, 0x26, 0x76, 0x15, 0x02, 0x08} },
 		  SZ_4K, SZ_1K, SZ_256K, 0, 8, 232, NAND_ECC_INFO(4, SZ_512) },
+#endif
 	{"TC58NVG5D2 32G 3.3V 8-bit",
 		{ .id = {0x98, 0xd7, 0x94, 0x32, 0x76, 0x56, 0x09, 0x00} },
 		  SZ_8K, SZ_4K, SZ_1M, 0, 8, 640, NAND_ECC_INFO(40, SZ_1K) },
diff --git a/drivers/mtd/nand/s5p_nand.c b/drivers/mtd/nand/s5p_nand.c
new file mode 100755
index 0000000..7374d45
--- /dev/null
+++ b/drivers/mtd/nand/s5p_nand.c
@@ -0,0 +1,1051 @@
+﻿/*
+ * (C) Copyright 2006 DENX Software Engineering
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include <nand.h>
+#include <asm/arch/s5pc110.h>
+
+#include <asm/io.h>
+#include <errno.h>
+
+/* Nand flash definition values by jsgood */
+#define S3C_NAND_TYPE_UNKNOWN	0x0
+#define S3C_NAND_TYPE_SLC	0x1
+#define S3C_NAND_TYPE_MLC	0x2
+#undef	S3C_NAND_DEBUG
+
+/* Nand flash global values by jsgood */
+int cur_ecc_mode = 0;
+int nand_type = S3C_NAND_TYPE_UNKNOWN;
+
+#if defined(CONFIG_S5P_NAND_HWECC)
+/* Nand flash oob definition for SLC 512b page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_16 = {
+	.eccbytes = 4,
+	.eccpos = {1, 2, 3, 4},
+	.oobfree = {
+		{.offset = 6,
+		 . length = 10}}
+};
+
+/* Nand flash oob definition for SLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_64 = {
+	.eccbytes = 16,
+	.eccpos = {40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 38}}
+};
+ 
+/* Nand flash oob definition for MLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_mlc_64 = {
+	.eccbytes = 32,
+	.eccpos = {
+		   32, 33, 34, 35, 36, 37, 38, 39,
+		   40, 41, 42, 43, 44, 45, 46, 47,
+ 		   48, 49, 50, 51, 52, 53, 54, 55,
+   		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 28}}
+};
+
+#if 0
+/* Nand flash oob definition for 4Kb page size with 8_bit ECC */
+static struct nand_ecclayout s3c_nand_oob_128 = {
+        .eccbytes = 104,
+        .eccpos = {
+                   24, 25, 26, 27, 28, 29, 30, 31,
+                   32, 33, 34, 35, 36, 37, 38, 39,
+                   40, 41, 42, 43, 44, 45, 46, 47,
+                   48, 49, 50, 51, 52, 53, 54, 55,
+                   56, 57, 58, 59, 60, 61, 62, 63,
+                   64, 65, 66, 67, 68, 69, 70, 71,
+                   72, 73, 74, 75, 76, 77, 78, 79,
+                   80, 81, 82, 83, 84, 85, 86, 87,
+                   88, 89, 90, 91, 92, 93, 94, 95,
+                   96, 97, 98, 99, 100, 101, 102, 103,
+                   104, 105, 106, 107, 108, 109, 110, 111,
+                   112, 113, 114, 115, 116, 117, 118, 119,
+                   120, 121, 122, 123, 124, 125, 126, 127},
+        .oobfree = {
+                {.offset = 2,
+                 .length = 22}}
+};
+#endif
+#endif
+
+#if defined(S3C_NAND_DEBUG)
+/*
+ * Function to print out oob buffer for debugging
+ * Written by jsgood
+ */
+static void print_oob(const char *header, struct mtd_info *mtd)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	printk("%s:\t", header);
+
+	for(i = 0; i < 64; i++)
+		printk("%02x ", chip->oob_poi[i]);
+
+	printk("\n");
+}
+#endif
+
+/*
+ * Hardware specific access to control-lines function
+ * Written by jsgood
+ */
+static void s3c_nand_hwcontrol(struct mtd_info *mtd, int dat, unsigned int ctrl)
+{
+	unsigned int cur;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_NCE) {
+			if (dat != NAND_CMD_NONE) {
+				cur = readl(NFCONT);
+				/* Forced Enable CS */
+				cur &= ~NFCONT_CS;
+
+				writel(cur, NFCONT);
+			}
+		} else {
+			cur = readl(NFCONT);
+			/* Forced Enable CS */
+			cur &= ~NFCONT_CS;
+
+			writel(cur, NFCONT);
+		}
+	}
+
+	if (dat != NAND_CMD_NONE) {
+		if (ctrl & NAND_CLE)
+			writeb(dat, NFCMMD);
+		else if (ctrl & NAND_ALE)
+			writeb(dat, NFADDR);
+	}
+}
+
+/*
+ * Function for checking device ready pin
+ * Written by jsgood
+ */
+static int s3c_nand_device_ready(struct mtd_info *mtdinfo)
+{
+	while (!(readl(NFSTAT) & NFSTAT_RnB)) {}
+	return 1;
+}
+
+#if defined(CONFIG_S5P_NAND_HWECC)
+
+/*
+ * Function for checking ECCEncDone in NFSTAT
+ * Written by jsgood
+ */
+static void s3c_nand_wait_enc(void)
+{
+	while (!(readl(NFECCSTAT) & NFSTAT_ECCENCDONE)) {}
+}
+
+/*
+ * Function for checking ECCDecDone in NFSTAT
+ * Written by jsgood
+ */
+static void s3c_nand_wait_dec(void)
+{
+	while (!(readl(NFECCSTAT) & NFSTAT_ECCDECDONE)) {}
+}
+
+/*
+ * Function for checking ECC Busy
+ * Written by jsgood
+ */
+static void s3c_nand_wait_ecc_busy(void)
+{
+	while (readl(NFECCSTAT) & NFESTAT0_ECCBUSY) {}
+}
+
+/*
+ * This function is called before encoding ecc codes to ready ecc engine.
+ * Written by jsgood
+ */
+static void s3c_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	u_long nfcont, nfconf;
+
+	cur_ecc_mode = mode;
+
+	nfconf = readl(NFCONF);
+
+ 	if (nand_type == S3C_NAND_TYPE_SLC)
+		nfconf &= ~NFCONF_ECC_MLC;	/* SLC */
+	else
+		nfconf |= NFCONF_ECC_MLC;	/* MLC */
+
+	writel(nfconf, NFCONF);
+
+	/* Initialize & unlock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_INITMECC;
+	nfcont &= ~NFCONT_MECCLOCK;
+
+	if (nand_type == S3C_NAND_TYPE_MLC) {
+		if (mode == NAND_ECC_WRITE)
+			nfcont |= NFCONT_ECC_ENC;
+		else if (mode == NAND_ECC_READ)
+			nfcont &= ~NFCONT_ECC_ENC;
+	}
+
+	writel(nfcont, NFCONT);
+}
+
+/*
+ * This function is called immediately after encoding ecc codes.
+ * This function returns encoded ecc codes.
+ * Written by jsgood
+ */
+static int s3c_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	u_long nfcont, nfmecc0, nfmecc1;
+
+	/* Lock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_MECCLOCK;
+	writel(nfcont, NFCONT);
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		nfmecc0 = readl(NFMECC0);
+
+		ecc_code[0] = nfmecc0 & 0xff;
+		ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+		ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+		ecc_code[3] = (nfmecc0 >> 24) & 0xff;
+	} else {
+		if (cur_ecc_mode == NAND_ECC_READ)
+			s3c_nand_wait_dec();
+		else {
+			s3c_nand_wait_enc();
+
+			nfmecc0 = readl(NFMECC0);
+			nfmecc1 = readl(NFMECC1);
+
+			ecc_code[0] = nfmecc0 & 0xff;
+			ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+			ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+			ecc_code[3] = (nfmecc0 >> 24) & 0xff;
+			ecc_code[4] = nfmecc1 & 0xff;
+			ecc_code[5] = (nfmecc1 >> 8) & 0xff;
+			ecc_code[6] = (nfmecc1 >> 16) & 0xff;
+			ecc_code[7] = (nfmecc1 >> 24) & 0xff;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * This function determines whether read data is good or not.
+ * If SLC, must write ecc codes to controller before reading status bit.
+ * If MLC, status bit is already set, so only reading is needed.
+ * If status bit is good, return 0.
+ * If correctable errors occured, do that.
+ * If uncorrectable errors occured, return -1.
+ * Written by jsgood
+ */
+static int s3c_nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret = -1;
+	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;
+	u_char err_type;
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		/* SLC: Write ecc to compare */
+		nfmeccdata0 = (read_ecc[1] << 16) | read_ecc[0];
+		nfmeccdata1 = (read_ecc[3] << 16) | read_ecc[2];
+		writel(nfmeccdata0, NFMECCDATA0);
+		writel(nfmeccdata1, NFMECCDATA1);
+
+		/* Read ecc status */
+		nfestat0 = readl(NFESTAT0);
+		err_type = nfestat0 & 0x3;
+
+		switch (err_type) {
+		case 0: /* No error */
+			ret = 0;
+			break;
+
+		case 1: /* 1 bit error (Correctable)
+			   (nfestat0 >> 7) & 0x7ff	:error byte number
+			   (nfestat0 >> 4) & 0x7	:error bit number */
+			printk("s3c-nand: 1 bit error detected at byte %ld, correcting from "
+					"0x%02x ", (nfestat0 >> 7) & 0x7ff, dat[(nfestat0 >> 7) & 0x7ff]);
+			dat[(nfestat0 >> 7) & 0x7ff] ^= (1 << ((nfestat0 >> 4) & 0x7));
+			printk("to 0x%02x...OK\n", dat[(nfestat0 >> 7) & 0x7ff]);
+			ret = 1;
+			break;
+
+		case 2: /* Multiple error */
+		case 3: /* ECC area error */
+			printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+		}
+	} else {
+		/* MLC: */
+		s3c_nand_wait_ecc_busy();
+
+		nfestat0 = readl(NFESTAT0);
+		nfestat1 = readl(NFESTAT1);
+		nfmlcbitpt = readl(NFMLCBITPT);
+
+		err_type = (nfestat0 >> 26) & 0x7;
+
+		/* No error, If free page (all 0xff) */
+		if ((nfestat0 >> 29) & 0x1) {
+			err_type = 0;
+		} else {
+			/* No error, If all 0xff from 17th byte in oob (in case of JFFS2 format) */
+			if (dat) {
+				if (dat[17] == 0xff && dat[26] == 0xff && dat[35] == 0xff && dat[44] == 0xff && dat[54] == 0xff)
+					err_type = 0;
+			}
+		}
+
+		switch (err_type) {
+		case 5: /* Uncorrectable */
+			printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+
+		case 4: /* 4 bit error (Correctable) */
+			dat[(nfestat1 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 24) & 0xff);
+
+		case 3: /* 3 bit error (Correctable) */
+			dat[nfestat1 & 0x3ff] ^= ((nfmlcbitpt >> 16) & 0xff);
+
+		case 2: /* 2 bit error (Correctable) */
+			dat[(nfestat0 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 8) & 0xff);
+
+		case 1: /* 1 bit error (Correctable) */
+			printk("s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
+			dat[nfestat0 & 0x3ff] ^= (nfmlcbitpt & 0xff);
+			ret = err_type;
+			break;
+
+		case 0: /* No error */
+			ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+#if defined(CONFIG_NAND_BL1_8BIT_ECC) && defined(CONFIG_S5PC110)
+/***************************************************************
+ * jsgood: Temporary 8 Bit H/W ECC supports for BL1 (6410/6430 only)
+ ***************************************************************/
+static void s3c_nand_wait_ecc_busy_8bit(void)
+{
+	while (readl(NFECCSTAT) & NFESTAT0_ECCBUSY) {
+	}
+}
+
+void s3c_nand_enable_hwecc_8bit(struct mtd_info *mtd, int mode)
+{
+	u_long nfreg;
+	
+	cur_ecc_mode = mode;
+
+	if(cur_ecc_mode == NAND_ECC_WRITE){
+
+	/* 8 bit selection */
+	nfreg = readl(NFCONF);
+	nfreg &= ~(0x3 << 23);
+	nfreg |= (0x3<< 23);
+	writel(nfreg, NFCONF);
+	
+	/* Set ECC type */
+	nfreg = readl(NFECCCONF);
+	nfreg &= 0xf;
+	nfreg |= 0x3;
+	writel(nfreg, NFECCCONF);
+
+	/* set 8/12/16bit Ecc direction to Encoding */
+	nfreg = readl(NFECCCONT);
+	nfreg &= ~(0x1 << 16);
+	nfreg |= (0x1 << 16);
+	writel(nfreg, NFECCCONT);
+
+	/* set 8/12/16bit ECC message length  to msg */
+	nfreg = readl(NFECCCONF);
+	nfreg &= ~((0x3ff<<16));
+	nfreg |= (0x1ff << 16);
+	writel(nfreg, NFECCCONF);
+
+	/* write '1' to clear this bit. */
+	/* clear illegal access status bit */
+	nfreg = readl(NFSTAT);
+	nfreg |= (0x1 << 4);
+	nfreg |= (0x1 << 5);
+	writel(nfreg, NFSTAT);
+
+	/* clear 8/12/16bit ecc encode done */
+	nfreg = readl(NFECCSTAT);
+	nfreg |= (0x1 << 25);
+	writel(nfreg, NFECCSTAT);
+
+	nfreg = readl(NFCONT);
+	nfreg &= ~(0x1 << 1);
+	writel(nfreg, NFCONT);
+	
+	/* Initialize & unlock */
+	nfreg = readl(NFCONT);
+	nfreg &= ~NFCONT_MECCLOCK;
+	nfreg |= NFCONT_INITECC;	
+	writel(nfreg, NFCONT);
+
+	/* Reset ECC value. */
+	nfreg = readl(NFECCCONT);
+	nfreg |= (0x1 << 2);
+	writel(nfreg, NFECCCONT);
+	
+	}else{
+
+	/* set 8/12/16bit ECC message length  to msg */
+	nfreg = readl(NFECCCONF);
+	nfreg &= ~((0x3ff<<16));
+	nfreg |= (0x1ff << 16);
+	writel(nfreg, NFECCCONF);
+	
+	/* set 8/12/16bit Ecc direction to Decoding */
+	nfreg = readl(NFECCCONT);
+	nfreg &= ~(0x1 << 16);
+	writel(nfreg, NFECCCONT);
+	
+	/* write '1' to clear this bit. */
+	/* clear illegal access status bit */
+	nfreg = readl(NFSTAT);
+	nfreg |= (0x1 << 4);
+	nfreg |= (0x1 << 5);
+	writel(nfreg, NFSTAT);
+
+	/* Lock */
+	nfreg = readl(NFCONT);
+	nfreg |= NFCONT_MECCLOCK;
+	writel(nfreg, NFCONT);
+
+	nfreg = readl(NFCONT);
+	nfreg &= ~(0x1 << 1);
+	writel(nfreg, NFCONT);
+
+	/* clear 8/12/16bit ecc decode done */
+	nfreg = readl(NFECCSTAT);
+	nfreg |= (0x1 << 24);
+	writel(nfreg, NFECCSTAT);
+	
+	/* Initialize & lock */
+	nfreg = readl(NFCONT);
+	nfreg &= ~NFCONT_MECCLOCK;
+	nfreg |= NFCONT_MECCLOCK;
+	writel(nfreg, NFCONT);
+
+	/* write '1' to clear this bit. */
+	nfreg = readl(NFSTAT);
+	nfreg &= ~(1<<4);
+	nfreg |= (1<<4);
+	writel(nfreg, NFSTAT);
+
+	while(!(nfreg &(1<<4))){
+		nfreg = readl(NFSTAT);
+		}
+
+	/* write '1' to clear this bit. */
+	nfreg = readl(NFSTAT);
+	nfreg &= ~(1<<4);
+	nfreg |= (1<<4);
+	writel(nfreg, NFSTAT);
+	
+	/* Initialize & unlock */
+	nfreg = readl(NFCONT);
+	nfreg &= ~NFCONT_MECCLOCK;
+	nfreg |= NFCONT_INITECC;	
+	writel(nfreg, NFCONT);
+
+	/* Reset ECC value. */
+	nfreg = readl(NFECCCONT);
+	nfreg |= (0x1 << 2);
+	writel(nfreg, NFECCCONT);
+	}
+
+}
+
+int s3c_nand_calculate_ecc_8bit(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	u_long nfcont, nfeccprgecc0, nfeccprgecc1, nfeccprgecc2, nfeccprgecc3;
+
+	if (cur_ecc_mode == NAND_ECC_READ) {
+		/* Lock */
+		nfcont = readl(NFCONT);
+		nfcont |= NFCONT_MECCLOCK;
+		writel(nfcont, NFCONT);
+		
+		s3c_nand_wait_dec();
+
+		/* clear 8/12/16bit ecc decode done */
+		nfcont = readl(NFECCSTAT);
+		nfcont |= (1<<24);
+		writel(nfcont, NFECCSTAT);
+
+		s3c_nand_wait_ecc_busy_8bit();
+
+		if(readl(NFSTAT)&(1<<5))
+		{
+			/* clear illegal access status bit */
+			nfcont = readl(NFSTAT);
+			nfcont |= (1<<5);
+			writel(nfcont, NFSTAT);
+
+			printf("\n Accessed locked area!! \n");
+			
+			nfcont = readl(NFCONT);
+			nfcont |= (1<<1);
+			writel(nfcont, NFCONT);
+			
+			return -1;
+		}
+		
+		nfcont = readl(NFCONT);
+		nfcont |= (1<<1);
+		writel(nfcont, NFCONT);
+
+		
+	} else {
+		/* Lock */
+		nfcont = readl(NFCONT);
+		nfcont |= NFCONT_MECCLOCK;
+		writel(nfcont, NFCONT);
+		
+		s3c_nand_wait_enc();
+
+		/* clear 8/12/16bit ecc encode done */
+		nfcont = readl(NFECCSTAT);
+		nfcont |= (1<<25);
+		writel(nfcont, NFECCSTAT);
+
+		nfeccprgecc0 = readl(NFECCPRGECC0);
+		nfeccprgecc1 = readl(NFECCPRGECC1);
+		nfeccprgecc2 = readl(NFECCPRGECC2);
+		nfeccprgecc3 = readl(NFECCPRGECC3);
+	
+		ecc_code[0] = nfeccprgecc0 & 0xff;
+		ecc_code[1] = (nfeccprgecc0 >> 8) & 0xff;
+		ecc_code[2] = (nfeccprgecc0 >> 16) & 0xff;
+		ecc_code[3] = (nfeccprgecc0 >> 24) & 0xff;
+		ecc_code[4] = nfeccprgecc1 & 0xff;
+		ecc_code[5] = (nfeccprgecc1 >> 8) & 0xff;
+		ecc_code[6] = (nfeccprgecc1 >> 16) & 0xff;
+		ecc_code[7] = (nfeccprgecc1 >> 24) & 0xff;
+		ecc_code[8] = nfeccprgecc2 & 0xff;
+		ecc_code[9] = (nfeccprgecc2 >> 8) & 0xff;
+		ecc_code[10] = (nfeccprgecc2 >> 16) & 0xff;
+		ecc_code[11] = (nfeccprgecc2 >> 24) & 0xff;
+		ecc_code[12] = nfeccprgecc3 & 0xff;
+
+		
+
+	}
+
+	return 0;
+}
+
+int s3c_nand_correct_data_8bit(struct mtd_info *mtd, u_char *dat)
+{
+	int ret = -1;
+	u_long nf8eccerr0, nf8eccerr1, nf8eccerr2, nf8eccerr3, nf8eccerr4, nfmlc8bitpt0, nfmlc8bitpt1;
+	u_char err_type;
+
+	s3c_nand_wait_ecc_busy_8bit();
+
+	nf8eccerr0 = readl(NFECCSECSTAT);
+	nf8eccerr1 = readl(NFECCERL0);
+	nf8eccerr2 = readl(NFECCERL1);
+	nf8eccerr3 = readl(NFECCERL2);
+	nf8eccerr4 = readl(NFECCERL3);
+	nfmlc8bitpt0 = readl(NFECCERP0);
+	nfmlc8bitpt1 = readl(NFECCERP1);
+
+	err_type = (nf8eccerr0) & 0xf;
+
+	/* No error, If free page (all 0xff) */
+	if ((nf8eccerr0 >> 29) & 0x1)
+		err_type = 0;
+
+	switch (err_type) {
+	case 9: /* Uncorrectable */
+		printk("s3c-nand: ECC uncorrectable error detected\n");
+		ret = -1;
+		break;
+
+	case 8: /* 8 bit error (Correctable) */
+		dat[(nf8eccerr4 >> 16) & 0x3ff] ^= ((nfmlc8bitpt1 >> 24) & 0xff);
+
+	case 7: /* 7 bit error (Correctable) */
+		dat[(nf8eccerr4) & 0x3ff] ^= ((nfmlc8bitpt1 >> 16) & 0xff);
+
+	case 6: /* 6 bit error (Correctable) */
+		dat[(nf8eccerr3 >> 16) & 0x3ff] ^= ((nfmlc8bitpt1 >> 8) & 0xff);
+
+	case 5: /* 5 bit error (Correctable) */
+		dat[(nf8eccerr3) & 0x3ff] ^= ((nfmlc8bitpt1) & 0xff);
+
+	case 4: /* 8 bit error (Correctable) */
+		dat[(nf8eccerr2 >> 16) & 0x3ff] ^= ((nfmlc8bitpt0 >> 24) & 0xff);
+
+	case 3: /* 7 bit error (Correctable) */
+		dat[(nf8eccerr2) & 0x3ff] ^= ((nfmlc8bitpt0>> 16) & 0xff);
+
+	case 2: /* 6 bit error (Correctable) */
+		dat[(nf8eccerr1 >> 16) & 0x3ff] ^= ((nfmlc8bitpt0>> 8) & 0xff);
+
+	case 1: /* 1 bit error (Correctable) */
+		printk("s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
+		dat[(nf8eccerr1) & 0x3ff] ^= ((nfmlc8bitpt0) & 0xff);
+		ret = err_type;
+		break;
+
+	case 0: /* No error */
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+int s3c_nand_write_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{	
+	int i, eccsize = 512;
+	int eccbytes = 13;
+	int eccsteps = mtd->writesize / eccsize;
+	int badoffs = mtd->writesize == 512 ? NAND_SMALL_BADBLOCK_POS : NAND_LARGE_BADBLOCK_POS;
+
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+	
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		s3c_nand_enable_hwecc_8bit(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		s3c_nand_calculate_ecc_8bit(mtd, p, &ecc_calc[i]);
+	}
+
+	chip->oob_poi[badoffs] = 0xff;
+	for (i = 0; i <= eccbytes * (mtd->writesize / eccsize); i++) {
+		chip->oob_poi[i+12] = ecc_calc[i];
+	}
+
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+int s3c_nand_read_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf)
+{
+	int i, stat, eccsize = 512;
+	int eccbytes = 13;
+	int eccsteps = mtd->writesize / eccsize;
+	int col = 0;
+	uint8_t *p = buf;
+	
+	/* Step1: read whole oob */
+	col = mtd->writesize;
+
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col+12, -1);
+
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	col = 0;
+
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		s3c_nand_enable_hwecc_8bit(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->write_buf(mtd, chip->oob_poi + (((mtd->writesize / eccsize) - eccsteps) * eccbytes), eccbytes);
+		s3c_nand_calculate_ecc_8bit(mtd, 0, 0);
+		stat = s3c_nand_correct_data_8bit(mtd, p);
+
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * ((mtd->writesize / eccsize) + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+int s3c_nand_read_oob_8bit(struct mtd_info *mtd, struct nand_chip *chip, int page, int sndcmd)
+{
+        if (sndcmd) {
+                chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+                sndcmd = 0;
+        }
+
+        chip->read_buf(mtd, chip->oob_poi, 0); //secc_start);
+        return sndcmd;
+}
+
+int s3c_nand_write_oob_8bit(struct mtd_info *mtd, struct nand_chip *chip, int page)
+{
+        int status = 0;
+
+        chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+        /* spare area */
+        chip->write_buf(mtd, chip->oob_poi, 0); //secc_start);
+
+        /* Send command to program the OOB data */
+        chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+        status = chip->waitfunc(mtd, chip);
+        return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/********************************************************/
+#endif
+
+static int s3c_nand_write_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+			      int page)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int status = 0;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+	int i;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+static int s3c_nand_read_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+			     int page)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+#if 0
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+#endif
+
+	return 0;
+}
+
+static int s3c_nand_write_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf, int oob_required, int page)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[eccpos[i]] = ecc_calc[i];
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	return 0;
+}
+
+static int s3c_nand_read_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int oob_required, int page)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	int col = 0;
+	uint8_t *p = buf;
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+#if 0
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+#endif
+
+	col = 0;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+
+		stat = chip->ecc.correct(mtd, p, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), 0);
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+/*
+ * Hardware specific page read function for MLC.
+ * Written by jsgood
+ */
+static int s3c_nand_read_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int oob_required, int page)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int col = 0;
+	uint8_t *p = buf;
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+
+	/* Step1: read whole oob */
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	col = 0;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->write_buf(mtd, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), eccbytes);
+		chip->ecc.calculate(mtd, 0, 0);
+		stat = chip->ecc.correct(mtd, p, 0, 0);
+
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+/*
+ * Hardware specific page write function for MLC.
+ * Written by jsgood
+ */
+static int s3c_nand_write_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf, int oob_required, int page)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const uint8_t *p = buf;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+
+	/* Step1: write main data and encode mecc */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	/* Step2: save encoded mecc */
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[mecc_pos[i]] = ecc_calc[i];
+
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+#endif
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+#if defined(CONFIG_S5P_NAND_HWECC)
+	int i;
+	u_char tmp, cellinfo;
+	struct nand_flash_dev *type = NULL;
+#endif
+	pr_debug("%s() in\n", __func__);
+
+	NFCONT_REG 		&= ~NFCONT_WP;
+	nand->IO_ADDR_R		= (void __iomem *)(NFDATA);
+	nand->IO_ADDR_W		= (void __iomem *)(NFDATA);
+	nand->cmd_ctrl		= s3c_nand_hwcontrol;
+	nand->dev_ready		= s3c_nand_device_ready;
+	nand->options		= 0;
+
+#if defined(CFG_NAND_FLASH_BBT)
+		nand->options 		|= NAND_USE_FLASH_BBT;
+#else
+		nand->options		|= NAND_SKIP_BBTSCAN;
+#endif
+
+#if defined(CONFIG_S5P_NAND_HWECC)
+	nand->ecc.mode		= NAND_ECC_HW;
+	nand->ecc.hwctl		= s3c_nand_enable_hwecc;
+	nand->ecc.calculate	= s3c_nand_calculate_ecc;
+	nand->ecc.correct	= s3c_nand_correct_data;
+
+	s3c_nand_hwcontrol(0, NAND_CMD_READID, NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+	s3c_nand_hwcontrol(0, 0x00, NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE);
+	s3c_nand_hwcontrol(0, 0x00, NAND_NCE | NAND_ALE);
+	s3c_nand_hwcontrol(0, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+	s3c_nand_device_ready(0);
+
+	tmp = readb(nand->IO_ADDR_R); /* Maf. ID */
+	tmp = readb(nand->IO_ADDR_R); /* Device ID */
+
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (tmp == nand_flash_ids[i].dev_id) {
+			type = &nand_flash_ids[i];
+			break;
+		}
+	}
+
+	pr_debug("type->name=\"%s\"\n", type->name);
+
+	cellinfo = readb(nand->IO_ADDR_R);		/* 3rd byte */
+	tmp = readb(nand->IO_ADDR_R);			/* 4th byte */
+
+	if (!type->pagesize) {
+		if (((cellinfo >> 2) & 0x3) == 0) {
+			nand_type = S3C_NAND_TYPE_SLC;
+			nand->ecc.size = 512;
+			nand->ecc.bytes	= 4;
+			nand->ecc.strength = 1;
+
+			if ((1024 << (tmp & 0x3)) > 512) {
+				nand->ecc.read_page = s3c_nand_read_page_1bit;
+				nand->ecc.write_page = s3c_nand_write_page_1bit;
+				nand->ecc.read_oob = s3c_nand_read_oob_1bit;
+				nand->ecc.write_oob = s3c_nand_write_oob_1bit;
+				nand->ecc.layout = &s3c_nand_oob_64;
+				nand->ecc.hwctl = s3c_nand_enable_hwecc;
+                                nand->ecc.calculate = s3c_nand_calculate_ecc;
+                                nand->ecc.correct = s3c_nand_correct_data;
+                                nand->options |= NAND_NO_SUBPAGE_WRITE;
+			} else {
+				nand->ecc.layout = &s3c_nand_oob_16;
+			}
+		} else {
+			nand_type = S3C_NAND_TYPE_MLC;
+			nand->options |= NAND_NO_SUBPAGE_WRITE;	/* NOP = 1 if MLC */
+			nand->ecc.read_page = s3c_nand_read_page_4bit;
+			nand->ecc.write_page = s3c_nand_write_page_4bit;
+			nand->ecc.size = 512;
+			nand->ecc.bytes = 8;	/* really 7 bytes */
+			nand->ecc.layout = &s3c_nand_oob_mlc_64;
+			nand->ecc.strength = 1;
+		}
+	} else {
+		nand_type = S3C_NAND_TYPE_SLC;
+		nand->ecc.size = 512;
+		nand->ecc.bytes = 4;
+		nand->ecc.layout = &s3c_nand_oob_16;
+		nand->ecc.strength = 1;
+	}
+#else
+	nand->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+	return 0;
+}
+
diff --git a/include/configs/gec210.h b/include/configs/gec210.h
index adbb872..b95a833 100755
--- a/include/configs/gec210.h
+++ b/include/configs/gec210.h
@@ -18,12 +18,13 @@
  */
 #define CONFIG_SAMSUNG		1	/* in a SAMSUNG core */
 #define CONFIG_S5P		1	/* which is in a S5P Family */
+#define CONFIG_S5PC110		1	/* which is in a S5PC110 / S5PV210 */
 #if 0
-#define CONFIG_S5PV210		1	/* which is in a S5PV210 */
 #define CONFIG_GEC210		1	/* working with GEC210 */
 #endif
 
 #include <asm/arch/cpu.h>		/* get chip and board defs */
+#include <asm/arch/s5pc110.h>
 
 #define CONFIG_ARCH_CPU_INIT
 
@@ -118,6 +119,11 @@
 	"ubiblock=4\0" \
 	"ubi=enabled"
 
+#define CONFIG_NETMASK          255.255.255.0
+#define CONFIG_IPADDR		192.168.1.48
+#define CONFIG_SERVERIP		192.168.1.46
+#define CONFIG_GATEWAYIP	192.168.1.1
+
 /*-----------------------------------------------------------------------
  * System clock configuration
  */
@@ -214,6 +220,9 @@
 /*-----------------------------------------------------------------------
  * FLASH and environment organization
  */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0xb0e00010
+#define CFG_NAND_PAGES_IN_BLOCK		64
 
 #define CONFIG_SYS_MONITOR_LEN		(256 << 10)	/* 256 KiB */
 
@@ -241,21 +250,21 @@
 #define CONFIG_ENV_OFFSET		(256 << 10)	/* 256KiB, 0x40000 */
 
 /* nand copy size from nand to DRAM.*/
+#define	COPY_BL1_SIZE		(8 << 10)	/* for irom's BL0 copy */
 #define	COPY_BL2_SIZE		0x80000
 
-#if 0
-#define CONFIG_USE_ONENAND_BOARD_INIT
-#define CONFIG_SAMSUNG_ONENAND		1
-#define CONFIG_SYS_ONENAND_BASE		0xE7100000
-#endif
-
 #define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_LOAD_ADDR - 0x1000000)
 
 /*
  * Ethernet Contoller driver
  */
+#define CONFIG_DRIVER_DM9000		1
+#define CONFIG_DM9000_BASE		(0x88000000)
+#define DM9000_IO			(CONFIG_DM9000_BASE)
+#define DM9000_DATA			(CONFIG_DM9000_BASE+8)
+
 #ifdef CONFIG_CMD_NET
-#define CONFIG_ENV_SROM_BANK   3       /* Select SROM Bank-3 for Ethernet*/
+#define CONFIG_ENV_SROM_BANK   1       /* Select SROM Bank-1 for Ethernet*/
 #endif /* CONFIG_CMD_NET */
 
 #endif	/* __CONFIG_H */
