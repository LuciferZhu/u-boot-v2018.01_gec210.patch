diff --git a/Makefile b/Makefile
index d8f419b..5d919ea 100644
--- a/Makefile
+++ b/Makefile
@@ -330,6 +330,7 @@ scripts/Kbuild.include: ;
 include scripts/Kbuild.include
 
 # Make variables (CC, etc...)
+CROSS_COMPILE	?= /usr/local/arm/gcc-linaro-7.2.1-2017.11-i686_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
 
 AS		= $(CROSS_COMPILE)as
 # Always use GNU ld
@@ -355,7 +356,7 @@ CHECK		= sparse
 CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
 		  -Wbitwise -Wno-return-void -D__CHECK_ENDIAN__ $(CF)
 
-KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__
+KBUILD_CPPFLAGS := -D__KERNEL__ -D__UBOOT__ #-DDEBUG
 
 KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \
 		   -Wno-format-security \
@@ -1030,7 +1031,7 @@ u-boot.sha1:	u-boot.bin
 		tools/ubsha1 u-boot.bin
 
 u-boot.dis:	u-boot
-		$(OBJDUMP) -d $< > $@
+		$(OBJDUMP) -D $< > $@
 
 ifdef CONFIG_TPL
 SPL_PAYLOAD := tpl/u-boot-with-tpl.bin
diff --git a/arch/arm/cpu/armv7/start.S b/arch/arm/cpu/armv7/start.S
index 95a0b52..ac56503 100644
--- a/arch/arm/cpu/armv7/start.S
+++ b/arch/arm/cpu/armv7/start.S
@@ -18,6 +18,7 @@
 #include <asm/system.h>
 #include <linux/linkage.h>
 #include <asm/armv7.h>
+#include <asm/arch/s5pc110.h>
 
 /*************************************************************************
  *
@@ -28,6 +29,11 @@
  * Relocate armboot to ram. Setup stack.
  *
  *************************************************************************/
+_TEXT_PHY_BASE:
+	.word	CONFIG_SYS_TEXT_BASE
+
+copy_sd_mmc_to_mem:
+	.word	0xD0037F98
 
 	.globl	reset
 	.globl	save_boot_params_ret
@@ -86,7 +92,98 @@ switch_to_hypervisor_ret:
 #endif
 #endif
 
-	bl	_main
+/*
+ * load BL2 into DDR
+ */
+	/* get ready to call C functions */
+	ldr	sp, _TEXT_PHY_BASE	/* setup temp stack pointer */
+	sub	sp, sp, #12
+	mov	fp, #0			/* no previous frame, so fp=0 */
+
+	/* when we already run in ram, we do not need to relocate U-Boot.
+	 * and actually, memory controller must be configured before U-Boot
+	 * is running in ram.
+	 */
+	ldr	r0, =0xff000fff
+	bic	r1, pc, r0		/* r0 <- current base addr of code */
+	ldr	r2, _TEXT_PHY_BASE	/* r1 <- original base addr in ram */
+	bic	r2, r2, r0		/* r0 <- current base addr of code */
+	cmp     r1, r2                  /* compare r0, r1                  */
+	beq     after_copy		/* r0 == r1 then skip flash copy   */
+
+	/*
+         * Read booting information.
+         */
+        ldr	r0, =PRO_ID_BASE
+        ldr	r1, [r0,#OMR_OFFSET]
+        bic	r2, r1, #0xffffffc1
+
+	/* NAND BOOT */
+	cmp	r2, #0x0		@ eSSD
+	moveq	r3, #BOOT_NAND
+
+	cmp	r2, #0x2		@ 2KB 5-cycle	8-bit ECC
+	moveq	r3, #BOOT_NAND
+
+	cmp	r2, #0x4		@ 4KB 5-cycle	8-bit ECC
+	moveq	r3, #BOOT_NAND
+
+	cmp	r2, #0x6		@ 4KB 5-cycle	16-bit ECC
+	moveq	r3, #BOOT_NAND
+
+	cmp	r2, #0x8		@ OneNAND Mux
+	moveq	r3, #BOOT_ONENAND
+
+	/* SD/MMC BOOT */
+	cmp     r2, #0xc
+	moveq   r3, #BOOT_MMCSD
+
+	/* NOR BOOT */
+	cmp     r2, #0x14
+	moveq   r3, #BOOT_NOR
+
+	/* Uart BOOTONG failed */
+	cmp     r2, #(0x1<<4)
+	moveq   r3, #BOOT_SEC_DEV
+
+	ldr	r0, =INF_REG_BASE
+	str	r3, [r0, #INF_REG3_OFFSET]
+
+	/*
+	 * copy u-boot from specific device.
+	 */
+	ldr	r0, =INF_REG_BASE
+	ldr	r1, [r0, #INF_REG3_OFFSET]
+	cmp	r1, #BOOT_NAND		/* 0x0 => boot device is nand */
+	beq	nand_boot
+	cmp	r1, #BOOT_ONENAND	/* 0x1 => boot device is onenand */
+	beq	onenand_boot
+	cmp     r1, #BOOT_MMCSD
+	beq     mmcsd_boot
+	cmp     r1, #BOOT_NOR
+	beq     nor_boot
+	cmp     r1, #BOOT_SEC_DEV
+	beq     mmcsd_boot
+
+nand_boot:
+	mov	r0, #0x1000
+	bl	copy_from_nand
+	b	after_copy
+
+onenand_boot:
+	b	onenand_boot
+
+mmcsd_boot:
+	bl      copy_from_mmcsd
+	b       after_copy
+
+nor_boot:
+	b       nor_boot
+
+
+after_copy:
+	ldr	pc, =_main		@ jump into ddr
+
 
 /*------------------------------------------------------------------------------*/
 
@@ -325,3 +422,81 @@ ENTRY(cpu_init_crit)
 	b	lowlevel_init		@ go setup pll,mux,memory
 ENDPROC(cpu_init_crit)
 #endif
+
+
+/*************************************************************************
+ *
+ * copy U-Boot to SDRAM and jump to ram (from NAND or OneNAND)
+ * r0: size to be compared
+ * Load 1'st 2blocks to RAM because U-boot's size is larger than 1block(128k) size
+ *
+ *************************************************************************/
+ENTRY(copy_from_nand)
+	push	{lr}		/* save return address */
+
+	mov	r9, r0
+
+	mov	r9, #0x100		/* Compare about 8KB */
+	bl	copy_uboot_to_ram
+	tst 	r0, #0x0
+	bne	copy_failed
+
+	ldr	r0, =0xd0020000
+
+	ldr	r1, _TEXT_PHY_BASE
+
+#if !defined(CONFIG_SECURE_BOOT)
+1:	ldr	r3, [r0], #4
+	ldr	r4, [r1], #4
+	teq	r3, r4
+	bne	compare_failed	/* not matched */
+	subs	r9, r9, #4
+	bne	1b
+#endif
+	pop	{pc}		/* all is OK */
+
+copy_failed:
+	nop			/* copy from nand failed */
+	b	copy_failed
+
+compare_failed:
+	nop			/* compare failed */
+	b	compare_failed
+ENDPROC(copy_from_nand)
+
+
+/*************************************************************************
+ *
+ * copy U-Boot to SDRAM and jump to ram (from SD/MMC)
+ * size align with a block (512Byte)
+ *
+ *************************************************************************/
+ENTRY(copy_from_mmcsd)
+	push	{lr}		/* save return address */
+
+	/* @param_0 channel */
+	ldr	r0, =0
+
+	/* @param_1 u32 StartBlkAddress */
+	ldr	r1, =49		@ BL1 at block1,BL2 at block49
+
+	/* @param_2 u16 blockSize */
+	ldr	r2, =512<<10	@ 512kB, BL2 should include dtb file
+	lsr	r2, #9		@ r2 >>= 9, as r2/=512
+	add	r2, #1		@ r2 += 1
+
+	/* @param_3 u32* memoryPtr */
+	ldr	r3, _TEXT_PHY_BASE
+
+	/* @param_4 bool with_init */
+	ldr	r4, =0		@ no init
+	push	{r4}		@ fourth arg at stack
+
+	ldr	r4, copy_sd_mmc_to_mem
+	mov	lr, pc
+	ldr	pc, [r4]
+
+	pop	{r4, pc}
+
+ENDPROC(copy_from_mmcsd)
+
diff --git a/arch/arm/cpu/u-boot.lds b/arch/arm/cpu/u-boot.lds
index 37d4c60..6c3feac 100644
--- a/arch/arm/cpu/u-boot.lds
+++ b/arch/arm/cpu/u-boot.lds
@@ -44,6 +44,9 @@ SECTIONS
 		*(.__image_copy_start)
 		*(.vectors)
 		CPUDIR/start.o (.text*)
+		board/samsung/gec210/lowlevel_init.o (.text*)
+		board/samsung/gec210/mem_init.o (.text*)
+		board/samsung/gec210/nand_cp.o (.text*)
 		*(.text*)
 	}
 
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index a895c70..19b85b3 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -9,6 +9,7 @@ dtb-$(CONFIG_AT91FAMILY) += at91sam9260-smartweb.dtb \
 
 dtb-$(CONFIG_S5PC100) += s5pc1xx-smdkc100.dtb
 dtb-$(CONFIG_S5PC110) += s5pc1xx-goni.dtb
+dtb-$(CONFIG_S5PV210) += s5pc1xx-gec210.dtb 
 dtb-$(CONFIG_EXYNOS4) += exynos4210-origen.dtb \
 	exynos4210-smdkv310.dtb \
 	exynos4210-universal_c210.dtb \
diff --git a/arch/arm/dts/s5pc1xx-gec210.dts b/arch/arm/dts/s5pc1xx-gec210.dts
new file mode 100644
index 0000000..5b84dba
--- /dev/null
+++ b/arch/arm/dts/s5pc1xx-gec210.dts
@@ -0,0 +1,36 @@
+/*
+ * Samsung's Exynos4210-based SMDKV310 board device tree source
+ *
+ * Copyright (c) 2014 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+#include "skeleton.dtsi"
+#include "s5pc110-pinctrl.dtsi"
+
+/ {
+	model = "Samsung GEC210 based on S5PV210";
+	compatible = "samsung,gec210", "samsung,s5pc110";
+
+	aliases {
+		serial0 = "/serial@e2900000";
+		console = "/serial@e2900000";
+		pinctrl0 = &pinctrl0;
+	};
+
+	pinctrl0: pinctrl@e0200000 {
+		compatible = "samsung,s5pc110-pinctrl";
+		reg = <0xe0200000 0x1000>;
+	};
+
+	serial@e2900000 {
+		compatible = "samsung,exynos4210-uart";
+		reg = <0xe2900000 0x400>;
+		interrupts = <10>;
+		id = <0>;
+	};
+
+};
diff --git a/arch/arm/include/asm/config.h b/arch/arm/include/asm/config.h
index 9f17829..c5d7658 100644
--- a/arch/arm/include/asm/config.h
+++ b/arch/arm/include/asm/config.h
@@ -1,4 +1,4 @@
-/*
+﻿/*
  * Copyright 2009 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -8,7 +8,7 @@
 #define _ASM_CONFIG_H_
 
 #define CONFIG_LMB
-#define CONFIG_SYS_BOOT_RAMDISK_HIGH
+/* #define CONFIG_SYS_BOOT_RAMDISK_HIGH */
 
 #if defined(CONFIG_ARCH_LS1021A) || \
 	defined(CONFIG_CPU_PXA27X) || \
diff --git a/arch/arm/mach-s5pc1xx/Kconfig b/arch/arm/mach-s5pc1xx/Kconfig
index 04acdaa..ba6cd8a 100644
--- a/arch/arm/mach-s5pc1xx/Kconfig
+++ b/arch/arm/mach-s5pc1xx/Kconfig
@@ -12,6 +12,10 @@ config TARGET_SMDKC100
 	bool "Support smdkc100 board"
 	select OF_CONTROL
 
+config TARGET_GEC210
+	bool "Support gec210 board"
+	select OF_CONTROL
+
 endchoice
 
 config SYS_SOC
@@ -19,5 +23,6 @@ config SYS_SOC
 
 source "board/samsung/goni/Kconfig"
 source "board/samsung/smdkc100/Kconfig"
+source "board/samsung/gec210/Kconfig"
 
 endif
diff --git a/arch/arm/mach-s5pc1xx/include/mach/boot0.h b/arch/arm/mach-s5pc1xx/include/mach/boot0.h
new file mode 100644
index 0000000..9d672cd
--- /dev/null
+++ b/arch/arm/mach-s5pc1xx/include/mach/boot0.h
@@ -0,0 +1,13 @@
+﻿/*
+ * Copyright 2018 Lucifer Zhu, LuciferZhu@yeah.net.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/* BOOT0 header information */
+	.word COPY_BL1_SIZE		@ indicate BL1 size for irom
+	.word 0x0
+	.word 0x0
+	.word 0x0
+_start:
+	ARM_VECTORS
diff --git a/arch/arm/mach-s5pc1xx/include/mach/s5pc110.h b/arch/arm/mach-s5pc1xx/include/mach/s5pc110.h
new file mode 100644
index 0000000..34d9892
--- /dev/null
+++ b/arch/arm/mach-s5pc1xx/include/mach/s5pc110.h
@@ -0,0 +1,1881 @@
+﻿/*
+ * (C) Copyright 2008
+ * Jongpill Lee, Samsung Erectronics, boyko.lee@samsung.com.
+ *      - only support for S5PC110
+ *  $Id: s5pc100.h,v 1.4 2008/11/25 06:15:10 boyko Exp $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/************************************************
+ * NAME	    : s5pc110.h
+ *
+ ************************************************/
+
+#ifndef __S5PC110_H__
+#define __S5PC110_H__
+
+
+#define __REG(x)	(*(volatile unsigned long*)(x))
+#define __REGb(x)	(*(volatile unsigned char*)(x))
+
+
+#ifndef CONFIG_S5PC110
+#define CONFIG_S5PC110			1
+#endif
+
+#if 0
+#define S5PC11X_UART_CHANNELS		3
+#define S5PC11X_SPI_CHANNELS		2
+
+#include <asm/hardware.h>
+
+#ifndef __ASSEMBLY__
+typedef enum {
+	S5PC11X_UART0,
+	S5PC11X_UART1,
+	S5PC11X_UART2,
+	S5PC11X_UART3,
+} S5PC11X_UARTS_NR;
+
+#include <s5pc11x.h>
+#endif
+#endif
+
+#define BIT0 				0x00000001
+#define BIT1 				0x00000002
+#define BIT2 				0x00000004
+#define BIT3 				0x00000008
+#define BIT4 				0x00000010
+#define BIT5 				0x00000020
+#define BIT6				0x00000040
+#define BIT7				0x00000080
+#define BIT8				0x00000100
+#define BIT9				0x00000200
+#define BIT10				0x00000400
+#define BIT11				0x00000800
+#define BIT12				0x00001000
+#define BIT13				0x00002000
+#define BIT14				0x00004000
+#define BIT15				0x00008000
+#define BIT16				0x00010000
+#define BIT17				0x00020000
+#define BIT18				0x00040000
+#define BIT19				0x00080000
+#define BIT20				0x00100000
+#define BIT21				0x00200000
+#define BIT22				0x00400000
+#define BIT23				0x00800000
+#define BIT24				0x01000000
+#define BIT25				0x02000000
+#define BIT26				0x04000000
+#define BIT27				0x08000000
+#define BIT28				0x10000000
+#define BIT29				0x20000000
+#define BIT30				0x40000000
+#define BIT31				0x80000000
+
+/* S5PC110 device base addresses */
+#define ELFIN_DMA_BASE			0xE0900000
+#define ELFIN_LCD_BASE			0xF8000000
+#define ELFIN_USB_HOST_BASE		0xEC200000
+#define ELFIN_I2C_BASE			0xE1800000
+#define ELFIN_I2S_BASE			0xE2100000
+#define ELFIN_ADC_BASE			0xE1700000
+#define ELFIN_SPI_BASE			0xE1300000
+
+
+#define ELFIN_HSMMC_0_BASE		0xEB000000
+#define ELFIN_HSMMC_1_BASE		0xEB100000
+#define ELFIN_HSMMC_2_BASE		0xEB200000
+#define ELFIN_HSMMC_3_BASE		0xEB300000
+
+#define ELFIN_CLOCK_POWER_BASE		0xE0100000
+
+#define ELFIN_TZPC0_BASE		0xF1500000
+#define ELFIN_TZPC1_BASE		0xFAD00000
+#define ELFIN_TZPC2_BASE		0xE0600000
+#define ELFIN_TZPC3_BASE		0xE1C00000
+
+#define IO_RET_REL			((1 << 31) | (1 << 29) | (1 << 28)) 
+
+/* Clock & Power Controller for s5pc110*/
+#define APLL_LOCK_OFFSET		0x00
+#define MPLL_LOCK_OFFSET		0x08
+#define EPLL_LOCK_OFFSET		0x10
+#define VPLL_LOCK_OFFSET		0x20
+#define APLL_CON0_OFFSET		0x100
+#define APLL_CON1_OFFSET		0x104
+#define MPLL_CON_OFFSET			0x108
+#define EPLL_CON_OFFSET			0x110
+#define VPLL_CON_OFFSET			0x120
+
+#define CLK_SRC0_OFFSET			0x200
+#define CLK_SRC1_OFFSET			0x204
+#define CLK_SRC2_OFFSET			0x208
+#define CLK_SRC3_OFFSET			0x20c
+#define CLK_SRC4_OFFSET			0x210
+#define CLK_SRC5_OFFSET			0x214
+#define CLK_SRC6_OFFSET			0x218
+#define CLK_SRC_MASK0_OFFSET		0x280
+#define CLK_SRC_MASK1_OFFSET		0x284
+
+#define CLK_DIV0_OFFSET			0x300
+#define CLK_DIV1_OFFSET			0x304
+#define CLK_DIV2_OFFSET			0x308
+#define CLK_DIV3_OFFSET			0x30c
+#define CLK_DIV4_OFFSET			0x310
+#define CLK_DIV5_OFFSET			0x314
+#define CLK_DIV6_OFFSET			0x318
+#define CLK_DIV7_OFFSET			0x31c
+
+#define CLK_GATE_IP0_OFFSET		0x460
+#define CLK_GATE_IP1_OFFSET		0x464
+#define CLK_GATE_IP2_OFFSET		0x468
+#define CLK_GATE_IP3_OFFSET		0x46c
+#define CLK_GATE_IP4_OFFSET		0x470
+#define CLK_GATE_BLOCK_OFFSET		0x480
+
+#define CLK_OUT_OFFSET			0x500
+#define CLK_DIV_STAT0_OFFSET		0x1000
+#define CLK_DIV_STAT1_OFFSET		0x1004
+#define CLK_MUX_STAT0_OFFSET		0x1100
+#define CLK_MUX_STAT1_OFFSET		0x1104
+#define SW_RST_OFFSET			0x2000
+
+#define ONEDRAM_CFG_OFFSET		0x6208
+
+#define OSC_CON_OFFSET			0x8000
+#define RST_STAT_OFFSET			0xa000
+#define PWR_CFG_OFFSET			0xc000
+#define	EINT_WAKEUP_MASK_OFFSET		0xc004
+#define WAKEUP_MASK_OFFSET		0xc008
+#define NORMAL_CFG_OFFSET		0xc010
+#define IDLE_CFG_OFFSET			0xc020
+#define STOP_CFG_OFFSET			0xc030
+#define STOP_MEM_CFG_OFFSET		0xc034
+#define SLEEP_CFG_OFFSET		0xc040
+#define OSC_FREQ_OFFSET			0xc100
+#define OSC_STABLE_OFFSET		0xc104
+#define PWR_STABLE_OFFSET		0xc108
+#define MTC_STABLE_OFFSET		0xc110
+#define CLAMP_STABLE_OFFSET		0xc114
+#define WAKEUP_STAT_OFFSET		0xc200
+#define BLK_PWR_STAT_OFFSET		0xc204
+#define BODY_BIAS_CON_OFFSET		0xc300
+#define ION_SKEW_CON_OFFSET		0xc310
+#define ION_SKEW_MON_OFFSET		0xc314
+#define IOFF_SKEW_CON_OFFSET		0xc320
+#define IOFF_SKEW_MON_OFFSET		0xc324
+#define OTHERS_OFFSET			0xe000
+#define OM_STAT_OFFSET			0xe100
+#define MIE_CONTROL_OFFSET		0xe800
+#define HDMI_CONTROL_OFFSET		0xe804
+#define USB_PHY_CONTROL_OFFSET		0xe80c
+#define DAC_CONTROL_OFFSET		0xe810
+#define MIPI_DPHY_CONTROL_OFFSET	0xe814
+#define ADC_CONTROL_OFFSET		0xe818
+#define PS_HOLD_CONTROL_OFFSET		0xe81c
+
+#define INFORM0_OFFSET			0xf000
+#define INFORM1_OFFSET			0xf004
+#define INFORM2_OFFSET			0xf008
+#define INFORM3_OFFSET			0xf00c
+#define INFORM4_OFFSET			0xf010
+#define INFORM5_OFFSET			0xf014
+#define INFORM6_OFFSET			0xf018
+#define INFORM7_OFFSET			0xf01c
+
+#define INF_REG0_OFFSET			0x00
+#define INF_REG1_OFFSET			0x04
+#define INF_REG2_OFFSET			0x08
+#define INF_REG3_OFFSET			0x0c
+#define INF_REG4_OFFSET			0x10
+#define INF_REG5_OFFSET			0x14
+#define INF_REG6_OFFSET			0x18
+#define INF_REG7_OFFSET			0x1c
+
+#define APLL_LOCK_REG			__REG(ELFIN_CLOCK_POWER_BASE+APLL_LOCK_OFFSET)
+#define MPLL_LOCK_REG			__REG(ELFIN_CLOCK_POWER_BASE+MPLL_LOCK_OFFSET
+#define EPLL_LOCK_REG			__REG(ELFIN_CLOCK_POWER_BASE+EPLL_LOCK_OFFSET)
+#define HPLL_LOCK_REG			__REG(ELFIN_CLOCK_POWER_BASE+HPLL_LOCK_OFFSET)
+#define APLL_CON0_REG			__REG(ELFIN_CLOCK_POWER_BASE+APLL_CON0_OFFSET)
+#define APLL_CON1_REG			__REG(ELFIN_CLOCK_POWER_BASE+APLL_CON1_OFFSET)
+#define MPLL_CON_REG			__REG(ELFIN_CLOCK_POWER_BASE+MPLL_CON_OFFSET)
+#define EPLL_CON_REG			__REG(ELFIN_CLOCK_POWER_BASE+EPLL_CON_OFFSET)
+#define HPLL_CON_REG			__REG(ELFIN_CLOCK_POWER_BASE+HPLL_CON_OFFSET)
+#define CLK_SRC0_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC0_OFFSET)
+#define CLK_SRC1_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC1_OFFSET)
+#define CLK_SRC2_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC2_OFFSET)
+#define CLK_SRC3_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC3_OFFSET)
+#define CLK_SRC4_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC4_OFFSET)
+#define CLK_DIV0_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV0_OFFSET)
+#define CLK_DIV1_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV1_OFFSET)
+#define CLK_DIV2_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV2_OFFSET)
+#define CLK_DIV3_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV3_OFFSET)
+#define CLK_DIV4_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV4_OFFSET)
+#define CLK_DIV5_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV5_OFFSET)
+#define CLK_DIV6_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV6_OFFSET)
+#define CLK_DIV7_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV7_OFFSET)
+
+#define CLK_OUT_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_OUT_OFFSET)
+
+#define CLK_GATE_IP0_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP0_OFFSET)
+#define CLK_GATE_IP1_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP1_OFFSET)
+#define CLK_GATE_IP2_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP2_OFFSET)
+#define CLK_GATE_IP3_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP3_OFFSET)
+#define CLK_GATE_IP4_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP4_OFFSET)
+#define CLK_GATE_BLOCK_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_BLOCK_OFFSET)
+
+#define CLK_DIV_STAT0_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV_STAT0_OFFSET)
+#define CLK_DIV_STAT1_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV_STAT1_OFFSET)
+#define CLK_MUX_STAT0_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_MUX_STAT0_OFFSET)
+#define CLK_MUX_STAT1_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_MUX_STAT1_OFFSET)
+
+
+#define AHB_CON0_REG			__REG(ELFIN_CLOCK_POWER_BASE+AHB_CON0_OFFSET)
+#define AHB_CON1_REG			__REG(ELFIN_CLOCK_POWER_BASE+AHB_CON1_OFFSET)
+#define AHB_CON2_REG			__REG(ELFIN_CLOCK_POWER_BASE+AHB_CON2_OFFSET)
+#define SELECT_DMA_REG			__REG(ELFIN_CLOCK_POWER_BASE+SELECT_DMA_OFFSET)
+#define SW_RST_REG			__REG(ELFIN_CLOCK_POWER_BASE+SW_RST_OFFSET)
+#define SYS_ID_REG			__REG(ELFIN_CLOCK_POWER_BASE+SYS_ID_OFFSET)
+#define MEM_SYS_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+MEM_SYS_CFG_OFFSET)
+#define QOS_OVERRIDE0_REG		__REG(ELFIN_CLOCK_POWER_BASE+QOS_OVERRIDE0_OFFSET)
+#define QOS_OVERRIDE1_REG		__REG(ELFIN_CLOCK_POWER_BASE+QOS_OVERRIDE1_OFFSET)
+#define MEM_CFG_STAT_REG		__REG(ELFIN_CLOCK_POWER_BASE+MEM_CFG_STAT_OFFSET)
+#define PWR_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+PWR_CFG_OFFSET)
+#define EINT_MASK_REG			__REG(ELFIN_CLOCK_POWER_BASE+EINT_MASK_OFFSET)
+#define NOR_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+NOR_CFG_OFFSET)
+#define STOP_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+STOP_CFG_OFFSET)
+#define SLEEP_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+SLEEP_CFG_OFFSET)
+#define OSC_FREQ_REG			__REG(ELFIN_CLOCK_POWER_BASE+OSC_FREQ_OFFSET)
+#define OSC_CNT_VAL_REG			__REG(ELFIN_CLOCK_POWER_BASE+OSC_CNT_VAL_OFFSET)
+#define PWR_CNT_VAL_REG			__REG(ELFIN_CLOCK_POWER_BASE+PWR_CNT_VAL_OFFSET)
+#define FPC_CNT_VAL_REG			__REG(ELFIN_CLOCK_POWER_BASE+FPC_CNT_VAL_OFFSET)
+#define MTC_CNT_VAL_REG			__REG(ELFIN_CLOCK_POWER_BASE+MTC_CNT_VAL_OFFSET)
+#define OTHERS_REG			__REG(ELFIN_CLOCK_POWER_BASE+OTHERS_OFFSET)
+#define RST_STAT_REG			__REG(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)
+#define WAKEUP_STAT_REG			__REG(ELFIN_CLOCK_POWER_BASE+WAKEUP_STAT_OFFSET)
+#define BLK_PWR_STAT_REG		__REG(ELFIN_CLOCK_POWER_BASE+BLK_PWR_STAT_OFFSET)
+
+#define PRO_ID_BASE			0xE0000000
+#define PRO_ID_OFFSET			0x00
+#define OMR_OFFSET			0x04
+
+#define INF_REG_BASE			0xE010F000
+
+#define INF_REG0_REG			__REG(INF_REG_BASE+INF_REG0_OFFSET)
+#define INF_REG1_REG			__REG(INF_REG_BASE+INF_REG1_OFFSET)
+#define INF_REG2_REG			__REG(INF_REG_BASE+INF_REG2_OFFSET)
+#define INF_REG3_REG			__REG(INF_REG_BASE+INF_REG3_OFFSET)
+#define INF_REG4_REG			__REG(INF_REG_BASE+INF_REG4_OFFSET)
+#define INF_REG5_REG			__REG(INF_REG_BASE+INF_REG5_OFFSET)
+#define INF_REG6_REG			__REG(INF_REG_BASE+INF_REG6_OFFSET)
+#define INF_REG7_REG			__REG(INF_REG_BASE+INF_REG7_OFFSET)
+
+#define APLL_LOCK			(ELFIN_CLOCK_POWER_BASE+APLL_LOCK_OFFSET)
+#define MPLL_LOCK			(ELFIN_CLOCK_POWER_BASE+MPLL_LOCK_OFFSET)
+#define EPLL_LOCK			(ELFIN_CLOCK_POWER_BASE+EPLL_LOCK_OFFSET)
+#define APLL_CON			(ELFIN_CLOCK_POWER_BASE+APLL_CON_OFFSET)
+#define MPLL_CON			(ELFIN_CLOCK_POWER_BASE+MPLL_CON_OFFSET)
+#define EPLL_CON0			(ELFIN_CLOCK_POWER_BASE+EPLL_CON0_OFFSET)
+#define EPLL_CON1			(ELFIN_CLOCK_POWER_BASE+EPLL_CON1_OFFSET)
+#define CLK_SRC				(ELFIN_CLOCK_POWER_BASE+CLK_SRC_OFFSET)
+#define CLK_DIV0			(ELFIN_CLOCK_POWER_BASE+CLK_DIV0_OFFSET)
+#define CLK_DIV1			(ELFIN_CLOCK_POWER_BASE+CLK_DIV1_OFFSET)
+#define CLK_DIV2			(ELFIN_CLOCK_POWER_BASE+CLK_DIV2_OFFSET)
+#define CLK_OUT				(ELFIN_CLOCK_POWER_BASE+CLK_OUT_OFFSET)
+#define HCLK_GATE			(ELFIN_CLOCK_POWER_BASE+HCLK_GATE_OFFSET)
+#define PCLK_GATE			(ELFIN_CLOCK_POWER_BASE+PCLK_GATE_OFFSET)
+#define SCLK_GATE			(ELFIN_CLOCK_POWER_BASE+SCLK_GATE_OFFSET)
+#define AHB_CON0			(ELFIN_CLOCK_POWER_BASE+AHB_CON0_OFFSET)
+#define AHB_CON1			(ELFIN_CLOCK_POWER_BASE+AHB_CON1_OFFSET)
+#define AHB_CON2			(ELFIN_CLOCK_POWER_BASE+AHB_CON2_OFFSET)
+#define SELECT_DMA			(ELFIN_CLOCK_POWER_BASE+SELECT_DMA_OFFSET)
+#define SW_RST				(ELFIN_CLOCK_POWER_BASE+SW_RST_OFFSET)
+#define SYS_ID				(ELFIN_CLOCK_POWER_BASE+SYS_ID_OFFSET)
+#define MEM_SYS_CFG			(ELFIN_CLOCK_POWER_BASE+MEM_SYS_CFG_OFFSET)
+#define QOS_OVERRIDE0			(ELFIN_CLOCK_POWER_BASE+QOS_OVERRIDE0_OFFSET)
+#define QOS_OVERRIDE1			(ELFIN_CLOCK_POWER_BASE+QOS_OVERRIDE1_OFFSET)
+#define MEM_CFG_STAT			(ELFIN_CLOCK_POWER_BASE+MEM_CFG_STAT_OFFSET)
+#define PWR_CFG				(ELFIN_CLOCK_POWER_BASE+PWR_CFG_OFFSET)
+#define EINT_MASK			(ELFIN_CLOCK_POWER_BASE+EINT_MASK_OFFSET)
+#define NOR_CFG				(ELFIN_CLOCK_POWER_BASE+NOR_CFG_OFFSET)
+#define STOP_CFG			(ELFIN_CLOCK_POWER_BASE+STOP_CFG_OFFSET)
+#define SLEEP_CFG			(ELFIN_CLOCK_POWER_BASE+SLEEP_CFG_OFFSET)
+#define OSC_FREQ			(ELFIN_CLOCK_POWER_BASE+OSC_FREQ_OFFSET)
+#define OSC_CNT_VAL			(ELFIN_CLOCK_POWER_BASE+OSC_CNT_VAL_OFFSET)
+#define PWR_CNT_VAL			(ELFIN_CLOCK_POWER_BASE+PWR_CNT_VAL_OFFSET)
+#define FPC_CNT_VAL			(ELFIN_CLOCK_POWER_BASE+FPC_CNT_VAL_OFFSET)
+#define MTC_CNT_VAL			(ELFIN_CLOCK_POWER_BASE+MTC_CNT_VAL_OFFSET)
+#define OTHERS				(ELFIN_CLOCK_POWER_BASE+OTHERS_OFFSET)
+#define RST_STAT			(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)
+#define WAKEUP_STAT			(ELFIN_CLOCK_POWER_BASE+WAKEUP_STAT_OFFSET)
+#define BLK_PWR_STAT			(ELFIN_CLOCK_POWER_BASE+BLK_PWR_STAT_OFFSET)
+#define USB_PHY_CONTROL			(ELFIN_CLOCK_POWER_BASE+USB_PHY_CONTROL_OFFSET)
+#define INF_REG0			(ELFIN_CLOCK_POWER_BASE+INF_REG0_OFFSET)
+#define INF_REG1			(ELFIN_CLOCK_POWER_BASE+INF_REG1_OFFSET)
+#define INF_REG2			(ELFIN_CLOCK_POWER_BASE+INF_REG2_OFFSET)
+#define INF_REG3			(ELFIN_CLOCK_POWER_BASE+INF_REG3_OFFSET)
+#define INF_REG4			(ELFIN_CLOCK_POWER_BASE+INF_REG4_OFFSET)
+#define INF_REG5			(ELFIN_CLOCK_POWER_BASE+INF_REG5_OFFSET)
+#define INF_REG6			(ELFIN_CLOCK_POWER_BASE+INF_REG6_OFFSET)
+#define INF_REG7			(ELFIN_CLOCK_POWER_BASE+INF_REG7_OFFSET)
+
+/* Access Controller (TZPC) */
+#define TZPC_DECPROT0SET_OFFSET		0x804
+#define TZPC_DECPROT1SET_OFFSET		0x810
+#define TZPC_DECPROT2SET_OFFSET		0x81C
+#define TZPC_DECPROT3SET_OFFSET		0x828
+
+/*
+ * GPIO
+ */
+#define ELFIN_GPIO_BASE			0xE0200000
+
+
+#define GPA0CON_OFFSET 			0x000 
+#define GPA0DAT_OFFSET	 		0x004 
+#define GPA0PUD_OFFSET 			0x008 
+#define GPA0DRV_SR_OFFSET	 	0x00C 
+#define GPA0CONPDN_OFFSET 		0x010 
+#define GPA0PUDPDN_OFFSET 		0x014
+
+#define GPA1CON_OFFSET 			0x020
+#define GPA1DAT_OFFSET 			0x024 
+#define GPA1PUD_OFFSET 			0x028 
+#define GPA1DRV_SR_OFFSET 		0x02C 
+#define GPA1CONPDN_OFFSET 		0x030 
+#define GPA1PUDPDN_OFFSET 		0x034 
+
+#define GPBCON_OFFSET 			0x040 
+#define GPBDAT_OFFSET 			0x044 
+#define GPBPUD_OFFSET 			0x048 
+#define GPBDRV_SR_OFFSET 		0x04C 
+#define GPBCONPDN_OFFSET 		0x050 
+#define GPBPUDPDN_OFFSET 		0x054 
+
+#define GPC0CON_OFFSET 			0x060 
+#define GPC0DAT_OFFSET 			0x064 
+#define GPC0PUD_OFFSET 			0x068 
+#define GPC0DRV_SR_OFFSET 		0x06C 
+#define GPC0CONPDN_OFFSET 		0x070 
+#define GPC0PUDPDN_OFFSET 		0x074 
+
+#define GPC1CON_OFFSET 			0x080 
+#define GPC1DAT_OFFSET 			0x084 
+#define GPC1PUD_OFFSET 			0x088 
+#define GPC1DRV_SR_OFFSET 		0x08C 
+#define GPC1CONPDN_OFFSET 		0x090 
+#define GPC1PUDPDN_OFFSET 		0x094 
+
+#define GPD0CON_OFFSET 			0x0A0 
+#define GPD0DAT_OFFSET 			0x0A4 
+#define GPD0PUD_OFFSET 			0x0A8 
+#define GPD0DRV_SR_OFFSET 		0x0AC 
+#define GPD0CONPDN_OFFSET 		0x0B0 
+#define GPD0PUDPDN_OFFSET 		0x0B4 
+
+#define GPD1CON_OFFSET 			0x0C0 
+#define GPD1DAT_OFFSET 			0x0C4 
+#define GPD1PUD_OFFSET 			0x0C8 
+#define GPD1DRV_SR_OFFSET 		0x0CC 
+#define GPD1CONPDN_OFFSET 		0x0D0 
+#define GPD1PUDPDN_OFFSET 		0x0D4 
+
+#define GPE0CON_OFFSET 			0x0E0 
+#define GPE0DAT_OFFSET 			0x0E4 
+#define GPE0PUD_OFFSET 			0x0E8 
+#define GPE0DRV_SR_OFFSET 		0x0EC 
+#define GPE0CONPDN_OFFSET 		0x0F0 
+#define GPE0PUDPDN_OFFSET 		0x0F4
+
+#define GPE1CON_OFFSET 			0x100 
+#define GPE1DAT_OFFSET 			0x104 
+#define GPE1PUD_OFFSET 			0x108 
+#define GPE1DRV_SR_OFFSET 		0x10C 
+#define GPE1CONPDN_OFFSET 		0x110 
+#define GPE1PUDPDN_OFFSET 		0x114 
+
+#define GPF0CON_OFFSET 			0x120 
+#define GPF0DAT_OFFSET 			0x124 
+#define GPF0PUD_OFFSET 			0x128 
+#define GPF0DRV_SR_OFFSET 		0x12C 
+#define GPF0CONPDN_OFFSET 		0x130 
+#define GPF0PUDPDN_OFFSET 		0x134 
+
+#define GPF1CON_OFFSET 			0x140 
+#define GPF1DAT_OFFSET 			0x144 
+#define GPF1PUD_OFFSET 			0x148 
+#define GPF1DRV_SR_OFFSET 		0x14C 
+#define GPF1CONPDN_OFFSET 		0x150 
+#define GPF1PUDPDN_OFFSET 		0x154 
+
+#define GPF2CON_OFFSET 			0x160 
+#define GPF2DAT_OFFSET 			0x164 
+#define GPF2PUD_OFFSET 			0x168 
+#define GPF2DRV_SR_OFFSET 		0x16C 
+#define GPF2CONPDN_OFFSET 		0x170 
+#define GPF2PUDPDN_OFFSET 		0x174 
+
+#define GPF3CON_OFFSET 			0x180 
+#define GPF3DAT_OFFSET 			0x184 
+#define GPF3PUD_OFFSET 			0x188 
+#define GPF3DRV_SR_OFFSET 		0x18C 
+#define GPF3CONPDN_OFFSET 		0x190 
+#define GPF3PUDPDN_OFFSET 		0x194 
+
+#define GPG0CON_OFFSET 			0x1A0 
+#define GPG0DAT_OFFSET 			0x1A4 
+#define GPG0PUD_OFFSET 			0x1A8 
+#define GPG0DRV_SR_OFFSET 		0x1AC 
+#define GPG0CONPDN_OFFSET 		0x1B0 
+#define GPG0PUDPDN_OFFSET 		0x1B4 
+
+#define GPG1CON_OFFSET 			0x1C0 
+#define GPG1DAT_OFFSET 			0x1C4 
+#define GPG1PUD_OFFSET 			0x1C8 
+#define GPG1DRV_SR_OFFSET 		0x1CC 
+#define GPG1CONPDN_OFFSET 		0x1D0 
+#define GPG1PUDPDN_OFFSET 		0x1D4 
+
+#define GPG2CON_OFFSET 			0x1E0 
+#define GPG2DAT_OFFSET 			0x1E4 
+#define GPG2PUD_OFFSET 			0x1E8 
+#define GPG2DRV_SR_OFFSET 		0x1EC 
+#define GPG2CONPDN_OFFSET 		0x1F0 
+#define GPG2PUDPDN_OFFSET 		0x1F4 
+
+#define GPG3CON_OFFSET 			0x200 
+#define GPG3DAT_OFFSET 			0x204 
+#define GPG3PUD_OFFSET 			0x208 
+#define GPG3DRV_SR_OFFSET 		0x20C 
+#define GPG3CONPDN_OFFSET 		0x210 
+#define GPG3PUDPDN_OFFSET 		0x214
+
+#define MP1_0DRV_SR_OFFSET 		0x3CC
+#define MP1_1DRV_SR_OFFSET 		0x3EC
+#define MP1_2DRV_SR_OFFSET 		0x40C
+#define MP1_3DRV_SR_OFFSET 		0x42C
+#define MP1_4DRV_SR_OFFSET 		0x44C
+#define MP1_5DRV_SR_OFFSET 		0x46C
+#define MP1_6DRV_SR_OFFSET 		0x48C
+#define MP1_7DRV_SR_OFFSET 		0x4AC
+#define MP1_8DRV_SR_OFFSET 		0x4CC
+
+#define MP2_0DRV_SR_OFFSET 		0x4EC
+#define MP2_1DRV_SR_OFFSET 		0x50C
+#define MP2_2DRV_SR_OFFSET 		0x52C
+#define MP2_3DRV_SR_OFFSET 		0x54C
+#define MP2_4DRV_SR_OFFSET 		0x56C
+#define MP2_5DRV_SR_OFFSET 		0x58C
+#define MP2_6DRV_SR_OFFSET 		0x5AC
+#define MP2_7DRV_SR_OFFSET 		0x5CC
+#define MP2_8DRV_SR_OFFSET 		0x5EC
+
+/* GPH0 */
+#define GPH0CON_OFFSET			0xc00
+#define GPH0DAT_OFFSET			0xc04
+#define GPH0PUD_OFFSET			0xc08
+#define GPH0DRV_OFFSET			0xc0c
+
+/* GPH1 */
+#define GPH1CON_OFFSET			0xc20
+#define GPH1DAT_OFFSET			0xc24
+#define GPH1PUD_OFFSET			0xc28
+#define GPH1DRV_OFFSET			0xc2c
+
+/* GPH2 */
+#define GPH2CON_OFFSET			0xc40
+#define GPH2DAT_OFFSET			0xc44
+#define GPH2PUD_OFFSET			0xc48
+#define GPH2DRV_OFFSET			0xc4c
+
+/* GPH3 */
+#define GPH3CON_OFFSET			0xc60
+#define GPH3DAT_OFFSET			0xc64
+#define GPH3PUD_OFFSET			0xc68
+#define GPH3DRV_OFFSET			0xc6c
+
+
+#define GPICON_OFFSET 			0x220 
+#define GPIPUD_OFFSET 			0x228 
+#define GPIDRV_OFFSET_SR 		0x22C 
+#define GPIPUDPDN_OFFSET 		0x234 
+
+#define GPJ0CON_OFFSET 			0x240 
+#define GPJ0DAT_OFFSET 			0x244 
+#define GPJ0PUD_OFFSET 			0x248 
+#define GPJ0DRV_SR_OFFSET 		0x24C 
+#define GPJ0CONPDN_OFFSET 		0x250 
+#define GPJ0PUDPDN_OFFSET 		0x254 
+
+#define GPJ1CON_OFFSET 			0x260 
+#define GPJ1DAT_OFFSET 			0x264 
+#define GPJ1PUD_OFFSET 			0x268 
+#define GPJ1DRV_SR_OFFSET 		0x26C 
+#define GPJ1CONPDN_OFFSET 		0x270 
+#define GPJ1PUDPDN_OFFSET 		0x274 
+
+#define GPJ2CON_OFFSET 			0x280 
+#define GPJ2DAT_OFFSET 			0x284 
+#define GPJ2PUD_OFFSET 			0x288 
+#define GPJ2DRV_SR_OFFSET 		0x28C 
+#define GPJ2CONPDN_OFFSET 		0x290 
+#define GPJ2PUDPDN_OFFSET 		0x294 
+
+#define GPJ3CON_OFFSET 			0x2A0 
+#define GPJ3DAT_OFFSET 			0x2A4 
+#define GPJ3PUD_OFFSET 			0x2A8 
+#define GPJ3DRV_SR_OFFSET 		0x2AC 
+#define GPJ3CONPDN_OFFSET 		0x2B0 
+#define GPJ3PUDPDN_OFFSET 		0x2B4 
+
+#define GPJ4CON_OFFSET 			0x2C0 
+#define GPJ4DAT_OFFSET 			0x2C4 
+#define GPJ4PUD_OFFSET 			0x2C8 
+#define GPJ4DRV_SR_OFFSET 		0x2CC 
+#define GPJ4CONPDN_OFFSET 		0x2D0 
+#define GPJ4PUDPDN_OFFSET 		0x2D4 
+
+#define MP01CON_OFFSET 			0x2E0 
+#define MP01DAT_OFFSET 			0x2E4 
+#define MP01PUD_OFFSET 			0x2E8 
+#define MP01DRV_SR_OFFSET 		0x2EC 
+#define MP01CONPDN_OFFSET 		0x2E0 
+#define MP01PUDPDN_OFFSET 		0x2E4 
+
+#define MP02CON_OFFSET                  0x300 
+#define MP02DAT_OFFSET                  0x304
+#define MP02PUD_OFFSET                  0x308 
+#define MP02DRV_SR_OFFSET               0x30c 
+#define MP02CONPDN_OFFSET               0x310 
+#define MP02PUDPDN_OFFSET               0x314
+
+#define MP03CON_OFFSET                  0x320 
+#define MP03DAT_OFFSET                  0x324
+#define MP03PUD_OFFSET                  0x328 
+#define MP03DRV_SR_OFFSET               0x32c 
+#define MP03CONPDN_OFFSET               0x330 
+#define MP03PUDPDN_OFFSET               0x334
+
+#define MP06CON_OFFSET                  0x380
+#define MP06DAT_OFFSET                  0x384
+#define MP06PUD_OFFSET                  0x388
+#define MP06DRV_SR_OFFSET               0x38C
+#define MP06CONPDN_OFFSET               0x390
+#define MP06PUDPDN_OFFSET               0x394
+
+#define MP07CON_OFFSET                  0x3A0
+#define MP07DAT_OFFSET                  0x3A4
+#define MP07PUD_OFFSET                  0x3A8
+#define MP07DRV_SR_OFFSET               0x3AC
+#define MP07CONPDN_OFFSET               0x3B0
+#define MP07PUDPDN_OFFSET               0x3B4
+
+#define GPA0CON				(ELFIN_GPIO_BASE + GPA0CON_OFFSET)	 
+#define GPA0DAT				(ELFIN_GPIO_BASE + GPA0DAT_OFFSET)		 
+#define GPA0PUD				(ELFIN_GPIO_BASE + GPA0PUD_OFFSET)		 
+#define GPA0DRV				(ELFIN_GPIO_BASE + GPA0DRV_SR_OFFSET)
+#define GPA0CONPDN			(ELFIN_GPIO_BASE + GPA0CONPDN_OFFSET)	 
+#define GPA0PUDPDN			(ELFIN_GPIO_BASE + GPA0PUDPDN_OFFSET)	 
+#define GPA1CON				(ELFIN_GPIO_BASE + GPA1CON_OFFSET) 
+#define GPA1DAT				(ELFIN_GPIO_BASE + GPA1DAT_OFFSET) 		 
+#define GPA1PUD				(ELFIN_GPIO_BASE + GPA1PUD_OFFSET) 		 
+#define GPA1DRV				(ELFIN_GPIO_BASE + GPA1DRV_SR_OFFSET) 	 
+#define GPA1CONPDN			(ELFIN_GPIO_BASE + GPA1CONPDN_OFFSET) 	 
+#define GPA1PUDPDN			(ELFIN_GPIO_BASE + GPA1PUDPDN_OFFSET) 	 
+#define GPBCON				(ELFIN_GPIO_BASE + GPBCON_OFFSET) 
+#define GPBDAT				(ELFIN_GPIO_BASE + GPBDAT_OFFSET)			 
+#define GPBPUD				(ELFIN_GPIO_BASE + GPBPUD_OFFSET)			 
+#define GPBDRV_SR			(ELFIN_GPIO_BASE + GPBDRV_SR_OFFSET)
+#define GPBCONPDN			(ELFIN_GPIO_BASE + GPBCONPDN_OFFSET)	 
+#define GPBPUDPDN			(ELFIN_GPIO_BASE + GPBPUDPDN_OFFSET)	 
+#define GPC0CON				(ELFIN_GPIO_BASE + GPC0CON_OFFSET)	 
+#define GPC0DAT				(ELFIN_GPIO_BASE + GPC0DAT_OFFSET)		 
+#define GPC0PUD				(ELFIN_GPIO_BASE + GPC0PUD_OFFSET)		 
+#define GPC0DRV				(ELFIN_GPIO_BASE + GPC0DRV_SR_OFFSET)
+#define GPC0CONPDN			(ELFIN_GPIO_BASE + GPC0CONPDN_OFFSET)	 
+#define GPC0PUDPDN			(ELFIN_GPIO_BASE + GPC0PUDPDN_OFFSET)	 
+#define GPC1CON				(ELFIN_GPIO_BASE + GPC1CON_OFFSET) 
+#define GPC1DAT				(ELFIN_GPIO_BASE + GPC1DAT_OFFSET)		 
+#define GPC1PUD				(ELFIN_GPIO_BASE + GPC1PUD_OFFSET)		 
+#define GPC1DRV				(ELFIN_GPIO_BASE + GPC1DRV_SR_OFFSET)
+#define GPC1CONPDN			(ELFIN_GPIO_BASE + GPC1CONPDN_OFFSET)	 
+#define GPC1PUDPDN			(ELFIN_GPIO_BASE + GPC1PUDPDN_OFFSET)	 
+#define GPD0CON				(ELFIN_GPIO_BASE + GPD0CON_OFFSET) 
+#define GPD0DAT				(ELFIN_GPIO_BASE + GPD0DAT_OFFSET)		 
+#define GPD0PUD				(ELFIN_GPIO_BASE + GPD0PUD_OFFSET)		 
+#define GPD0DRV				(ELFIN_GPIO_BASE + GPD0DRV_SR_OFFSET)
+#define GPD0CONPDN			(ELFIN_GPIO_BASE + GPD0CONPDN_OFFSET)	 
+#define GPD0PUDPDN			(ELFIN_GPIO_BASE + GPD0PUDPDN_OFFSET)	 
+#define GPD1CON				(ELFIN_GPIO_BASE + GPD1CON_OFFSET) 
+#define GPD1DAT				(ELFIN_GPIO_BASE + GPD1DAT_OFFSET)		 
+#define GPD1PUD				(ELFIN_GPIO_BASE + GPD1PUD_OFFSET)		 
+#define GPD1DRV				(ELFIN_GPIO_BASE + GPD1DRV_SR_OFFSET)
+#define GPD1CONPDN			(ELFIN_GPIO_BASE + GPD1CONPDN_OFFSET)	 
+#define GPD1PUDPDN			(ELFIN_GPIO_BASE + GPD1PUDPDN_OFFSET)	 
+#define GPE0CON				(ELFIN_GPIO_BASE + GPE0CON_OFFSET) 
+#define GPE0DAT				(ELFIN_GPIO_BASE + GPE0DAT_OFFSET)		 
+#define GPE0PUD				(ELFIN_GPIO_BASE + GPE0PUD_OFFSET)		 
+#define GPE0DRV				(ELFIN_GPIO_BASE + GPE0DRV_SR_OFFSET)
+#define GPE0CONPDN			(ELFIN_GPIO_BASE + GPE0CONPDN_OFFSET)
+#define GPE0PUDPDN			(ELFIN_GPIO_BASE + GPE0PUDPDN_OFFSET)	 
+#define GPE1CON				(ELFIN_GPIO_BASE + GPE1CON_OFFSET) 
+#define GPE1DAT				(ELFIN_GPIO_BASE + GPE1DAT_OFFSET)		 
+#define GPE1PUD				(ELFIN_GPIO_BASE + GPE1PUD_OFFSET)		 
+#define GPE1DRV				(ELFIN_GPIO_BASE + GPE1DRV_SR_OFFSET)
+#define GPE1CONPDN			(ELFIN_GPIO_BASE + GPE1CONPDN_OFFSET)	 
+#define GPE1PUDPDN			(ELFIN_GPIO_BASE + GPE1PUDPDN_OFFSET)	 
+#define GPF0CON				(ELFIN_GPIO_BASE + GPF0CON_OFFSET) 
+#define GPF0DAT				(ELFIN_GPIO_BASE + GPF0DAT_OFFSET)		 
+#define GPF0PUD				(ELFIN_GPIO_BASE + GPF0PUD_OFFSET)		 
+#define GPF0DRV				(ELFIN_GPIO_BASE + GPF0DRV_SR_OFFSET)
+#define GPF0CONPDN			(ELFIN_GPIO_BASE + GPF0CONPDN_OFFSET)	 
+#define GPF0PUDPDN			(ELFIN_GPIO_BASE + GPF0PUDPDN_OFFSET)	 
+#define GPF1CON				(ELFIN_GPIO_BASE + GPF1CON_OFFSET) 
+#define GPF1DAT				(ELFIN_GPIO_BASE + GPF1DAT_OFFSET)		 
+#define GPF1PUD				(ELFIN_GPIO_BASE + GPF1PUD_OFFSET)		 
+#define GPF1DRV				(ELFIN_GPIO_BASE + GPF1DRV_SR_OFFSET)
+#define GPF1CONPDN			(ELFIN_GPIO_BASE + GPF1CONPDN_OFFSET)	 
+#define GPF1PUDPDN			(ELFIN_GPIO_BASE + GPF1PUDPDN_OFFSET)	 
+#define GPF2CON				(ELFIN_GPIO_BASE + GPF2CON_OFFSET) 
+#define GPF2DAT				(ELFIN_GPIO_BASE + GPF2DAT_OFFSET)		 
+#define GPF2PUD				(ELFIN_GPIO_BASE + GPF2PUD_OFFSET)		 
+#define GPF2DRV				(ELFIN_GPIO_BASE + GPF2DRV_SR_OFFSET)	 
+#define GPF2CONPDN			(ELFIN_GPIO_BASE + GPF2CONPDN_OFFSET)	 
+#define GPF2PUDPDN			(ELFIN_GPIO_BASE + GPF2PUDPDN_OFFSET)	 
+#define GPF3CON				(ELFIN_GPIO_BASE + GPF3CON_OFFSET) 
+#define GPF3DAT				(ELFIN_GPIO_BASE + GPF3DAT_OFFSET)		 
+#define GPF3PUD				(ELFIN_GPIO_BASE + GPF3PUD_OFFSET)		 
+#define GPF3DRV				(ELFIN_GPIO_BASE + GPF3DRV_SR_OFFSET)
+#define GPF3CONPDN			(ELFIN_GPIO_BASE + GPF3CONPDN_OFFSET)	 
+#define GPF3PUDPDN			(ELFIN_GPIO_BASE + GPF3PUDPDN_OFFSET)	 
+#define GPG0CON				(ELFIN_GPIO_BASE + GPG0CON_OFFSET) 
+#define GPG0DAT				(ELFIN_GPIO_BASE + GPG0DAT_OFFSET)		 
+#define GPG0PUD				(ELFIN_GPIO_BASE + GPG0PUD_OFFSET)		 
+#define GPG0DRV				(ELFIN_GPIO_BASE + GPG0DRV_SR_OFFSET)
+#define GPG0CONPDN			(ELFIN_GPIO_BASE + GPG0CONPDN_OFFSET)	 
+#define GPG0PUDPDN			(ELFIN_GPIO_BASE + GPG0PUDPDN_OFFSET)	 
+#define GPG1CON				(ELFIN_GPIO_BASE + GPG1CON_OFFSET) 
+#define GPG1DAT				(ELFIN_GPIO_BASE + GPG1DAT_OFFSET)		 
+#define GPG1PUD				(ELFIN_GPIO_BASE + GPG1PUD_OFFSET)		 
+#define GPG1DRV				(ELFIN_GPIO_BASE + GPG1DRV_SR_OFFSET)
+#define GPG1CONPDN			(ELFIN_GPIO_BASE + GPG1CONPDN_OFFSET)	 
+#define GPG1PUDPDN			(ELFIN_GPIO_BASE + GPG1PUDPDN_OFFSET)	 
+#define GPG2CON				(ELFIN_GPIO_BASE + GPG2CON_OFFSET) 
+#define GPG2DAT				(ELFIN_GPIO_BASE + GPG2DAT_OFFSET)		 
+#define GPG2PUD				(ELFIN_GPIO_BASE + GPG2PUD_OFFSET)		 
+#define GPG2DRV				(ELFIN_GPIO_BASE + GPG2DRV_SR_OFFSET)
+#define GPG2CONPDN			(ELFIN_GPIO_BASE + GPG2CONPDN_OFFSET)	 
+#define GPG2PUDPDN			(ELFIN_GPIO_BASE + GPG2PUDPDN_OFFSET)	 
+#define GPG3CON				(ELFIN_GPIO_BASE + GPG3CON_OFFSET) 
+#define GPG3DAT				(ELFIN_GPIO_BASE + GPG3DAT_OFFSET)		 
+#define GPG3PUD				(ELFIN_GPIO_BASE + GPG3PUD_OFFSET)		 
+#define GPG3DRV				(ELFIN_GPIO_BASE + GPG3DRV_SR_OFFSET)
+#define GPG3CONPDN			(ELFIN_GPIO_BASE + GPG3CONPDN_OFFSET)	 
+#define GPG3PUDPDN			(ELFIN_GPIO_BASE + GPG3PUDPDN_OFFSET)	 
+#define GPICON				(ELFIN_GPIO_BASE + GPICON_OFFSET) 
+#define GPIPUD				(ELFIN_GPIO_BASE + GPIPUD_OFFSET)			 
+#define GPIDRV				(ELFIN_GPIO_BASE + GPIDRV_OFFSET_SR)
+#define GPIPUDPDN			(ELFIN_GPIO_BASE + GPIPUDPDN_OFFSET)	 
+#define GPJ0CON				(ELFIN_GPIO_BASE + GPJ0CON_OFFSET)	 
+#define GPJ0DAT				(ELFIN_GPIO_BASE + GPJ0DAT_OFFSET)		 
+#define GPJ0PUD				(ELFIN_GPIO_BASE + GPJ0PUD_OFFSET)		 
+#define GPJ0DRV				(ELFIN_GPIO_BASE + GPJ0DRV_SR_OFFSET)
+#define GPJ0CONPDN			(ELFIN_GPIO_BASE + GPJ0CONPDN_OFFSET)	 
+#define GPJ0PUDPDN			(ELFIN_GPIO_BASE + GPJ0PUDPDN_OFFSET)	 
+#define GPJ1CON				(ELFIN_GPIO_BASE + GPJ1CON_OFFSET) 
+#define GPJ1DAT				(ELFIN_GPIO_BASE + GPJ1DAT_OFFSET)		 
+#define GPJ1PUD				(ELFIN_GPIO_BASE + GPJ1PUD_OFFSET)		 
+#define GPJ1DRV				(ELFIN_GPIO_BASE + GPJ1DRV_SR_OFFSET)
+#define GPJ1CONPDN			(ELFIN_GPIO_BASE + GPJ1CONPDN_OFFSET)	 
+#define GPJ1PUDPDN			(ELFIN_GPIO_BASE + GPJ1PUDPDN_OFFSET)	 
+#define GPJ2CON				(ELFIN_GPIO_BASE + GPJ2CON_OFFSET) 
+#define GPJ2DAT				(ELFIN_GPIO_BASE + GPJ2DAT_OFFSET)		 
+#define GPJ2PUD				(ELFIN_GPIO_BASE + GPJ2PUD_OFFSET)		 
+#define GPJ2DRV				(ELFIN_GPIO_BASE + GPJ2DRV_SR_OFFSET)
+#define GPJ2CONPDN			(ELFIN_GPIO_BASE + GPJ2CONPDN_OFFSET)	 
+#define GPJ2PUDPDN			(ELFIN_GPIO_BASE + GPJ2PUDPDN_OFFSET)	 
+#define GPJ3CON				(ELFIN_GPIO_BASE + GPJ3CON_OFFSET) 
+#define GPJ3DAT				(ELFIN_GPIO_BASE + GPJ3DAT_OFFSET)		 
+#define GPJ3PUD				(ELFIN_GPIO_BASE + GPJ3PUD_OFFSET)		 
+#define GPJ3DRV_SR			(ELFIN_GPIO_BASE + GPJ3DRV_SR_OFFSET)
+#define GPJ3CONPDN			(ELFIN_GPIO_BASE + GPJ3CONPDN_OFFSET)	 
+#define GPJ3PUDPDN			(ELFIN_GPIO_BASE + GPJ3PUDPDN_OFFSET)	 
+#define GPJ4CON				(ELFIN_GPIO_BASE + GPJ4CON_OFFSET)
+#define GPJ4DAT				(ELFIN_GPIO_BASE + GPJ4DAT_OFFSET)		 
+#define GPJ4PUD				(ELFIN_GPIO_BASE + GPJ4PUD_OFFSET)		 
+#define GPJ4DRV				(ELFIN_GPIO_BASE + GPJ4DRV_SR_OFFSET)
+#define GPJ4CONPDN			(ELFIN_GPIO_BASE + GPJ4CONPDN_OFFSET)	 
+#define GPJ4PUDPDN			(ELFIN_GPIO_BASE + GPJ4PUDPDN_OFFSET)
+
+#define MP01CON_REG			__REG(ELFIN_GPIO_BASE + MP01CON_OFFSET)
+#define MP01DAT_REG			__REG(ELFIN_GPIO_BASE + MP01DAT_OFFSET)		 
+#define MP01PUD_REG			__REG(ELFIN_GPIO_BASE + MP01PUD_OFFSET)		 
+#define MP01DRV_REG			__REG(ELFIN_GPIO_BASE + MP01DRV_SR_OFFSET)
+#define MP01CONPDN_REG			__REG(ELFIN_GPIO_BASE + MP01CONPDN_OFFSET)	 
+#define MP01PUDPDN_REG			__REG(ELFIN_GPIO_BASE + MP01PUDPDN_OFFSET)
+
+
+#define MP02CON_REG                     __REG(ELFIN_GPIO_BASE + MP02CON_OFFSET)
+#define MP02DAT_REG                     __REG(ELFIN_GPIO_BASE + MP02DAT_OFFSET)          
+#define MP02PUD_REG                     __REG(ELFIN_GPIO_BASE + MP02PUD_OFFSET)          
+#define MP02DRV_REG                     __REG(ELFIN_GPIO_BASE + MP02DRV_SR_OFFSET)
+#define MP02CONPDN_REG                  __REG(ELFIN_GPIO_BASE + MP02CONPDN_OFFSET)       
+#define MP02PUDPDN_REG                  __REG(ELFIN_GPIO_BASE + MP02PUDPDN_OFFSET)
+
+#define MP03CON_REG                     __REG(ELFIN_GPIO_BASE + MP03CON_OFFSET)
+#define MP03DAT_REG                     __REG(ELFIN_GPIO_BASE + MP03DAT_OFFSET)          
+#define MP03PUD_REG                     __REG(ELFIN_GPIO_BASE + MP03PUD_OFFSET)          
+#define MP03DRV_REG                     __REG(ELFIN_GPIO_BASE + MP03DRV_SR_OFFSET)
+#define MP03CONPDN_REG                  __REG(ELFIN_GPIO_BASE + MP03CONPDN_OFFSET)       
+#define MP03PUDPDN_REG                  __REG(ELFIN_GPIO_BASE + MP03PUDPDN_OFFSET)
+
+#define NFCONF_VAL	(7<<12)|(7<<8)|(7<<4)|(0<<3)|(1<<2)|(1<<1)|(0<<0)       
+#define NFCONT_VAL	(0<<18)|(0<<17)|(0<<16)|(0<<10)|(0<<9)|(0<<8)|(0<<7)|(0<<6)|(0x3<<1)|(1<<0)
+#define MP03CON_VAL	(1<<29)|(1<<25)|(1<<21)|(1<<17)|(1<<13)|(1<<9)|(1<<5)|(1<<1)
+/*
+ * Bus Matrix
+ */
+#define ELFIN_MEM_SYS_CFG		0x7e00f120
+
+/*
+ * Memory controller
+ */
+#define ELFIN_SROM_BASE			0xE8000000
+
+#define SROM_BW_REG			__REG(ELFIN_SROM_BASE+0x0)
+#define SROM_BC0_REG			__REG(ELFIN_SROM_BASE+0x4)
+#define SROM_BC1_REG			__REG(ELFIN_SROM_BASE+0x8)
+#define SROM_BC2_REG			__REG(ELFIN_SROM_BASE+0xC)
+#define SROM_BC3_REG			__REG(ELFIN_SROM_BASE+0x10)
+#define SROM_BC4_REG			__REG(ELFIN_SROM_BASE+0x14)
+#define SROM_BC5_REG			__REG(ELFIN_SROM_BASE+0x18)
+
+/*
+ * SDRAM Controller
+ */
+#define APB_DMC_0_BASE			0xF0000000
+#define APB_DMC_1_BASE			0xF1400000
+#define ASYNC_MSYS_DMC0_BASE		0xF1E00000
+
+#define DMC_CONCONTROL 			0x00
+#define DMC_MEMCONTROL 			0x04
+#define DMC_MEMCONFIG0 			0x08
+#define DMC_MEMCONFIG1 			0x0C
+#define DMC_DIRECTCMD 			0x10
+#define DMC_PRECHCONFIG 		0x14
+#define DMC_PHYCONTROL0 		0x18
+#define DMC_PHYCONTROL1 		0x1C
+#define DMC_RESERVED 			0x20
+#define DMC_PWRDNCONFIG 		0x28
+#define DMC_TIMINGAREF 			0x30
+#define DMC_TIMINGROW 			0x34
+#define DMC_TIMINGDATA 			0x38
+#define DMC_TIMINGPOWER 		0x3C
+#define DMC_PHYSTATUS 			0x40
+#define DMC_CHIP0STATUS 		0x48
+#define DMC_CHIP1STATUS 		0x4C
+#define DMC_AREFSTATUS 			0x50
+#define DMC_MRSTATUS 			0x54
+#define DMC_PHYTEST0 			0x58
+#define DMC_PHYTEST1 			0x5C
+#define DMC_QOSCONTROL0 		0x60
+#define DMC_QOSCONFIG0 			0x64
+#define DMC_QOSCONTROL1 		0x68
+#define DMC_QOSCONFIG1 			0x6C
+#define DMC_QOSCONTROL2 		0x70
+#define DMC_QOSCONFIG2 			0x74
+#define DMC_QOSCONTROL3 		0x78
+#define DMC_QOSCONFIG3 			0x7C
+#define DMC_QOSCONTROL4 		0x80
+#define DMC_QOSCONFIG4 			0x84
+#define DMC_QOSCONTROL5 		0x88
+#define DMC_QOSCONFIG5 			0x8C
+#define DMC_QOSCONTROL6 		0x90
+#define DMC_QOSCONFIG6 			0x94
+#define DMC_QOSCONTROL7 		0x98
+#define DMC_QOSCONFIG7 			0x9C
+#define DMC_QOSCONTROL8 		0xA0
+#define DMC_QOSCONFIG8 			0xA4
+#define DMC_QOSCONTROL9 		0xA8
+#define DMC_QOSCONFIG9 			0xAC
+#define DMC_QOSCONTROL10 		0xB0
+#define DMC_QOSCONFIG10 		0xB4
+#define DMC_QOSCONTROL11 		0xB8
+#define DMC_QOSCONFIG11 		0xBC
+#define DMC_QOSCONTROL12 		0xC0
+#define DMC_QOSCONFIG12 		0xC4
+#define DMC_QOSCONTROL13 		0xC8
+#define DMC_QOSCONFIG13 		0xCC
+#define DMC_QOSCONTROL14 		0xD0
+#define DMC_QOSCONFIG14 		0xD4
+#define DMC_QOSCONTROL15 		0xD8
+#define DMC_QOSCONFIG15 		0xDC
+
+
+/*
+* Memory Chip direct command
+*/
+
+/****************************************************************
+ Definitions for memory configuration
+ Set memory configuration
+	active_chips	 = 1'b0 (1 chip)
+	qos_master_chip  = 3'b000(ARID[3:0])
+	memory burst	 = 3'b010(burst 4)
+	stop_mem_clock	 = 1'b0(disable dynamical stop)
+	auto_power_down  = 1'b0(disable auto power-down mode)
+	power_down_prd	 = 6'b00_0000(0 cycle for auto power-down)
+	ap_bit		 = 1'b0 (bit position of auto-precharge is 10)
+	row_bits	 = 3'b010(# row address 13)
+	column_bits	 = 3'b010(# column address 10 )
+
+ Set user configuration
+	2'b10=SDRAM/mSDRAM, 2'b11=DDR, 2'b01=mDDR
+
+ Set chip select for chip [n]
+	 row bank control, bank address 0x3000_0000 ~ 0x37ff_ffff
+	 CHIP_[n]_CFG=0x30F8,  30: ADDR[31:24], F8: Mask[31:24]
+******************************************************************/
+
+/*
+ * HS MMC Interface
+ */
+#define ELFIN_HSMMC_BASE		0xEB000000
+
+#define HM_SYSAD			(0x00)
+#define HM_BLKSIZE			(0x04)
+#define HM_BLKCNT			(0x06)
+#define HM_ARGUMENT			(0x08)
+#define HM_TRNMOD			(0x0c)
+#define HM_CMDREG			(0x0e)
+#define HM_RSPREG0			(0x10)
+#define HM_RSPREG1			(0x14)
+#define HM_RSPREG2			(0x18)
+#define HM_RSPREG3			(0x1c)
+#define HM_BDATA			(0x20)
+#define HM_PRNSTS			(0x24)
+#define HM_HOSTCTL			(0x28)
+#define HM_PWRCON			(0x29)
+#define HM_BLKGAP			(0x2a)
+#define HM_WAKCON			(0x2b)
+#define HM_CLKCON			(0x2c)
+#define HM_TIMEOUTCON			(0x2e)
+#define HM_SWRST			(0x2f)
+#define HM_NORINTSTS			(0x30)
+#define HM_ERRINTSTS			(0x32)
+#define HM_NORINTSTSEN			(0x34)
+#define HM_ERRINTSTSEN			(0x36)
+#define HM_NORINTSIGEN			(0x38)
+#define HM_ERRINTSIGEN			(0x3a)
+#define HM_ACMD12ERRSTS			(0x3c)
+#define HM_CAPAREG			(0x40)
+#define HM_MAXCURR			(0x48)
+#define HM_CONTROL2			(0x80)
+#define HM_CONTROL3			(0x84)
+#define HM_CONTROL4			(0x8c)
+#define HM_HCVER			(0xfe)
+
+/*
+ * Nand flash controller
+ */
+#define ELFIN_NAND_BASE			0xB0E00000
+#define ELFIN_NAND_ECC_BASE		0xB0E20000
+
+#define NFCONF_OFFSET           	0x00
+#define NFCONT_OFFSET           	0x04
+#define NFCMMD_OFFSET           	0x08
+#define NFADDR_OFFSET           	0x0c
+#define NFDATA_OFFSET			0x10
+#define NFMECCDATA0_OFFSET      	0x14
+#define NFMECCDATA1_OFFSET      	0x18
+#define NFSECCDATA0_OFFSET      	0x1c
+#define NFSBLK_OFFSET           	0x20
+#define NFEBLK_OFFSET           	0x24
+#define NFSTAT_OFFSET           	0x28
+#define NFESTAT0_OFFSET         	0x2c
+#define NFESTAT1_OFFSET         	0x30
+#define NFMECC0_OFFSET          	0x34
+#define NFMECC1_OFFSET          	0x38
+#define NFSECC_OFFSET           	0x3c
+#define NFMLCBITPT_OFFSET       	0x40
+#define NFECCCONF_OFFSET 		0x000 // R/W ECC configuration register 0x0000_0000
+#define NFECCCONT_OFFSET 		0x020 // R/W ECC control register 0x0000_0000
+#define NFECCSTAT_OFFSET 		0x030 // R ECC status register 0x0000_0000
+#define NFECCSECSTAT_OFFSET 		0x040 // R ECC sector status register 0x0000_0000
+#define NFECCPRGECC0_OFFSET 		0x090 // R ECC parity code0 register for page program 0x0000_0000
+#define NFECCPRGECC1_OFFSET 		0x094 // R ECC parity code1 register for page program 0x0000_0000
+#define NFECCPRGECC2_OFFSET 		0x098 // R ECC parity code2 register for page program 0x0000_0000
+#define NFECCPRGECC3_OFFSET 		0x09C // R ECC parity code3 register for page program 0x0000_0000
+#define NFECCPRGECC4_OFFSET 		0x0A0 // R ECC parity code4 register for page program 0x0000_0000
+#define NFECCPRGECC5_OFFSET 		0x0A4 // R ECC parity code5 register for page program 0x0000_0000
+#define NFECCPRGECC6_OFFSET 		0x0A8 // R ECC parity code6 register for page program 0x0000_0000
+#define NFECCERL0_OFFSET		0x0C0 // R ECC error byte location0 register 0x0000_0000
+#define NFECCERL1_OFFSET		0x0C4 // R ECC error byte location1 register 0x0000_0000
+#define NFECCERL2_OFFSET		0x0C8 // R ECC error byte location2 register 0x0000_0000
+#define NFECCERL3_OFFSET 		0x0CC // R ECC error byte location3 register 0x0000_0000
+#define NFECCERL4_OFFSET 		0x0D0 // R ECC error byte location4 register 0x0000_0000
+#define NFECCERL5_OFFSET 		0x0D4 // R ECC error byte location5 register 0x0000_0000
+#define NFECCERL6_OFFSET 		0x0D8 // R ECC error byte location6 register 0x0000_0000
+#define NFECCERL7_OFFSET 		0x0DC // R ECC error byte location7 register 0x0000_0000
+#define NFECCERP0_OFFSET 		0x0F0 // R ECC error bit pattern0 register 0x0000_0000
+#define NFECCERP1_OFFSET 		0x0F4 // R ECC error bit pattern1 register 0x0000_0000
+#define NFECCERP2_OFFSET 		0x0F8 // R ECC error bit pattern2 register 0x0000_0000
+#define NFECCERP3_OFFSET 		0x0FC // R ECC error bit pattern3 register 0x0000_0000
+#define NFECCCONECC0_OFFSET 		0x110 // R/W ECC parity conversion code0 register 0x0000_0000
+#define NFECCCONECC1_OFFSET 		0x114 // R/W ECC parity conversion code1 register 0x0000_0000
+#define NFECCCONECC2_OFFSET 		0x118 // R/W ECC parity conversion code2 register 0x0000_0000
+#define NFECCCONECC3_OFFSET 		0x11C // R/W ECC parity conversion code3 register 0x0000_0000
+#define NFECCCONECC4_OFFSET 		0x120 // R/W ECC parity conversion code4 register 0x0000_0000
+#define NFECCCONECC5_OFFSET 		0x124 // R/W ECC parity conversion code5 register 0x0000_0000
+#define NFECCCONECC6_OFFSET		0x128 // R/W ECC parity conversion code6 register 0x0000_0000
+
+#define NFCONF				(ELFIN_NAND_BASE+NFCONF_OFFSET)
+#define NFCONT				(ELFIN_NAND_BASE+NFCONT_OFFSET)
+#define NFCMMD				(ELFIN_NAND_BASE+NFCMMD_OFFSET)
+#define NFADDR           		(ELFIN_NAND_BASE+NFADDR_OFFSET)
+#define NFDATA          		(ELFIN_NAND_BASE+NFDATA_OFFSET)
+#define NFMECCDATA0     		(ELFIN_NAND_BASE+NFMECCDATA0_OFFSET)
+#define NFMECCDATA1     		(ELFIN_NAND_BASE+NFMECCDATA1_OFFSET)
+#define NFSECCDATA0      		(ELFIN_NAND_BASE+NFSECCDATA0_OFFSET)
+#define NFSBLK          		(ELFIN_NAND_BASE+NFSBLK_OFFSET)
+#define NFEBLK           		(ELFIN_NAND_BASE+NFEBLK_OFFSET)
+#define NFSTAT           		(ELFIN_NAND_BASE+NFSTAT_OFFSET)
+#define NFESTAT0         		(ELFIN_NAND_BASE+NFESTAT0_OFFSET)
+#define NFESTAT1         		(ELFIN_NAND_BASE+NFESTAT1_OFFSET)
+#define NFMECC0          		(ELFIN_NAND_BASE+NFMECC0_OFFSET)
+#define NFMECC1          		(ELFIN_NAND_BASE+NFMECC1_OFFSET)
+#define NFSECC           		(ELFIN_NAND_BASE+NFSECC_OFFSET)
+#define NFMLCBITPT           		(ELFIN_NAND_BASE+NFMLCBITPT_OFFSET)
+
+#define NFECCCONF			(ELFIN_NAND_ECC_BASE+NFECCCONF_OFFSET)
+#define NFECCCONT			(ELFIN_NAND_ECC_BASE+NFECCCONT_OFFSET)
+#define NFECCSTAT			(ELFIN_NAND_ECC_BASE+NFECCSTAT_OFFSET)
+#define NFECCSECSTAT			(ELFIN_NAND_ECC_BASE+NFECCSECSTAT_OFFSET)
+#define NFECCPRGECC0			(ELFIN_NAND_ECC_BASE+NFECCPRGECC0_OFFSET)
+#define NFECCPRGECC1			(ELFIN_NAND_ECC_BASE+NFECCPRGECC1_OFFSET)
+#define NFECCPRGECC2			(ELFIN_NAND_ECC_BASE+NFECCPRGECC2_OFFSET)
+#define NFECCPRGECC3			(ELFIN_NAND_ECC_BASE+NFECCPRGECC3_OFFSET)
+#define NFECCPRGECC4			(ELFIN_NAND_ECC_BASE+NFECCPRGECC4_OFFSET)
+#define NFECCPRGECC5			(ELFIN_NAND_ECC_BASE+NFECCPRGECC5_OFFSET)
+#define NFECCPRGECC6			(ELFIN_NAND_ECC_BASE+NFECCPRGECC6_OFFSET)
+#define NFECCERL0			(ELFIN_NAND_ECC_BASE+NFECCERL0_OFFSET)
+#define NFECCERL1			(ELFIN_NAND_ECC_BASE+NFECCERL1_OFFSET)
+#define NFECCERL2			(ELFIN_NAND_ECC_BASE+NFECCERL2_OFFSET)
+#define NFECCERL3			(ELFIN_NAND_ECC_BASE+NFECCERL3_OFFSET)
+#define NFECCERL4			(ELFIN_NAND_ECC_BASE+NFECCERL4_OFFSET)
+#define NFECCERL5			(ELFIN_NAND_ECC_BASE+NFECCERL5_OFFSET)
+#define NFECCERL6			(ELFIN_NAND_ECC_BASE+NFECCERL6_OFFSET)
+#define NFECCERL7			(ELFIN_NAND_ECC_BASE+NFECCERL7_OFFSET)
+#define NFECCERP0			(ELFIN_NAND_ECC_BASE+NFECCERP0_OFFSET)
+#define NFECCERP1			(ELFIN_NAND_ECC_BASE+NFECCERP1_OFFSET)
+#define NFECCERP2			(ELFIN_NAND_ECC_BASE+NFECCERP2_OFFSET)
+#define NFECCERP3			(ELFIN_NAND_ECC_BASE+NFECCERP3_OFFSET)
+#define NFECCCONECC0			(ELFIN_NAND_ECC_BASE+NFECCCONECC0_OFFSET)
+#define NFECCCONECC1			(ELFIN_NAND_ECC_BASE+NFECCCONECC1_OFFSET)
+#define NFECCCONECC2			(ELFIN_NAND_ECC_BASE+NFECCCONECC2_OFFSET)
+#define NFECCCONECC3			(ELFIN_NAND_ECC_BASE+NFECCCONECC3_OFFSET)
+#define NFECCCONECC4			(ELFIN_NAND_ECC_BASE+NFECCCONECC4_OFFSET)
+#define NFECCCONECC5			(ELFIN_NAND_ECC_BASE+NFECCCONECC5_OFFSET)
+#define NFECCCONECC6			(ELFIN_NAND_ECC_BASE+NFECCCONECC6_OFFSET)
+
+
+#define NFCONF_REG			__REG(ELFIN_NAND_BASE+NFCONF_OFFSET)
+#define NFCONT_REG			__REG(ELFIN_NAND_BASE+NFCONT_OFFSET)
+#define NFCMD_REG			__REG(ELFIN_NAND_BASE+NFCMMD_OFFSET)
+#define NFADDR_REG           		__REG(ELFIN_NAND_BASE+NFADDR_OFFSET)
+#define NFDATA_REG          		__REG(ELFIN_NAND_BASE+NFDATA_OFFSET)
+#define NFDATA8_REG          		__REGb(ELFIN_NAND_BASE+NFDATA_OFFSET)
+#define NFMECCDATA0_REG     		__REG(ELFIN_NAND_BASE+NFMECCDATA0_OFFSET)
+#define NFMECCDATA1_REG     		__REG(ELFIN_NAND_BASE+NFMECCDATA1_OFFSET)
+#define NFSECCDATA0_REG      		__REG(ELFIN_NAND_BASE+NFSECCDATA0_OFFSET)
+#define NFSBLK_REG          		__REG(ELFIN_NAND_BASE+NFSBLK_OFFSET)
+#define NFEBLK_REG           		__REG(ELFIN_NAND_BASE+NFEBLK_OFFSET)
+#define NFSTAT_REG           		__REG(ELFIN_NAND_BASE+NFSTAT_OFFSET)
+#define NFESTAT0_REG         		__REG(ELFIN_NAND_BASE+NFESTAT0_OFFSET)
+#define NFESTAT1_REG         		__REG(ELFIN_NAND_BASE+NFESTAT1_OFFSET)
+#define NFMECC0_REG          		__REG(ELFIN_NAND_BASE+NFMECC0_OFFSET)
+#define NFMECC1_REG          		__REG(ELFIN_NAND_BASE+NFMECC1_OFFSET)
+#define NFSECC_REG           		__REG(ELFIN_NAND_BASE+NFSECC_OFFSET)
+#define NFMLCBITPT_REG         		__REG(ELFIN_NAND_BASE+NFMLCBITPT_OFFSET)
+
+#define NFCONF_ECC_MLC			(1<<24)
+
+#define NFCONF_ECC_1BIT			(0<<23)
+#define NFCONF_ECC_4BIT			(2<<23)
+#define NFCONF_ECC_8BIT			(1<<23)
+
+#define NFCONT_ECC_ENC			(1<<18)
+#define NFCONT_WP			(1<<16)
+#define NFCONT_MECCLOCK			(1<<7)
+#define NFCONT_SECCLOCK			(1<<6)
+#define NFCONT_INITMECC			(1<<5)
+#define NFCONT_INITSECC			(1<<4)
+#define NFCONT_INITECC			(NFCONT_INITMECC | NFCONT_INITSECC)
+#define NFCONT_CS			(1<<1)
+#define NFSTAT_ECCENCDONE		(1<<25)
+#define NFSTAT_ECCDECDONE		(1<<24)
+#define NFSTAT_RnB			(1<<0)
+#define NFESTAT0_ECCBUSY		(1<<31)
+
+
+
+/*************************************************************
+ * OneNAND Controller
+ *************************************************************/
+#define ELFIN_ONENAND_BASE		0xB0000000
+#define ELFIN_ONENANDCON_BASE		(ELFIN_ONENAND_BASE + 0x600000)
+
+#define ONENAND_IF_CTRL_OFFSET			0x100
+#define ONENAND_IF_CMD_OFFSET			0x104
+#define ONENAND_IF_ASYNC_TIMING_CTRL_OFFSET	0x108
+#define ONENAND_IF_STATUS_OFFSET		0x10C
+#define DMA_SRC_ADDR_OFFSET			0x400
+#define DMA_SRC_CFG_OFFSET			0x404
+#define DMA_DST_ADDR_OFFSET			0x408
+#define DMA_DST_CFG_OFFSET			0x40C
+#define DMA_TRANS_SIZE_OFFSET			0x414
+#define DMA_TRANS_CMD_OFFSET			0x418
+#define DMA_TRANS_STATUS_OFFSET			0x41C
+#define DMA_TRANS_DIR_OFFSET			0x420
+#define SQC_SAO_OFFSET				0x600
+#define SQC_CMD_OFFSET				0x608
+#define SQC_STATUS_OFFSET			0x60C
+#define SQC_CAO_OFFSET				0x610
+#define SQC_REG_CTRL_OFFSET			0x614
+#define SQC_REG_VAL_OFFSET			0x618
+#define SQC_BRPAO0_OFFSET			0x620
+#define SQC_BRPAO1_OFFSET			0x624
+#define INTC_SQC_CLR_OFFSET			0x1000
+#define INTC_DMA_CLR_OFFSET			0x1004
+#define INTC_ONENAND_CLR_OFFSET			0x1008
+#define INTC_SQC_MASK_OFFSET			0x1020
+#define INTC_DMA_MASK_OFFSET			0x1024
+#define INTC_ONENAND_MASK_OFFSET		0x1028
+#define INTC_SQC_PEND_OFFSET			0x1040
+#define INTC_DMA_PEND_OFFSET			0x1044
+#define INTC_ONENAND_PEND_OFFSET		0x1048
+#define INTC_SQC_STATUS_OFFSET			0x1060
+#define INTC_DMA_STATUS_OFFSET			0x1064
+#define INTC_ONENAND_STATUS_OFFSET		0x1068
+
+#if 0
+#define ONENAND_MEM_CFG_SYNC_READ	(1 << 15)
+#define ONENAND_MEM_CFG_BRL_7		(7 << 12)
+#define ONENAND_MEM_CFG_BRL_6		(6 << 12)
+#define ONENAND_MEM_CFG_BRL_5		(5 << 12)
+#define ONENAND_MEM_CFG_BRL_4		(4 << 12)
+#define ONENAND_MEM_CFG_BRL_3		(3 << 12)
+#define ONENAND_MEM_CFG_BRL_10		(2 << 12)
+#define ONENAND_MEM_CFG_BRL_9		(1 << 12)
+#define ONENAND_MEM_CFG_BRL_8		(0 << 12)
+#define ONENAND_MEM_CFG_BRL_SHIFT	(12)
+#define ONENAND_MEM_CFG_BL_1K		(5 << 9)
+#define ONENAND_MEM_CFG_BL_32		(4 << 9)
+#define ONENAND_MEM_CFG_BL_16		(3 << 9)
+#define ONENAND_MEM_CFG_BL_8		(2 << 9)
+#define ONENAND_MEM_CFG_BL_4		(1 << 9)
+#define ONENAND_MEM_CFG_BL_CONT		(0 << 9)
+#define ONENAND_MEM_CFG_BL_SHIFT	(9)
+#define ONENAND_MEM_CFG_NO_ECC		(1 << 8)
+#define ONENAND_MEM_CFG_RDY_HIGH	(1 << 7)
+#define ONENAND_MEM_CFG_INT_HIGH	(1 << 6)
+#define ONENAND_MEM_CFG_IOBE		(1 << 5)
+#define ONENAND_MEM_CFG_RDY_CONF	(1 << 4)
+#define ONENAND_MEM_CFG_HF		(1 << 2)
+#define ONENAND_MEM_CFG_WM_SYNC		(1 << 1)
+#define ONENAND_MEM_CFG_BWPS_UNLOCK	(1 << 0)
+
+#define ONENAND_BURST_LEN_CONT		(0)
+#define ONENAND_BURST_LEN_4		(4)
+#define ONENAND_BURST_LEN_8		(8)
+#define ONENAND_BURST_LEN_16		(16)
+
+#define ONENAND_MEM_RESET_WARM		(0x1)
+#define ONENAND_MEM_RESET_COLD		(0x2)
+#define ONENAND_MEM_RESET_HOT		(0x3)
+
+#define ONENAND_INT_ERR_CACHE_OP_ERR	(1 << 13)
+#define ONENAND_INT_ERR_RST_CMP		(1 << 12)
+#define ONENAND_INT_ERR_RDY_ACT		(1 << 11)
+#define ONENAND_INT_ERR_INT_ACT		(1 << 10)
+#define ONENAND_INT_ERR_UNSUP_CMD	(1 << 9)
+#define ONENAND_INT_ERR_LOCKED_BLK	(1 << 8)
+#define ONENAND_INT_ERR_BLK_RW_CMP	(1 << 7)
+#define ONENAND_INT_ERR_ERS_CMP		(1 << 6)
+#define ONENAND_INT_ERR_PGM_CMP		(1 << 5)
+#define ONENAND_INT_ERR_LOAD_CMP	(1 << 4)
+#define ONENAND_INT_ERR_ERS_FAIL	(1 << 3)
+#define ONENAND_INT_ERR_PGM_FAIL	(1 << 2)
+#define ONENAND_INT_ERR_INT_TO		(1 << 1)
+#define ONENAND_INT_ERR_LD_FAIL_ECC_ERR	(1 << 0)
+
+#define ONENAND_DEVICE_DENSITY_SHIFT	(4)
+#define ONENAND_DEVICE_IS_DDP		(1 << 3)
+#define ONENAND_DEVICE_IS_DEMUX		(1 << 2)
+#define ONENAND_DEVICE_VCC_MASK		(0x3)
+#define ONENAND_DEVICE_DENSITY_128Mb	(0x000)
+#define ONENAND_DEVICE_DENSITY_256Mb	(0x001)
+#define ONENAND_DEVICE_DENSITY_512Mb	(0x002)
+#define ONENAND_DEVICE_DENSITY_1Gb	(0x003)
+#define ONENAND_DEVICE_DENSITY_2Gb	(0x004)
+#define ONENAND_DEVICE_DENSITY_4Gb	(0x005)
+
+#define ONENAND_SYNC_MODE_RM_SYNC	(1 << 1)
+#define ONENAND_SYNC_MODE_WM_SYNC	(1 << 0)
+
+#define ONENAND_TRANS_SPARE_TSRF_INC	(1 << 0)
+
+#define ONENAND_INT_PIN_ENABLE		(1 << 0)
+
+#define ONENAND_ACC_CLOCK_266_133	(0x5)
+#define ONENAND_ACC_CLOCK_166_83	(0x3)
+#define ONENAND_ACC_CLOCK_134_67	(0x3)
+#define ONENAND_ACC_CLOCK_100_50	(0x2)
+#define ONENAND_ACC_CLOCK_60_30		(0x2)
+
+#define ONENAND_FLASH_AUX_WD_DISABLE	(1 << 0)
+
+/*
+ * Datain values for mapped commands
+ */
+#define ONENAND_DATAIN_ERASE_STATUS	(0x00)
+#define ONENAND_DATAIN_ERASE_MULTI	(0x01)
+#define ONENAND_DATAIN_ERASE_SINGLE	(0x03)
+#define ONENAND_DATAIN_ERASE_VERIFY	(0x15)
+#define ONENAND_DATAIN_UNLOCK_START	(0x08)
+#define ONENAND_DATAIN_UNLOCK_END	(0x09)
+#define ONENAND_DATAIN_LOCK_START	(0x0A)
+#define ONENAND_DATAIN_LOCK_END		(0x0B)
+#define ONENAND_DATAIN_LOCKTIGHT_START	(0x0C)
+#define ONENAND_DATAIN_LOCKTIGHT_END	(0x0D)
+#define ONENAND_DATAIN_UNLOCK_ALL	(0x0E)
+#define ONENAND_DATAIN_COPYBACK_SRC	(0x1000)
+#define ONENAND_DATAIN_COPYBACK_DST	(0x2000)
+#define ONENAND_DATAIN_ACCESS_OTP	(0x12)
+#define ONENAND_DATAIN_ACCESS_MAIN	(0x14)
+#define ONENAND_DATAIN_ACCESS_SPARE	(0x13)
+#define ONENAND_DATAIN_ACCESS_MAIN_AND_SPARE	(0x16)
+#define ONENAND_DATAIN_PIPELINE_READ	(0x4000)
+#define ONENAND_DATAIN_PIPELINE_WRITE	(0x4100)
+#define ONENAND_DATAIN_RMW_LOAD		(0x10)
+#define ONENAND_DATAIN_RMW_MODIFY	(0x11)
+
+/*
+ * Command Mapping for S5PC110 OneNAND Controller
+ */
+#define ONENAND_AHB_ADDR		(0xB0000000)
+#define ONENAND_DUMMY_ADDR		(0xB0400000)
+#define ONENAND_CMD_SHIFT		(26)
+#define ONENAND_CMD_MAP_00		(0x0)
+#define ONENAND_CMD_MAP_01		(0x1)
+#define ONENAND_CMD_MAP_10		(0x2)
+#define ONENAND_CMD_MAP_11		(0x3)
+#define ONENAND_CMD_MAP_FF		(0xF)
+
+/*
+ * Mask for Mapping table
+ */
+#define ONENAND_MEM_ADDR_MASK		(0xffffff)
+#define ONENAND_DDP_SHIFT_1Gb		(22)
+#define ONENAND_DDP_SHIFT_2Gb		(23)
+#define ONENAND_DDP_SHIFT_4Gb		(24)
+#define ONENAND_FBA_SHIFT		(13)
+#define ONENAND_FPA_SHIFT		(7)
+#define ONENAND_FSA_SHIFT		(5)
+#define ONENAND_FBA_MASK_128Mb		(0xff)
+#define ONENAND_FBA_MASK_256Mb		(0x1ff)
+#define ONENAND_FBA_MASK_512Mb		(0x1ff)
+#define ONENAND_FBA_MASK_1Gb_DDP	(0x1ff)
+#define ONENAND_FBA_MASK_1Gb		(0x3ff)
+#define ONENAND_FBA_MASK_2Gb_DDP	(0x3ff)
+#define ONENAND_FBA_MASK_2Gb		(0x7ff)
+#define ONENAND_FBA_MASK_4Gb_DDP	(0x7ff)
+#define ONENAND_FBA_MASK_4Gb		(0xfff)
+#define ONENAND_FPA_MASK		(0x3f)
+#define ONENAND_FSA_MASK		(0x3)
+
+#endif
+
+/*
+ * Device ID Register F001h (R)
+ */
+#define ONENAND_DEVICE_DENSITY_SHIFT	(4)
+#define ONENAND_DEVICE_IS_DDP		(1 << 3)
+#define ONENAND_DEVICE_IS_DEMUX		(1 << 2)
+#define ONENAND_DEVICE_VCC_MASK		(0x3)
+
+/*
+ * Version ID Register F002h (R)
+ */
+#define ONENAND_VERSION_PROCESS_SHIFT	(8)
+
+/*
+ * Start Address 1 F100h (R/W)
+ */
+#define ONENAND_DDP_SHIFT		(15)
+#define ONENAND_DDP_CHIP0		(0)
+#define ONENAND_DDP_CHIP1		(1 << ONENAND_DDP_SHIFT)
+
+/*
+ * Start Buffer Register F200h (R/W)
+ */
+#define ONENAND_BSA_MASK		(0x03)
+#define ONENAND_BSA_SHIFT		(8)
+#define ONENAND_BSA_BOOTRAM		(0 << 2)
+#define ONENAND_BSA_DATARAM0		(2 << 2)
+#define ONENAND_BSA_DATARAM1		(3 << 2)
+#define ONENAND_BSC_MASK		(0x03)
+
+/*
+ * Command Register F220h (R/W)
+ */
+#define ONENAND_CMD_READ		(0x00)
+#define ONENAND_CMD_READOOB		(0x13)
+#define ONENAND_CMD_PROG		(0x80)
+#define ONENAND_CMD_PROGOOB		(0x1A)
+#define ONENAND_CMD_UNLOCK		(0x23)
+#define ONENAND_CMD_LOCK		(0x2A)
+#define ONENAND_CMD_LOCK_TIGHT		(0x2C)
+#define ONENAND_CMD_UNLOCK_ALL		(0x27)
+#define ONENAND_CMD_ERASE		(0x94)
+#define ONENAND_CMD_RESET		(0xF0)
+#define ONENAND_CMD_OTP_ACCESS		(0x65)
+#define ONENAND_CMD_READID		(0x90)
+#define ONENAND_CMD_STARTADDR1		(0xE0)
+#define ONENAND_CMD_WP_STATUS		(0xE1)
+#define ONENAND_CMD_PIPELINE_READ	(0x01)
+#define ONENAND_CMD_PIPELINE_WRITE	(0x81)
+
+/*
+ * System Configuration 1 Register F221h (R, R/W)
+ */
+#define ONENAND_SYS_CFG1_SYNC_READ	(1 << 15)
+#define ONENAND_SYS_CFG1_BRL_7		(7 << 12)
+#define ONENAND_SYS_CFG1_BRL_6		(6 << 12)
+#define ONENAND_SYS_CFG1_BRL_5		(5 << 12)
+#define ONENAND_SYS_CFG1_BRL_4		(4 << 12)
+#define ONENAND_SYS_CFG1_BRL_3		(3 << 12)
+#define ONENAND_SYS_CFG1_BRL_10		(2 << 12)
+#define ONENAND_SYS_CFG1_BRL_9		(1 << 12)
+#define ONENAND_SYS_CFG1_BRL_8		(0 << 12)
+#define ONENAND_SYS_CFG1_BRL_SHIFT	(12)
+#define ONENAND_SYS_CFG1_BL_32		(4 << 9)
+#define ONENAND_SYS_CFG1_BL_16		(3 << 9)
+#define ONENAND_SYS_CFG1_BL_8		(2 << 9)
+#define ONENAND_SYS_CFG1_BL_4		(1 << 9)
+#define ONENAND_SYS_CFG1_BL_CONT	(0 << 9)
+#define ONENAND_SYS_CFG1_BL_SHIFT	(9)
+#define ONENAND_SYS_CFG1_NO_ECC		(1 << 8)
+#define ONENAND_SYS_CFG1_RDY		(1 << 7)
+#define ONENAND_SYS_CFG1_INT		(1 << 6)
+#define ONENAND_SYS_CFG1_IOBE		(1 << 5)
+#define ONENAND_SYS_CFG1_RDY_CONF	(1 << 4)
+
+/*
+ * Controller Status Register F240h (R)
+ */
+#define ONENAND_CTRL_ONGO		(1 << 15)
+#define ONENAND_CTRL_LOCK		(1 << 14)
+#define ONENAND_CTRL_LOAD		(1 << 13)
+#define ONENAND_CTRL_PROGRAM		(1 << 12)
+#define ONENAND_CTRL_ERASE		(1 << 11)
+#define ONENAND_CTRL_ERROR		(1 << 10)
+#define ONENAND_CTRL_RSTB		(1 << 7)
+#define ONENAND_CTRL_OTP_L		(1 << 6)
+#define ONENAND_CTRL_OTP_BL		(1 << 5)
+
+/*
+ * Interrupt Status Register F241h (R)
+ */
+#define ONENAND_INT_MASTER		(1 << 15)
+#define ONENAND_INT_READ		(1 << 7)
+#define ONENAND_INT_WRITE		(1 << 6)
+#define ONENAND_INT_ERASE		(1 << 5)
+#define ONENAND_INT_RESET		(1 << 4)
+#define ONENAND_INT_CLEAR		(0 << 0)
+
+/*
+ * NAND Flash Write Protection Status Register F24Eh (R)
+ */
+#define ONENAND_WP_US			(1 << 2)
+#define ONENAND_WP_LS			(1 << 1)
+#define ONENAND_WP_LTS			(1 << 0)
+
+/*
+ * ECC Status Register FF00h (R)
+ */
+#define ONENAND_ECC_1BIT		(1 << 0)
+#define ONENAND_ECC_1BIT_ALL		(0x5555)
+#define ONENAND_ECC_2BIT		(1 << 1)
+#define ONENAND_ECC_2BIT_ALL		(0xAAAA)
+
+/*
+ * One-Time Programmable (OTP)
+ */
+#define ONENAND_OTP_LOCK_OFFSET		(14)
+
+/*************************************************************
+ * End of OneNAND Controller
+ *************************************************************/
+/*
+ * Interrupt
+ */
+#define ELFIN_VIC0_BASE_ADDR		(0xF2000000)
+#define ELFIN_VIC1_BASE_ADDR		(0xF2100000)
+#define ELFIN_VIC2_BASE_ADDR		(0xF2200000)
+
+#define ELFIN_TZIC0_BASE_ADDR		(0xF2800000)
+#define ELFIN_TZIC1_BASE_ADDR		(0xF2900000)
+#define ELFIN_TZIC2_BASE_ADDR		(0xF2A00000)
+
+#define oINTMOD				(0x0C)		// VIC INT SELECT (IRQ or FIQ)
+#define oINTUNMSK			(0x10)		// VIC INT EN (Unmask by writing 1)
+#define oINTMSK				(0x14)		// VIC INT EN CLEAR (Mask by writing 1)
+#define oINTSUBMSK			(0x1C)		// VIC SOFT INT CLEAR
+#define oVECTADDR			(0xF00)		// VIC ADDRESS
+
+/*
+ * Watchdog timer
+ */
+#define ELFIN_WATCHDOG_BASE		0xE2700000
+
+#define WTCON_OFFSET			0x00
+#define WTDAT_OFFSET			0x08
+#define WTCNT_OFFSET			0x0C
+
+#define WTCON_REG			__REG(ELFIN_WATCHDOG_BASE+WTCON_OFFSET)
+#define WTDAT_REG			__REG(ELFIN_WATCHDOG_BASE+WTDAT_OFFSET)
+#define WTCNT_REG			__REG(ELFIN_WATCHDOG_BASE+WTCNT_OFFSET)
+
+/*
+ * UART
+ */
+#define ELFIN_UART_BASE			0XE2900000
+
+#define ELFIN_UART0_OFFSET		0x0000
+#define ELFIN_UART1_OFFSET		0x0400
+#define ELFIN_UART2_OFFSET		0x0800
+#define ELFIN_UART3_OFFSET		0x0c00
+
+#if defined(CONFIG_SERIAL0)
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART0_OFFSET)
+#elif defined(CONFIG_SERIAL1)
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART1_OFFSET)
+#elif defined(CONFIG_SERIAL2)
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART2_OFFSET)
+#elif defined(CONFIG_SERIAL3)
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART3_OFFSET)
+#else
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART0_OFFSET)
+#endif
+
+#define ULCON_OFFSET			0x00
+#define UCON_OFFSET			0x04
+#define UFCON_OFFSET			0x08
+#define UMCON_OFFSET			0x0C
+#define UTRSTAT_OFFSET			0x10
+#define UERSTAT_OFFSET			0x14
+#define UFSTAT_OFFSET			0x18
+#define UMSTAT_OFFSET			0x1C
+#define UTXH_OFFSET			0x20
+#define URXH_OFFSET			0x24
+#define UBRDIV_OFFSET			0x28
+#define UDIVSLOT_OFFSET			0x2C
+#define UINTP_OFFSET			0x30
+#define UINTSP_OFFSET			0x34
+#define UINTM_OFFSET			0x38
+
+#define UTRSTAT_TX_EMPTY		BIT2
+#define UTRSTAT_RX_READY		BIT0
+#define UART_ERR_MASK			0xF
+
+
+/*
+ * PWM timer
+ */
+#define ELFIN_TIMER_BASE		0xE2500000
+
+#define TCFG0_REG			__REG(0xE2500000)
+#define TCFG1_REG			__REG(0xE2500004)
+#define TCON_REG			__REG(0xE2500008)
+#define TCNTB0_REG			__REG(0xE250000c)
+#define TCMPB0_REG			__REG(0xE2500010)
+#define TCNTO0_REG			__REG(0xE2500014)
+#define TCNTB1_REG			__REG(0xE2500018)
+#define TCMPB1_REG			__REG(0xE250001c)
+#define TCNTO1_REG			__REG(0xE2500020)
+#define TCNTB2_REG			__REG(0xE2500024)
+#define TCMPB2_REG			__REG(0xE2500028)
+#define TCNTO2_REG			__REG(0xE250002c)
+#define TCNTB3_REG			__REG(0xE2500030)
+#define TCMPB3_REG			__REG(0xE2500034)
+#define TCNTO3_REG			__REG(0xE2500038)
+#define TCNTB4_REG			__REG(0xE250003c)
+#define TCNTO4_REG			__REG(0xE2500040)
+#define TINT_CSTAT			__REG(0xE2500044)
+
+#if 0
+/* Fields */
+#define fTCFG0_DZONE			Fld(8,16)       /* the dead zone length (= timer 0) */
+#define fTCFG0_PRE1			Fld(8,8)        /* prescaler value for time 2,3,4 */
+#define fTCFG0_PRE0			Fld(8,0)        /* prescaler value for time 0,1 */
+#define fTCFG1_MUX4			Fld(4,16)
+/* bits */
+#define TCFG0_DZONE(x)			FInsrt((x), fTCFG0_DZONE)
+#define TCFG0_PRE1(x)			FInsrt((x), fTCFG0_PRE1)
+#define TCFG0_PRE0(x)			FInsrt((x), fTCFG0_PRE0)
+#define TCON_4_AUTO			(1 << 22)       /* auto reload on/off for Timer 4 */
+#define TCON_4_UPDATE			(1 << 21)       /* manual Update TCNTB4 */
+#define TCON_4_ONOFF			(1 << 20)       /* 0: Stop, 1: start Timer 4 */
+#define COUNT_4_ON			(TCON_4_ONOFF*1)
+#define COUNT_4_OFF			(TCON_4_ONOFF*0)
+#define TCON_3_AUTO			(1 << 19)       /* auto reload on/off for Timer 3 */
+#define TIMER3_ATLOAD_ON		(TCON_3_AUTO*1)
+#define TIMER3_ATLAOD_OFF		FClrBit(TCON, TCON_3_AUTO)
+#define TCON_3_INVERT			(1 << 18)       /* 1: Inverter on for TOUT3 */
+#define TIMER3_IVT_ON			(TCON_3_INVERT*1)
+#define TIMER3_IVT_OFF			(FClrBit(TCON, TCON_3_INVERT))
+#define TCON_3_MAN			(1 << 17)       /* manual Update TCNTB3,TCMPB3 */
+#define TIMER3_MANUP			(TCON_3_MAN*1)
+#define TIMER3_NOP			(FClrBit(TCON, TCON_3_MAN))
+#define TCON_3_ONOFF			(1 << 16)       /* 0: Stop, 1: start Timer 3 */
+#define TIMER3_ON			(TCON_3_ONOFF*1)
+#define TIMER3_OFF			(FClrBit(TCON, TCON_3_ONOFF))
+/* macros */
+#define GET_PRESCALE_TIMER4(x)		FExtr((x), fTCFG0_PRE1)
+#define GET_DIVIDER_TIMER4(x)		FExtr((x), fTCFG1_MUX4)
+#endif
+
+/*
+ * USB2.0 HS OTG (Chapter 26)
+ */
+#define USBOTG_LINK_BASE		(0xEC000000)
+#define USBOTG_PHY_BASE			(0xEC100000)
+
+#define S5P_OTG_PHYPWR	 		(USBOTG_PHY_BASE + 0x000) /* R/W OTG PHY Power Control Register */
+#define S5P_OTG_PHYCLK 			(USBOTG_PHY_BASE + 0x004) /* R/W OTG PHY Clock Control Register */
+#define S5P_OTG_RSTCON 			(USBOTG_PHY_BASE + 0x008) /* R/W OTG Reset Control Register */
+#define S5P_OTG_PHYTUNE0 		(USBOTG_PHY_BASE + 0x020) /* R/W OTG PHY0 Tuning Register */
+#define S5P_OTG_PHYTUNE1 		(USBOTG_PHY_BASE + 0x024) /* R/W OTG PHY1 Tuning Register */
+
+/* Core Global Register */
+#define S5P_OTG_GOTGCTL 		(USBOTG_LINK_BASE + 0x000) /* R/W OTG Control and Status Register */
+#define S5P_OTG_GOTGINT 		(USBOTG_LINK_BASE + 0x004) /* R/W OTG Interrupt Register */
+#define S5P_OTG_GAHBCFG 		(USBOTG_LINK_BASE + 0x008) /* R/W Core AHB Configuration Register */
+#define S5P_OTG_GUSBCFG 		(USBOTG_LINK_BASE + 0x00C) /* R/W Core USB Configuration Register */
+#define S5P_OTG_GRSTCTL 		(USBOTG_LINK_BASE + 0x010) /* R/W Core Reset Register */
+#define S5P_OTG_GINTSTS 		(USBOTG_LINK_BASE + 0x014) /* R/W Core Interrupt Register */
+#define S5P_OTG_GINTMSK 		(USBOTG_LINK_BASE + 0x018) /* R/W Core Interrupt Mask Register */
+#define S5P_OTG_GRXSTSR 		(USBOTG_LINK_BASE + 0x01C) /* R Receive Status Debug Read Register */
+#define S5P_OTG_GRXSTSP 		(USBOTG_LINK_BASE + 0x020) /* R Receive Status Read/Pop Register */
+#define S5P_OTG_GRXFSIZ 		(USBOTG_LINK_BASE + 0x024) /* R/W Receive FIFO Size Register */
+#define S5P_OTG_GNPTXFSIZ 		(USBOTG_LINK_BASE + 0x028) /* R/W Non-Periodic Transmit FIFO Size Register */
+#define S5P_OTG_GNPTXSTS 		(USBOTG_LINK_BASE + 0x02C) /* R Non-Periodic Transmit FIFO/Queue Status Register */
+#define S5P_OTG_HPTXFSIZ 		(USBOTG_LINK_BASE + 0x100) /* R/W Host Periodic Transmit FIFO Size Register */
+#define S5P_OTG_DPTXFSIZ1 		(USBOTG_LINK_BASE + 0x104) /* R/W Device Periodic Transmit FIFO-1 Size Register */
+#define S5P_OTG_DPTXFSIZ2 		(USBOTG_LINK_BASE + 0x108) /* R/W Device Periodic Transmit FIFO-2 Size Register */
+#define S5P_OTG_DPTXFSIZ3 		(USBOTG_LINK_BASE + 0x10C) /* R/W Device Periodic Transmit FIFO-3 Size Register */
+#define S5P_OTG_DPTXFSIZ4 		(USBOTG_LINK_BASE + 0x110) /* R/W Device Periodic Transmit FIFO-4 Size Register */
+#define S5P_OTG_DPTXFSIZ5 		(USBOTG_LINK_BASE + 0x114) /* R/W Device Periodic Transmit FIFO-5 Size Register */
+#define S5P_OTG_DPTXFSIZ6 		(USBOTG_LINK_BASE + 0x118) /* R/W Device Periodic Transmit FIFO-6 Size Register */
+#define S5P_OTG_DPTXFSIZ7 		(USBOTG_LINK_BASE + 0x11C) /* R/W Device Periodic Transmit FIFO-7 Size Register */
+#define S5P_OTG_DPTXFSIZ8 		(USBOTG_LINK_BASE + 0x120) /* R/W Device Periodic Transmit FIFO-8 Size Register */
+#define S5P_OTG_DPTXFSIZ9 		(USBOTG_LINK_BASE + 0x124) /* R/W Device Periodic Transmit FIFO-9 Size Register */
+#define S5P_OTG_DPTXFSIZ10 		(USBOTG_LINK_BASE + 0x128) /* R/W Device Periodic Transmit FIFO-10 Size Register */
+#define S5P_OTG_DPTXFSIZ11 		(USBOTG_LINK_BASE + 0x12C) /* R/W Device Periodic Transmit FIFO-11 Size Register */
+#define S5P_OTG_DPTXFSIZ12 		(USBOTG_LINK_BASE + 0x130) /* R/W Device Periodic Transmit FIFO-12 Size Register */
+#define S5P_OTG_DPTXFSIZ13 		(USBOTG_LINK_BASE + 0x134) /* R/W Device Periodic Transmit FIFO-13 Size Register */
+#define S5P_OTG_DPTXFSIZ14 		(USBOTG_LINK_BASE + 0x138) /* R/W Device Periodic Transmit FIFO-14 Size Register */
+#define S5P_OTG_DPTXFSIZ15 		(USBOTG_LINK_BASE + 0x13C) /* R/W Device Periodic Transmit FIFO-15 Size Register */
+
+/* Host Mode Register */
+/* Host Global Register */
+#define S5P_OTG_HCFG 			(USBOTG_LINK_BASE + 0x400) /* R/W Host Configuration Register */
+#define S5P_OTG_HFIR 			(USBOTG_LINK_BASE + 0x404) /* R/W Host Frame Interval Register */
+#define S5P_OTG_HFNUM 			(USBOTG_LINK_BASE + 0x408) /* R Host Frame Number/Frame Time Remaining Register */
+
+#define S5P_OTG_HPTXSTS 		(USBOTG_LINK_BASE + 0x410) /* R Host Periodic Transmit FIFO/Queue Status Register */
+#define S5P_OTG_HAINT 			(USBOTG_LINK_BASE + 0x414) /* R Host All Channels Interrupt Register */
+#define S5P_OTG_HAINTMSK 		(USBOTG_LINK_BASE + 0x418) /* R/W Host All Channels Interrupt Mask Register */
+
+/*Host Port Control and Status Register */
+#define S5P_OTG_HPRT 			(USBOTG_LINK_BASE + 0x440) /* R/W Host Port Control and Status Register */
+
+/*Host Channel-Specific Register */
+#define S5P_OTG_HCCHAR0 		(USBOTG_LINK_BASE + 0x500) /* R/W Host Channel 0 Characteristics Register */
+#define S5P_OTG_HCSPLT0 		(USBOTG_LINK_BASE + 0x504) /* R/W Host Channel 0 Spilt Control Register */
+#define S5P_OTG_HCINT0 			(USBOTG_LINK_BASE + 0x508) /* R/W Host Channel 0 Interrupt Register */
+#define S5P_OTG_HCINTMSK0 		(USBOTG_LINK_BASE + 0x50C) /* R/W Host Channel 0 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ0 		(USBOTG_LINK_BASE + 0x510) /* R/W Host Channel 0 Transfer Size Register */
+#define S5P_OTG_HCDMA0 			(USBOTG_LINK_BASE + 0x514) /* R/W Host Channel 0 DMA Address Register */
+#define S5P_OTG_HCCHAR1 		(USBOTG_LINK_BASE + 0x520) /* R/W Host Channel 1 Characteristics Register */
+#define S5P_OTG_HCSPLT1 		(USBOTG_LINK_BASE + 0x524) /* R/W Host Channel 1 Spilt Control Register */
+#define S5P_OTG_HCINT1 			(USBOTG_LINK_BASE + 0x528) /* R/W Host Channel 1 Interrupt Register */
+#define S5P_OTG_HCINTMSK1 		(USBOTG_LINK_BASE + 0x52C) /* R/W Host Channel 1 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ1 		(USBOTG_LINK_BASE + 0x530) /* R/W Host Channel 1 Transfer Size Register */
+#define S5P_OTG_HCDMA1 			(USBOTG_LINK_BASE + 0x534) /* R/W Host Channel 1 DMA Address Register */
+#define S5P_OTG_HCCHAR2 		(USBOTG_LINK_BASE + 0x540) /* R/W Host Channel 2 Characteristics Register */
+#define S5P_OTG_HCSPLT2 		(USBOTG_LINK_BASE + 0x544) /* R/W Host Channel 2 Spilt Control Register */
+#define S5P_OTG_HCINT2 			(USBOTG_LINK_BASE + 0x548) /* R/W Host Channel 2 Interrupt Register */
+#define S5P_OTG_HCINTMSK2 		(USBOTG_LINK_BASE + 0x54C) /* R/W Host Channel 2 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ2 		(USBOTG_LINK_BASE + 0x550) /* R/W Host Channel 2 Transfer Size Register */
+#define S5P_OTG_HCDMA2 			(USBOTG_LINK_BASE + 0x554) /* R/W Host Channel 2 DMA Address Register */
+#define S5P_OTG_HCCHAR3 		(USBOTG_LINK_BASE + 0x560) /* R/W Host Channel 3 Characteristics Register */
+#define S5P_OTG_HCSPLT3 		(USBOTG_LINK_BASE + 0x564) /* R/W Host Channel 3 Spilt Control Register */
+#define S5P_OTG_HCINT3 			(USBOTG_LINK_BASE + 0x568) /* R/W Host Channel 3 Interrupt Register */
+#define S5P_OTG_HCINTMSK3 		(USBOTG_LINK_BASE + 0x56C) /* R/W Host Channel 3 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ3 		(USBOTG_LINK_BASE + 0x570) /* R/W Host Channel 3 Transfer Size Register */
+#define S5P_OTG_HCDMA3 			(USBOTG_LINK_BASE + 0x574) /* R/W Host Channel 3 DMA Address Register */
+#define S5P_OTG_HCCHAR4 		(USBOTG_LINK_BASE + 0x580) /* R/W Host Channel 4 Characteristics Register */
+#define S5P_OTG_HCSPLT4 		(USBOTG_LINK_BASE + 0x584) /* R/W Host Channel 4 Spilt Control Register */
+#define S5P_OTG_HCINT4 			(USBOTG_LINK_BASE + 0x588) /* R/W Host Channel 4 Interrupt Register */
+#define S5P_OTG_HCINTMSK4 		(USBOTG_LINK_BASE + 0x58C) /* R/W Host Channel 4 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ4 		(USBOTG_LINK_BASE + 0x580) /* R/W Host Channel 4 Transfer Size Register */
+#define S5P_OTG_HCDMA4 			(USBOTG_LINK_BASE + 0x584) /* R/W Host Channel 4 DMA Address Register */
+#define S5P_OTG_HCCHAR5 		(USBOTG_LINK_BASE + 0x5A0) /* R/W Host Channel 5 Characteristics Register */
+#define S5P_OTG_HCSPLT5 		(USBOTG_LINK_BASE + 0x5A4) /* R/W Host Channel 5 Spilt Control Register */
+#define S5P_OTG_HCINT5 			(USBOTG_LINK_BASE + 0x5A8) /* R/W Host Channel 5 Interrupt Register */
+#define S5P_OTG_HCINTMSK5 		(USBOTG_LINK_BASE + 0x5AC) /* R/W Host Channel 5 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ5 		(USBOTG_LINK_BASE + 0x5B0) /* R/W Host Channel 5 Transfer Size Register */
+#define S5P_OTG_HCDMA5 			(USBOTG_LINK_BASE + 0x5B4) /* R/W Host Channel 5 DMA Address Register */
+#define S5P_OTG_HCCHAR6 		(USBOTG_LINK_BASE + 0x5C0) /* R/W Host Channel 6 Characteristics Register */
+#define S5P_OTG_HCSPLT6 		(USBOTG_LINK_BASE + 0x5C4) /* R/W Host Channel 6 Spilt Control Register */
+#define S5P_OTG_HCINT6 			(USBOTG_LINK_BASE + 0x5C8) /* R/W Host Channel 6 Interrupt Register */
+#define S5P_OTG_HCINTMSK6 		(USBOTG_LINK_BASE + 0x5CC) /* R/W Host Channel 6 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ6 		(USBOTG_LINK_BASE + 0x5D0) /* R/W Host Channel 6 Transfer Size Register */
+#define S5P_OTG_HCDMA6 			(USBOTG_LINK_BASE + 0x5D4) /* R/W Host Channel 6 DMA Address Register */
+#define S5P_OTG_HCCHAR7 		(USBOTG_LINK_BASE + 0x5E0) /* R/W Host Channel 7 Characteristics Register */
+#define S5P_OTG_HCSPLT7 		(USBOTG_LINK_BASE + 0x5E4) /* R/W Host Channel 7 Spilt Control Register */
+#define S5P_OTG_HCINT7 			(USBOTG_LINK_BASE + 0x5E8) /* R/W Host Channel 7 Interrupt Register */
+#define S5P_OTG_HCINTMSK7 		(USBOTG_LINK_BASE + 0x5EC) /* R/W Host Channel 7 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ7 		(USBOTG_LINK_BASE + 0x5F0) /* R/W Host Channel 7 Transfer Size Register */
+#define S5P_OTG_HCDMA7 			(USBOTG_LINK_BASE + 0x5F4) /* R/W Host Channel 7 DMA Address Register */
+#define S5P_OTG_HCCHAR8 		(USBOTG_LINK_BASE + 0x600) /* R/W Host Channel 8 Characteristics Register */
+#define S5P_OTG_HCSPLT8 		(USBOTG_LINK_BASE + 0x604) /* R/W Host Channel 8 Spilt Control Register */
+#define S5P_OTG_HCINT8 			(USBOTG_LINK_BASE + 0x608) /* R/W Host Channel 8 Interrupt Register */
+#define S5P_OTG_HCINTMSK8 		(USBOTG_LINK_BASE + 0x60C) /* R/W Host Channel 8 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ8 		(USBOTG_LINK_BASE + 0x610) /* R/W Host Channel 8 Transfer Size Register */
+#define S5P_OTG_HCDMA8 			(USBOTG_LINK_BASE + 0x614) /* R/W Host Channel 8 DMA Address Register */
+#define S5P_OTG_HCCHAR9 		(USBOTG_LINK_BASE + 0x620) /* R/W Host Channel 9 Characteristics Register */
+#define S5P_OTG_HCSPLT9 		(USBOTG_LINK_BASE + 0x624) /* R/W Host Channel 9 Spilt Control Register */
+#define S5P_OTG_HCINT9 			(USBOTG_LINK_BASE + 0x628) /* R/W Host Channel 9 Interrupt Register */
+#define S5P_OTG_HCINTMSK9 		(USBOTG_LINK_BASE + 0x62C) /* R/W Host Channel 9 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ9 		(USBOTG_LINK_BASE + 0x630) /* R/W Host Channel 9 Transfer Size Register */
+#define S5P_OTG_HCDMA9 			(USBOTG_LINK_BASE + 0x634) /* R/W Host Channel 9 DMA Address Register */
+#define S5P_OTG_HCCHAR10 		(USBOTG_LINK_BASE + 0x640) /* R/W Host Channel 10 Characteristics Register */
+#define S5P_OTG_HCSPLT10 		(USBOTG_LINK_BASE + 0x644) /* R/W Host Channel 10 Spilt Control Register */
+#define S5P_OTG_HCINT10 		(USBOTG_LINK_BASE + 0x648) /* R/W Host Channel 10 Interrupt Register */
+#define S5P_OTG_HCINTMSK10 		(USBOTG_LINK_BASE + 0x64C) /* R/W Host Channel 10 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ10 		(USBOTG_LINK_BASE + 0x650) /* R/W Host Channel 10 Transfer Size Register */
+#define S5P_OTG_HCDMA10 		(USBOTG_LINK_BASE + 0x654) /* R/W Host Channel 10 DMA Address Register */
+#define S5P_OTG_HCCHAR11 		(USBOTG_LINK_BASE + 0x660) /* R/W Host Channel 11 Characteristics Register */
+#define S5P_OTG_HCSPLT11 		(USBOTG_LINK_BASE + 0x664) /* R/W Host Channel 11 Spilt Control Register */
+#define S5P_OTG_HCINT11 		(USBOTG_LINK_BASE + 0x668) /* R/W Host Channel 11 Interrupt Register */
+#define S5P_OTG_HCINTMSK11 		(USBOTG_LINK_BASE + 0x66C) /* R/W Host Channel 11 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ11 		(USBOTG_LINK_BASE + 0x670) /* R/W Host Channel 11 Transfer Size Register */
+#define S5P_OTG_HCDMA11 		(USBOTG_LINK_BASE + 0x674) /* R/W Host Channel 11 DMA Address Register */
+#define S5P_OTG_HCCHAR12 		(USBOTG_LINK_BASE + 0x680) /* R/W Host Channel 12 Characteristics Register */
+#define S5P_OTG_HCSPLT12 		(USBOTG_LINK_BASE + 0x684) /* R/W Host Channel 12 Spilt Control Register */
+#define S5P_OTG_HCINT12 		(USBOTG_LINK_BASE + 0x688) /* R/W Host Channel 12 Interrupt Register */
+#define S5P_OTG_HCINTMSK12 		(USBOTG_LINK_BASE + 0x68C) /* R/W Host Channel 12 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ12 		(USBOTG_LINK_BASE + 0x690) /* R/W Host Channel 12 Transfer Size Register */
+#define S5P_OTG_HCDMA12 		(USBOTG_LINK_BASE + 0x694) /* R/W Host Channel 12 DMA Address Register */
+#define S5P_OTG_HCCHAR13 		(USBOTG_LINK_BASE + 0x6A0) /* R/W Host Channel 13 Characteristics Register */
+#define S5P_OTG_HCSPLT13 		(USBOTG_LINK_BASE + 0x6A4) /* R/W Host Channel 13 Spilt Control Register */
+#define S5P_OTG_HCINT13 		(USBOTG_LINK_BASE + 0x6A8) /* R/W Host Channel 13 Interrupt Register */
+#define S5P_OTG_HCINTMSK13 		(USBOTG_LINK_BASE + 0x6AC) /* R/W Host Channel 13 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ13 		(USBOTG_LINK_BASE + 0x6B0) /* R/W Host Channel 13 Transfer Size Register */
+#define S5P_OTG_HCDMA13 		(USBOTG_LINK_BASE + 0x6B4) /* R/W Host Channel 13 DMA Address Register */
+#define S5P_OTG_HCCHAR14 		(USBOTG_LINK_BASE + 0x6C0) /* R/W Host Channel 14 Characteristics Register */
+#define S5P_OTG_HCSPLT14 		(USBOTG_LINK_BASE + 0x6C4) /* R/W Host Channel 14 Spilt Control Register */
+#define S5P_OTG_HCINT14 		(USBOTG_LINK_BASE + 0x6C8) /* R/W Host Channel 14 Interrupt Register */
+#define S5P_OTG_HCINTMSK14 		(USBOTG_LINK_BASE + 0x6CC) /* R/W Host Channel 14 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ14	 	(USBOTG_LINK_BASE + 0x6D0) /* R/W Host Channel 14 Transfer Size Register */
+#define S5P_OTG_HCDMA14 		(USBOTG_LINK_BASE + 0x6D4) /* R/W Host Channel 14 DMA Address Register */
+#define S5P_OTG_HCCHAR15 		(USBOTG_LINK_BASE + 0x6E0) /* R/W Host Channel 15 Characteristics Register */
+#define S5P_OTG_HCSPLT15 		(USBOTG_LINK_BASE + 0x6E4) /* R/W Host Channel 15 Spilt Control Register */
+#define S5P_OTG_HCINT15 		(USBOTG_LINK_BASE + 0x6E8) /* R/W Host Channel 15 Interrupt Register */
+#define S5P_OTG_HCINTMSK15 		(USBOTG_LINK_BASE + 0x6EC) /* R/W Host Channel 15 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ15 		(USBOTG_LINK_BASE + 0x6F0) /* R/W Host Channel 15 Transfer Size Register */
+#define S5P_OTG_HCDMA15 		(USBOTG_LINK_BASE + 0x6F4) /* R/W Host Channel 15 DMA Address Register */
+
+/* Device Global Register */
+#define S5P_OTG_DCFG 			(USBOTG_LINK_BASE + 0x800) /* R/W Device Configuration Register */
+#define S5P_OTG_DCTL 			(USBOTG_LINK_BASE + 0x804) /* R/W Device Control Register */
+#define S5P_OTG_DSTS 			(USBOTG_LINK_BASE + 0x808) /* R Device Status Register */
+#define S5P_OTG_DIEPMSK 		(USBOTG_LINK_BASE + 0x810) /* R/W Device IN Endpoint Common Interrupt Mask Register */
+#define S5P_OTG_DOEPMSK 		(USBOTG_LINK_BASE + 0x814) /* R/W Device OUT Endpoint Common Interrupt Mask Register */
+#define S5P_OTG_DAINT 			(USBOTG_LINK_BASE + 0x818) /* R Device ALL Endpoints Interrupt Register */
+#define S5P_OTG_DAINTMSK 		(USBOTG_LINK_BASE + 0x81C) /* R/W Device ALL Endpoints Interrupt Mask Register */
+#define S5P_OTG_DTKNQR1 		(USBOTG_LINK_BASE + 0x820) /* R Device IN Token Sequence Learning Queue Read Register */
+#define S5P_OTG_DTKNQR2 		(USBOTG_LINK_BASE + 0x824) /* R Device IN Token Sequence Learning Queue Read Register */
+#define S5P_OTG_DVBUSDIS 		(USBOTG_LINK_BASE + 0x828) /* R/W Device VBUS Discharge Time Register */
+#define S5P_OTG_DVBUSPULSE 		(USBOTG_LINK_BASE + 0x82C) /* R/W Device VBUS Pulsing Time Register */
+#define S5P_OTG_DTKNQR3 		(USBOTG_LINK_BASE + 0x830) /* R Device IN Token Sequence Learning Queue Read Register */
+#define S5P_OTG_DTKNQR4 		(USBOTG_LINK_BASE + 0x834) /* R Device IN Token Sequence Learning Queue Read Register */
+
+/* Device Logical IN Endpo int-Specific Registers */
+#define S5P_OTG_DIEPCTL0 		(USBOTG_LINK_BASE + 0x900) /* R/W Device Control IN Endpoint 0 Control Register */
+#define S5P_OTG_DIEPINT0 		(USBOTG_LINK_BASE + 0x908) /* R/W Device IN Endpoint 0 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ0 		(USBOTG_LINK_BASE + 0x910) /* R/W Device IN Endpoint 0 Transfer Size Register */
+#define S5P_OTG_DIEPDMA0 		(USBOTG_LINK_BASE + 0x914) /* R/W Device IN Endpoint 0 DMA Address Register */
+#define S5P_OTG_DIEPCTL1 		(USBOTG_LINK_BASE + 0x920) /* R/W Device Control IN Endpoint 1 Control Register */
+#define S5P_OTG_DIEPINT1 		(USBOTG_LINK_BASE + 0x928) /* R/W Device IN Endpoint 1 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ1 		(USBOTG_LINK_BASE + 0x930) /* R/W Device IN Endpoint 1 Transfer Size Register */
+#define S5P_OTG_DIEPDMA1 		(USBOTG_LINK_BASE + 0x934) /* R/W Device IN Endpoint 1 DMA Address Register */
+#define S5P_OTG_DIEPCTL2 		(USBOTG_LINK_BASE + 0x940) /* R/W Device Control IN Endpoint 2 Control Register */
+#define S5P_OTG_DIEPINT2 		(USBOTG_LINK_BASE + 0x948) /* R/W Device IN Endpoint 2 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ2 		(USBOTG_LINK_BASE + 0x950) /* R/W Device IN Endpoint 2 Transfer Size Register */
+#define S5P_OTG_DIEPDMA2 		(USBOTG_LINK_BASE + 0x954) /* R/W Device IN Endpoint 2 DMA Address Register */
+#define S5P_OTG_DIEPCTL3 		(USBOTG_LINK_BASE + 0x960) /* R/W Device Control IN Endpoint 3 Control Register */
+#define S5P_OTG_DIEPINT3 		(USBOTG_LINK_BASE + 0x968) /* R/W Device IN Endpoint 3 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ3 		(USBOTG_LINK_BASE + 0x970) /* R/W Device IN Endpoint 3 Transfer Size Register */
+#define S5P_OTG_DIEPDMA3 		(USBOTG_LINK_BASE + 0x974) /* R/W Device IN Endpoint 3 DMA Address Register */
+#define S5P_OTG_DIEPCTL4 		(USBOTG_LINK_BASE + 0x980) /* R/W Device Control IN Endpoint 0 Control Register */
+#define S5P_OTG_DIEPINT4 		(USBOTG_LINK_BASE + 0x988) /* R/W Device IN Endpoint 4 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ4 		(USBOTG_LINK_BASE + 0x990) /* R/W Device IN Endpoint 4 Transfer Size Register */
+#define S5P_OTG_DIEPDMA4 		(USBOTG_LINK_BASE + 0x994) /* R/W Device IN Endpoint 4 DMA Address Register */
+#define S5P_OTG_DIEPCTL5 		(USBOTG_LINK_BASE + 0x9A0) /* R/W Device Control IN Endpoint 5 Control Register */
+#define S5P_OTG_DIEPINT5 		(USBOTG_LINK_BASE + 0x9A8) /* R/W Device IN Endpoint 5 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ5 		(USBOTG_LINK_BASE + 0x9B0) /* R/W Device IN Endpoint 5 Transfer Size Register */
+#define S5P_OTG_DIEPDMA5 		(USBOTG_LINK_BASE + 0x9B4) /* R/W Device IN Endpoint 5 DMA Address Register */
+#define S5P_OTG_DIEPCTL6 		(USBOTG_LINK_BASE + 0x9C0) /* R/W Device Control IN Endpoint 6 Control Register */
+#define S5P_OTG_DIEPINT6		(USBOTG_LINK_BASE + 0x9C8) /* R/W Device IN Endpoint 6 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ6		(USBOTG_LINK_BASE + 0x9D0) /* R/W Device IN Endpoint 6 Transfer Size Register */
+#define S5P_OTG_DIEPDMA6		(USBOTG_LINK_BASE + 0x9D4) /* R/W Device IN Endpoint 6 DMA Address Register */
+#define S5P_OTG_DIEPCTL7		(USBOTG_LINK_BASE + 0x9E0) /* R/W Device Control IN Endpoint 7 Control Register */
+#define S5P_OTG_DIEPINT7		(USBOTG_LINK_BASE + 0x9E8) /* R/W Device IN Endpoint 7 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ7		(USBOTG_LINK_BASE + 0x9F0) /* R/W Device IN Endpoint 7 Transfer Size Register */
+#define S5P_OTG_DIEPDMA7		(USBOTG_LINK_BASE + 0x9F4) /* R/W Device IN Endpoint 7 DMA Address Register */
+#define S5P_OTG_DIEPCTL8		(USBOTG_LINK_BASE + 0xA00) /* R/W Device Control IN Endpoint 8 Control Register */
+#define S5P_OTG_DIEPINT8		(USBOTG_LINK_BASE + 0xA08) /* R/W Device IN Endpoint 8 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ8		(USBOTG_LINK_BASE + 0xA10) /* R/W Device IN Endpoint 8 Transfer Size Register */
+#define S5P_OTG_DIEPDMA8		(USBOTG_LINK_BASE + 0xA14) /* R/W Device IN Endpoint 8 DMA Address Register */
+#define S5P_OTG_DIEPCTL9		(USBOTG_LINK_BASE + 0xA20) /* R/W Device Control IN Endpoint 9 Control Register */
+#define S5P_OTG_DIEPINT9		(USBOTG_LINK_BASE + 0xA28) /* R/W Device IN Endpoint 9 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ9		(USBOTG_LINK_BASE + 0xA30) /* R/W Device IN Endpoint 9 Transfer Size Register */
+#define S5P_OTG_DIEPDMA9		(USBOTG_LINK_BASE + 0xA34) /* R/W Device IN Endpoint 9 DMA Address Register */
+#define S5P_OTG_DIEPCTL10		(USBOTG_LINK_BASE + 0xA40) /* R/W Device Control IN Endpoint 10 Control Register */
+#define S5P_OTG_DIEPINT10		(USBOTG_LINK_BASE + 0xA48) /* R/W Device IN Endpoint 10 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ10		(USBOTG_LINK_BASE + 0xA50) /* R/W Device IN Endpoint 10 Transfer Size Register */
+#define S5P_OTG_DIEPDMA10		(USBOTG_LINK_BASE + 0xA54) /* R/W Device IN Endpoint 10 DMA Address Register */
+#define S5P_OTG_DIEPCTL11		(USBOTG_LINK_BASE + 0xA60) /* R/W Device Control IN Endpoint 11 Control Register */
+#define S5P_OTG_DIEPINT11		(USBOTG_LINK_BASE + 0xA68) /* R/W Device IN Endpoint 11 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ11		(USBOTG_LINK_BASE + 0xA70) /* R/W Device IN Endpoint 11 Transfer Size Register */
+#define S5P_OTG_DIEPDMA11		(USBOTG_LINK_BASE + 0xA74) /* R/W Device IN Endpoint 11 DMA Address Register */
+#define S5P_OTG_DIEPCTL12		(USBOTG_LINK_BASE + 0xA80) /* R/W Device Control IN Endpoint 12 Control Register */
+#define S5P_OTG_DIEPINT12		(USBOTG_LINK_BASE + 0xA88) /* R/W Device IN Endpoint 12 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ12		(USBOTG_LINK_BASE + 0xA90) /* R/W Device IN Endpoint 12 Transfer Size Register */
+#define S5P_OTG_DIEPDMA12		(USBOTG_LINK_BASE + 0xA94) /* R/W Device IN Endpoint 12 DMA Address Register */
+#define S5P_OTG_DIEPCTL13		(USBOTG_LINK_BASE + 0xAA0) /* R/W Device Control IN Endpoint 13 Control Register */
+#define S5P_OTG_DIEPINT13		(USBOTG_LINK_BASE + 0xAA8) /* R/W Device IN Endpoint 13 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ13		(USBOTG_LINK_BASE + 0xAB0) /* R/W Device IN Endpoint 13 Transfer Size Register */
+#define S5P_OTG_DIEPDMA13		(USBOTG_LINK_BASE + 0xAB4) /* R/W Device IN Endpoint 13 DMA Address Register */
+#define S5P_OTG_DIEPCTL14		(USBOTG_LINK_BASE + 0xAC0) /* R/W Device Control IN Endpoint 14 Control Register */
+#define S5P_OTG_DIEPINT14		(USBOTG_LINK_BASE + 0xAC8) /* R/W Device IN Endpoint 14 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ14		(USBOTG_LINK_BASE + 0xAD0) /* R/W Device IN Endpoint 14 Transfer Size Register */
+#define S5P_OTG_DIEPDMA14		(USBOTG_LINK_BASE + 0xAD4) /* R/W Device IN Endpoint 14 DMA Address Register */
+#define S5P_OTG_DIEPCTL15		(USBOTG_LINK_BASE + 0xAE0) /* R/W Device Control IN Endpoint 15 Control Register */
+#define S5P_OTG_DIEPINT15		(USBOTG_LINK_BASE + 0xAE8) /* R/W Device IN Endpoint 15 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ15		(USBOTG_LINK_BASE + 0xAF0) /* R/W Device IN Endpoint 15 Transfer Size Register */
+#define S5P_OTG_DIEPDMA15		(USBOTG_LINK_BASE + 0xAF4) /* R/W Device IN Endpoint 15 DMA Address Register */
+
+/* Device Logical OUT Endpoint-Specific Register */
+#define S5P_OTG_DOEPCTL0		(USBOTG_LINK_BASE + 0xB00) /* R/W Device Control OUT Endpoint 0 Control Register */
+#define S5P_OTG_DOEPINT0		(USBOTG_LINK_BASE + 0xB08) /* R/W Device OUT Endpoint 0 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ0		(USBOTG_LINK_BASE + 0xB10) /* R/W Device OUT Endpoint 0 Transfer Size Register */
+#define S5P_OTG_DOEPDMA0		(USBOTG_LINK_BASE + 0xB14) /* R/W Device OUT Endpoint 0 DMA Address Register */
+#define S5P_OTG_DOEPCTL1		(USBOTG_LINK_BASE + 0xB20) /* R/W Device Control OUT Endpoint 1 Control Register */
+#define S5P_OTG_DOEPINT1		(USBOTG_LINK_BASE + 0xB28) /* R/W Device OUT Endpoint 1 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ1		(USBOTG_LINK_BASE + 0xB30) /* R/W Device OUT Endpoint 1 Transfer Size Register */
+#define S5P_OTG_DOEPDMA1		(USBOTG_LINK_BASE + 0xB34) /* R/W Device OUT Endpoint 1 DMA Address Register */
+#define S5P_OTG_DOEPCTL2		(USBOTG_LINK_BASE + 0xB40) /* R/W Device Control OUT Endpoint 2 Control Register */
+#define S5P_OTG_DOEPINT2		(USBOTG_LINK_BASE + 0xB48) /* R/W Device OUT Endpoint 2 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ2		(USBOTG_LINK_BASE + 0xB50) /* R/W Device OUT Endpoint 2 Transfer Size Register */
+#define S5P_OTG_DOEPDMA2		(USBOTG_LINK_BASE + 0xB54) /* R/W Device OUT Endpoint 2 DMA Address Register */
+#define S5P_OTG_DOEPCTL3		(USBOTG_LINK_BASE + 0xB60) /* R/W Device Control OUT Endpoint 3 Control Register */
+#define S5P_OTG_DOEPINT3		(USBOTG_LINK_BASE + 0xB68) /* R/W Device OUT Endpoint 3 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ3		(USBOTG_LINK_BASE + 0xB70) /* R/W Device OUT Endpoint 3 Transfer Size Register */
+#define S5P_OTG_DOEPDMA3		(USBOTG_LINK_BASE + 0xB74) /* R/W Device OUT Endpoint 3 DMA Address Register */
+#define S5P_OTG_DOEPCTL4		(USBOTG_LINK_BASE + 0xB80) /* R/W Device Control OUT Endpoint 4 Control Register */
+#define S5P_OTG_DOEPINT4		(USBOTG_LINK_BASE + 0xB88) /* R/W Device OUT Endpoint 4 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ4		(USBOTG_LINK_BASE + 0xB90) /* R/W Device OUT Endpoint 4 Transfer Size Register */
+#define S5P_OTG_DOEPDMA4		(USBOTG_LINK_BASE + 0xB94) /* R/W Device OUT Endpoint 4 DMA Address Register */
+#define S5P_OTG_DOEPCTL5		(USBOTG_LINK_BASE + 0xBA0) /* R/W Device Control OUT Endpoint 5 Control Register */
+#define S5P_OTG_DOEPINT5		(USBOTG_LINK_BASE + 0xBA8) /* R/W Device OUT Endpoint 5 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ5		(USBOTG_LINK_BASE + 0xBB0) /* R/W Device OUT Endpoint 5 Transfer Size Register */
+#define S5P_OTG_DOEPDMA5		(USBOTG_LINK_BASE + 0xBB4) /* R/W Device OUT Endpoint 5 DMA Address Register */
+#define S5P_OTG_DOEPCTL6		(USBOTG_LINK_BASE + 0xBC0) /* R/W Device Control OUT Endpoint 6 Control Register */
+#define S5P_OTG_DOEPINT6		(USBOTG_LINK_BASE + 0xBC8) /* R/W Device OUT Endpoint 6 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ6		(USBOTG_LINK_BASE + 0xBD0) /* R/W Device OUT Endpoint 6 Transfer Size Register */
+#define S5P_OTG_DOEPDMA6		(USBOTG_LINK_BASE + 0xBD4) /* R/W Device OUT Endpoint 6 DMA Address Register */
+#define S5P_OTG_DOEPCTL7		(USBOTG_LINK_BASE + 0xBE0) /* R/W Device Control OUT Endpoint 7 Control Register */
+#define S5P_OTG_DOEPINT7		(USBOTG_LINK_BASE + 0xBE8) /* R/W Device OUT Endpoint 7 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ7		(USBOTG_LINK_BASE + 0xBF0) /* R/W Device OUT Endpoint 7 Transfer Size Register */
+#define S5P_OTG_DOEPDMA7		(USBOTG_LINK_BASE + 0xBF4) /* R/W Device OUT Endpoint 7 DMA Address Register */
+#define S5P_OTG_DOEPCTL8		(USBOTG_LINK_BASE + 0xC00) /* R/W Device Control OUT Endpoint 8 Control Register */
+#define S5P_OTG_DOEPINT8		(USBOTG_LINK_BASE + 0xC08) /* R/W Device OUT Endpoint 8 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ8		(USBOTG_LINK_BASE + 0xC10) /* R/W Device OUT Endpoint 8 Transfer Size Register */
+#define S5P_OTG_DOEPDMA8		(USBOTG_LINK_BASE + 0xC14) /* R/W Device OUT Endpoint 8 DMA Address Register */
+#define S5P_OTG_DOEPCTL9		(USBOTG_LINK_BASE + 0xC20) /* R/W Device Control OUT Endpoint 9 Control Register */
+#define S5P_OTG_DOEPINT9		(USBOTG_LINK_BASE + 0xC28) /* R/W Device OUT Endpoint 9 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ9		(USBOTG_LINK_BASE + 0xC30) /* R/W Device OUT Endpoint 9 Transfer Size Register */
+#define S5P_OTG_DOEPDMA9		(USBOTG_LINK_BASE + 0xC34) /* R/W Device OUT Endpoint 9 DMA Address Register */
+#define S5P_OTG_DOEPCTL10		(USBOTG_LINK_BASE + 0xC40) /* R/W Device Control OUT Endpoint 10 Control Register */
+#define S5P_OTG_DOEPINT10		(USBOTG_LINK_BASE + 0xC48) /* R/W Device OUT Endpoint 10 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ10		(USBOTG_LINK_BASE + 0xC50) /* R/W Device OUT Endpoint 10 Transfer Size Register */
+#define S5P_OTG_DOEPDMA10		(USBOTG_LINK_BASE + 0xC54) /* R/W Device OUT Endpoint 10 DMA Address Register */
+#define S5P_OTG_DOEPCTL11		(USBOTG_LINK_BASE + 0xC60) /* R/W Device Control OUT Endpoint 11 Control Register */
+#define S5P_OTG_DOEPINT11		(USBOTG_LINK_BASE + 0xC68) /* R/W Device OUT Endpoint 11 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ11		(USBOTG_LINK_BASE + 0xC70) /* R/W Device OUT Endpoint 11 Transfer Size Register */
+#define S5P_OTG_DOEPDMA11		(USBOTG_LINK_BASE + 0xC74) /* R/W Device OUT Endpoint 11 DMA Address Register */
+#define S5P_OTG_DOEPCTL12		(USBOTG_LINK_BASE + 0xC80) /* R/W Device Control OUT Endpoint 12 Control Register */
+#define S5P_OTG_DOEPINT12		(USBOTG_LINK_BASE + 0xC88) /* R/W Device OUT Endpoint 12 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ12		(USBOTG_LINK_BASE + 0xC90) /* R/W Device OUT Endpoint 12 Transfer Size Register */
+#define S5P_OTG_DOEPDMA12		(USBOTG_LINK_BASE + 0xC94) /* R/W Device OUT Endpoint 12 DMA Address Register */
+#define S5P_OTG_DOEPCTL13		(USBOTG_LINK_BASE + 0xCA0) /* R/W Device Control OUT Endpoint 13 Control Register */
+#define S5P_OTG_DOEPINT13		(USBOTG_LINK_BASE + 0xCA8) /* R/W Device OUT Endpoint 13 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ13		(USBOTG_LINK_BASE + 0xCB0) /* R/W Device OUT Endpoint 13 Transfer Size Register */
+#define S5P_OTG_DOEPDMA13		(USBOTG_LINK_BASE + 0xCB4) /* R/W Device OUT Endpoint 13 DMA Address Register */
+#define S5P_OTG_DOEPCTL14		(USBOTG_LINK_BASE + 0xCC0) /* R/W Device Control OUT Endpoint 14 Control Register */
+#define S5P_OTG_DOEPINT14		(USBOTG_LINK_BASE + 0xCC8) /* R/W Device OUT Endpoint 14 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ14		(USBOTG_LINK_BASE + 0xCD0) /* R/W Device OUT Endpoint 14 Transfer Size Register */
+#define S5P_OTG_DOEPDMA14		(USBOTG_LINK_BASE + 0xCD4) /* R/W Device OUT Endpoint 14 DMA Address Register */
+#define S5P_OTG_DOEPCTL15		(USBOTG_LINK_BASE + 0xCE0) /* R/W Device Control OUT Endpoint 15 Control Register */
+#define S5P_OTG_OTG_DOEPINT15		(USBOTG_LINK_BASE + 0xCE8) /* R/W Device OUT Endpoint 15 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ15		(USBOTG_LINK_BASE + 0xCF0) /* R/W Device OUT Endpoint 15 Transfer Size Register */
+#define S5P_OTG_DOEPDMA15		(USBOTG_LINK_BASE + 0xCF4) /* R/W Device OUT Endpoint 15 DMA Address Register */
+
+/* Power and Clock Gating Register */
+#define S5P_OTG_PCGCCTL 		(USBOTG_LINK_BASE + 0xE00) /* R/W Power and Clock Gating Control Register */
+
+/* Endpoint FIFO address */
+#define S5P_OTG_EP0_FIFO		(USBOTG_LINK_BASE + 0x1000)
+
+/* USB Global Interrupt Status register(GINTSTS) setting value */
+#define GINTSTS_WkUpInt		(1<<31)
+#define GINTSTS_OEPInt		(1<<19)
+#define GINTSTS_IEPInt		(1<<18)
+#define GINTSTS_EnumDone	(1<<13)
+#define GINTSTS_USBRst		(1<<12)
+#define GINTSTS_USBSusp		(1<<11)
+#define GINTSTS_RXFLvl		(1<<4)
+
+#if 0
+/* include common stuff */
+#ifndef __ASSEMBLY__
+static inline S5PC11X_MEMCTL * S5PC11X_GetBase_MEMCTL(void)
+{
+	return (S5PC11X_MEMCTL *)(APB_DMC_0_BASE);
+}
+static inline S5PC11X_USB_HOST * S5PC11X_GetBase_USB_HOST(void)
+{
+	return (S5PC11X_USB_HOST *)ELFIN_USB_HOST_BASE;
+}
+static inline S5PC11X_INTERRUPT * S5PC11X_GetBase_INTERRUPT(void)
+{
+	return (S5PC11X_INTERRUPT *)ELFIN_VIC0_BASE_ADDR;
+}
+static inline S5PC11X_DMAS * S5PC11X_GetBase_DMAS(void)
+{
+	return (S5PC11X_DMAS *)ELFIN_DMA_BASE;
+}
+static inline S5PC11X_CLOCK_POWER * S5PC11X_GetBase_CLOCK_POWER(void)
+{
+	return (S5PC11X_CLOCK_POWER *)ELFIN_CLOCK_POWER_BASE;
+}
+static inline S5PC11X_LCD * S5PC11X_GetBase_LCD(void)
+{
+	return (S5PC11X_LCD *)ELFIN_LCD_BASE;
+}
+static inline S5PC11X_UART * S5PC11X_GetBase_UART(S5PC11X_UARTS_NR nr)
+{
+	return (S5PC11X_UART *)(ELFIN_UART_BASE + (nr*0x400));
+}
+static inline S5PC11X_TIMERS * S5PC11X_GetBase_TIMERS(void)
+{
+	return (S5PC11X_TIMERS *)ELFIN_TIMER_BASE;
+}
+static inline S5PC11X_WATCHDOG * S5PC11X_GetBase_WATCHDOG(void)
+{
+	return (S5PC11X_WATCHDOG *)ELFIN_WATCHDOG_BASE;
+}
+static inline S5PC11X_I2C * S5PC11X_GetBase_I2C(void)
+{
+	return (S5PC11X_I2C *)ELFIN_I2C_BASE;
+}
+static inline S5PC11X_I2S * S5PC11X_GetBase_I2S(void)
+{
+	return (S5PC11X_I2S *)ELFIN_I2S_BASE;
+}
+static inline S5PC11X_GPIO * S5PC11X_GetBase_GPIO(void)
+{
+	return (S5PC11X_GPIO *)ELFIN_GPIO_BASE;
+}
+static inline S3C2410_ADC * S3C2410_GetBase_ADC(void)
+{
+	return (S3C2410_ADC *)ELFIN_ADC_BASE;
+}
+static inline S5PC11X_SPI * S5PC11X_GetBase_SPI(void)
+{
+	return (S5PC11X_SPI *)ELFIN_SPI_BASE;
+}
+
+#else /* #ifndef __ASSEMBLY__ */
+
+/* LCD controller */
+#define LCDBGCON_OFFSET		0x5c
+
+#endif /* #ifndef __ASSEMBLY__ */
+
+#endif
+
+/* PENDING BIT */
+#define BIT_EINT0			(0x1)
+#define BIT_EINT1			(0x1<<1)
+#define BIT_EINT2			(0x1<<2)
+#define BIT_EINT3			(0x1<<3)
+#define BIT_EINT4_7			(0x1<<4)
+#define BIT_EINT8_23			(0x1<<5)
+#define BIT_BAT_FLT			(0x1<<7)
+#define BIT_TICK			(0x1<<8)
+#define BIT_WDT				(0x1<<9)
+#define BIT_TIMER0			(0x1<<10)
+#define BIT_TIMER1			(0x1<<11)
+#define BIT_TIMER2			(0x1<<12)
+#define BIT_TIMER3			(0x1<<13)
+#define BIT_TIMER4			(0x1<<14)
+#define BIT_UART2			(0x1<<15)
+#define BIT_LCD				(0x1<<16)
+#define BIT_DMA0			(0x1<<17)
+#define BIT_DMA1			(0x1<<18)
+#define BIT_DMA2			(0x1<<19)
+#define BIT_DMA3			(0x1<<20)
+#define BIT_SDI				(0x1<<21)
+#define BIT_SPI0			(0x1<<22)
+#define BIT_UART1			(0x1<<23)
+#define BIT_USBH			(0x1<<26)
+#define BIT_IIC				(0x1<<27)
+#define BIT_UART0			(0x1<<28)
+#define BIT_SPI1			(0x1<<29)
+#define BIT_RTC				(0x1<<30)
+#define BIT_ADC				(0x1<<31)
+#define BIT_ALLMSK			(0xFFFFFFFF)
+
+#endif /*__S5PC110_H__*/
diff --git a/board/samsung/gec210/Kconfig b/board/samsung/gec210/Kconfig
new file mode 100644
index 0000000..42776f3
--- /dev/null
+++ b/board/samsung/gec210/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_GEC210
+
+config SYS_BOARD
+	default "gec210"
+
+config SYS_VENDOR
+	default "samsung"
+
+config SYS_SOC
+	default "s5pc1xx"
+
+config SYS_CONFIG_NAME
+	default "gec210"
+
+endif
diff --git a/board/samsung/gec210/MAINTAINERS b/board/samsung/gec210/MAINTAINERS
new file mode 100644
index 0000000..a879714
--- /dev/null
+++ b/board/samsung/gec210/MAINTAINERS
@@ -0,0 +1,6 @@
+GEC210 BOARD
+M:	Lucifer Zhu <LuciferZhu@yeah.net>
+S:	Maintained
+F:	board/samsung/gec210/
+F:	include/configs/gec210.h
+F:	configs/gec210_defconfig
diff --git a/board/samsung/gec210/Makefile b/board/samsung/gec210/Makefile
new file mode 100644
index 0000000..ddeb488
--- /dev/null
+++ b/board/samsung/gec210/Makefile
@@ -0,0 +1,15 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2008
+# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= gec210.o
+obj-$(CONFIG_SAMSUNG_ONENAND)	+= onenand.o
+extra-y	+= lowlevel_init.o
+extra-y	+= mem_init.o
+extra-y	+= nand_cp.o
diff --git a/board/samsung/gec210/gec210.c b/board/samsung/gec210/gec210.c
new file mode 100644
index 0000000..57e38c9
--- /dev/null
+++ b/board/samsung/gec210/gec210.c
@@ -0,0 +1,112 @@
+﻿/*
+ *  Copyright (C) 2008-2009 Samsung Electronics
+ *  Minkyu Kang <mk7.kang@samsung.com>
+ *  Kyungmin Park <kyungmin.park@samsung.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <asm/arch/sromc.h>
+#include <netdev.h>
+#include <asm/mach-types.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+#ifdef CONFIG_SMC911X
+static void smc9115_pre_init(void)
+{
+	u32 smc_bw_conf, smc_bc_conf;
+
+	/* gpio configuration GPK0CON */
+	gpio_cfg_pin(S5PC100_GPIO_K00 + CONFIG_ENV_SROM_BANK, S5P_GPIO_FUNC(2));
+
+	/* Ethernet needs bus width of 16 bits */
+	smc_bw_conf = SMC_DATA16_WIDTH(CONFIG_ENV_SROM_BANK);
+	smc_bc_conf = SMC_BC_TACS(0x0) | SMC_BC_TCOS(0x4) | SMC_BC_TACC(0xe)
+			| SMC_BC_TCOH(0x1) | SMC_BC_TAH(0x4)
+			| SMC_BC_TACP(0x6) | SMC_BC_PMC(0x0);
+
+	/* Select and configure the SROMC bank */
+	s5p_config_sromc(CONFIG_ENV_SROM_BANK, smc_bw_conf, smc_bc_conf);
+}
+#endif
+
+#ifdef CONFIG_DRIVER_DM9000
+static void dm9000_pre_init(void)
+{
+	unsigned int tmp;
+
+	/* DM9000 on SROM BANK1, 16 bit */
+	SROM_BW_REG &= ~(0xf << 4);
+	SROM_BW_REG |= (0x1 << 4);
+	SROM_BC1_REG = ((0<<28)|(0<<24)|(5<<16)|(0<<12)|(0<<8)|(0<<4)|(0<<0));
+	/* Set MP01_1 as SROM_CSn[1] */
+	tmp = MP01CON_REG;
+	tmp &=~(0xf<<4);
+	tmp |=(2<<4);
+	MP01CON_REG = tmp;
+}
+#endif
+
+int board_init(void)
+{
+#ifdef CONFIG_SMC911X
+	smc9115_pre_init();
+#endif
+
+#ifdef CONFIG_DRIVER_DM9000
+	dm9000_pre_init();
+#endif
+	/* bi_arch_number has set in setup_machine(). */
+	/* gd->bd->bi_arch_number = MACH_TYPE_SMDKC110; */
+	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);
+	gd->ram_size += get_ram_size((long *)PHYS_SDRAM_2, PHYS_SDRAM_2_SIZE);
+
+	return 0;
+}
+
+int dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+
+	return 0;
+}
+
+#ifdef CONFIG_DISPLAY_BOARDINFO
+int checkboard(void)
+{
+	printf("Board:\tGEC210\n");
+	return 0;
+}
+#endif
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+
+#ifdef CONFIG_SMC911X
+	rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
+#endif
+
+#ifdef CONFIG_DRIVER_DM9000
+	rc = dm9000_initialize(bis);
+#endif
+	return rc;
+}
diff --git a/board/samsung/gec210/lowlevel_init.S b/board/samsung/gec210/lowlevel_init.S
new file mode 100644
index 0000000..46076d1
--- /dev/null
+++ b/board/samsung/gec210/lowlevel_init.S
@@ -0,0 +1,319 @@
+﻿/*
+ * Copyright (C) 2009 Samsung Electronics
+ * Kyungmin Park <kyungmin.park@samsung.com>
+ * Minkyu Kang <mk7.kang@samsung.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/power.h>
+#include <asm/arch/s5pc110.h>
+
+/*
+ * Register usages:
+ *
+ * r5 has zero always
+ */
+
+	.globl lowlevel_init
+lowlevel_init:
+	mov	r9, lr
+
+	/* r5 has always zero */
+	mov	r5, #0
+
+	ldr	r8, =S5PC110_GPIO_BASE
+
+	/* Disable Watchdog */
+	ldr	r0, =S5PC110_WATCHDOG_BASE
+	orr	r0, r0, #0x0
+	str	r5, [r0]
+
+	/* when we already run in ram, we do not need to relocate U-Boot.
+	 * and actually, memory controller must be configured before U-Boot
+	 * is running in ram.
+	 */
+	ldr	r0, =0xff000fff
+	bic	r1, pc, r0		/* r0 <- current base addr of code */
+	ldr	r2, =CONFIG_SYS_TEXT_BASE /* r1 <- original base addr in ram */
+	bic	r2, r2, r0		/* r0 <- current base addr of code */
+	cmp     r1, r2                  /* compare r0, r1                  */
+	beq     1f			/* r0 == r1 then skip sdram init   */
+
+	/* init system clock */
+	bl system_clock_init
+
+	/* Memory initialize */
+	bl mem_ctrl_asm_init
+
+1:
+	/* for UART */
+	bl uart_asm_init
+
+	/* for TZPC */
+	bl tzpc_asm_init
+
+	/* simple init for NAND */
+	bl nand_asm_init
+
+	/* Print 'K' */
+	ldr	r0, =ELFIN_UART_CONSOLE_BASE
+	ldr	r1, =0x4b4b4b4b
+	str	r1, [r0, #UTXH_OFFSET]
+
+	mov	lr, r9
+	mov	pc, lr
+
+
+/*
+ * system_clock_init: Initialize core clock and bus clock.
+ * void system_clock_init(void)
+ */
+system_clock_init:
+
+	ldr	r0, =ELFIN_CLOCK_POWER_BASE	@0xe0100000
+
+	/* Set Mux to FIN */
+	ldr	r1, =0x0
+	str	r1, [r0, #CLK_SRC0_OFFSET]
+
+	ldr	r1,	=APLL_LOCKTIME_VAL
+	str	r1,	[r0, #APLL_LOCK_OFFSET]
+
+	/* Disable PLL */
+retryloop:
+	ldr	r1, =0x0
+	str	r1, [r0, #APLL_CON0_OFFSET]
+	ldr	r1, =0x0
+	str	r1, [r0, #MPLL_CON_OFFSET]
+
+	ldr	r1, =0x0
+	str	r1, [r0, #MPLL_CON_OFFSET]
+
+	ldr   	r1, [r0, #CLK_DIV0_OFFSET]
+	ldr	r2, =CLK_DIV0_MASK
+	bic	r1, r1, r2
+
+	ldr	r2, =CLK_DIV0_VAL
+	orr	r1, r1, r2
+	str	r1, [r0, #CLK_DIV0_OFFSET]
+
+	ldr	r1, =APLL_VAL
+	str	r1, [r0, #APLL_CON0_OFFSET]
+
+	ldr	r1, =MPLL_VAL
+	str	r1, [r0, #MPLL_CON_OFFSET]
+
+	ldr	r1, =VPLL_VAL
+	str	r1, [r0, #VPLL_CON_OFFSET]
+	
+	ldr	r1, =AFC_ON
+	str	r1, [r0, #APLL_CON1_OFFSET]
+	
+	mov	r1, #0x10000
+1:	subs	r1, r1, #1
+	bne	1b
+
+	/* MPLL software workaround */
+	ldr	r1, [r0, #MPLL_CON_OFFSET]
+	orr     r1, r1, #(1<<28)
+	str	r1, [r0, #MPLL_CON_OFFSET]
+
+	mov	r1, #0x100
+1:	subs	r1, r1, #1
+	bne	1b
+
+	ldr	r1, [r0, #MPLL_CON_OFFSET]
+	and	r1, r1, #(1<<29)
+	cmp	r1, #(1<<29)
+	bne 	retryloop
+
+	/* H/W lock detect disable */
+	ldr	r1, [r0, #MPLL_CON_OFFSET]
+	bic     r1, r1, #(1<<28)
+	str	r1, [r0, #MPLL_CON_OFFSET]
+
+	ldr	r1, [r0, #CLK_SRC0_OFFSET]
+	ldr	r2, =0x10001111
+	orr	r1, r1, r2
+	str	r1, [r0, #CLK_SRC0_OFFSET]
+
+	/* CLK_DIV6 */
+	ldr	r1, [r0, #CLK_DIV6_OFFSET]
+	bic	r1, r1, #(0x7<<12)	@; ONENAND_RATIO: 0
+	str	r1, [r0, #CLK_DIV6_OFFSET]
+
+	mov	pc, lr
+
+
+/*
+ * uart_asm_init: Initialize UART in asm mode, 115200bps fixed.
+ * void uart_asm_init(void)
+ */
+uart_asm_init:
+	/* uart0 gpio setup */
+	ldr 	r0, =GPA0CON
+	ldr 	r1, [r0]
+	bic 	r1, #0xff
+	orr 	r1, #0x22
+	str 	r1, [r0]
+
+	ldr 	r0, =ELFIN_UART_CONSOLE_BASE
+
+	ldr 	r1, =0x00000003		@ No parityNo parity, No parity, 8-bit
+	str 	r1, [r0, #ULCON_OFFSET]
+
+	ldr 	r1, =0x00000305		@  PCLK, Level, Interrupt request or polling mode
+	str 	r1, [r0, #UCON_OFFSET]
+
+	ldr 	r1, =0x00000001		@ [trigger level] Tx FIFO-0 byte, Rx FIFO-32 byte,fifo en
+	str 	r1, [r0, #UFCON_OFFSET]
+
+	ldr 	r1, =0			@ disable Auto Flow Control
+	str 	r1, [r0, #UMCON_OFFSET]
+
+	/* 
+	 * baudrate=115200
+	 * DIV_VAL = (660000000 / (115200 x 16)) -1 = 34.8
+	 * UBRDIVn = 34 ( integer part of DIV_VAL )
+	 * (num of 1's in UDIVSLOTn)/16 = 0.8, (num of 1's in UDIVSLOTn) = 13, UDIVSLOT=0xDFDD
+	 */
+	ldr 	r1, =34
+	str 	r1, [r0, #UBRDIV_OFFSET]
+	ldr 	r1, =0xDFDD
+	str 	r1, [r0, #UDIVSLOT_OFFSET]
+
+	ldr 	r1, =0x0f
+	str 	r1, [r0, #UINTM_OFFSET]	@ disable all uart interrupt
+
+	/* print "O" */
+	ldr 	r1, =0x4f
+	str 	r1, [r0, #UTXH_OFFSET]
+
+	mov	pc, lr
+
+
+/*
+ * tzpc_asm_init: Initialize TZPC
+ */
+tzpc_asm_init:
+
+	ldr	r0, =ELFIN_TZPC0_BASE
+ 	mov	r1, #0x0
+ 	str	r1, [r0]
+ 	mov	r1, #0xff
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET] 	
+
+ 	ldr 	r0, =ELFIN_TZPC1_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET] 	
+
+ 	ldr	r0, =ELFIN_TZPC2_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET] 
+
+ 	ldr	r0, =ELFIN_TZPC3_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET] 	
+
+ 	mov	pc, lr
+
+
+/*
+ * Nand Interface Init for GEC210
+ */
+nand_asm_init:
+#if 0	/* own nand initial driver */
+	ldr	r0, =ELFIN_GPIO_BASE
+	/* pin CSn2 */
+	ldr	r1, [r0,#MP01CON_OFFSET]
+	bic	r1, r1, #(0xf<<8)
+	orr	r1, r1, #(0x3<<8)
+	str	r1, [r0,#MP01CON_OFFSET]
+	
+	/* pin CLE, ALE, WE, RE, RnB */
+	ldr	r1, [r0,#MP03CON_OFFSET]
+	ldr	r2, =0xFFFFF
+	bic	r1, r1, r2
+	ldr	r2, =0x22222
+	orr	r1, r1, r2
+	str	r1, [r0,#MP03CON_OFFSET]
+	
+	/* pin DATA[15:0] */
+	ldr	r1, =0x22222222
+	str	r1, [r0,#MP06CON_OFFSET]
+	
+	/*
+	 *  [1]: When page size is 2K ,5 address cycle
+	 */
+	ldr	r0, =ELFIN_NAND_BASE
+	ldr	r1, =(1<<23) | (0<<12) | (2<<8) | (0<<4) | (1<<1)
+	str	r1, [r0,#NFCONF_OFFSET]
+	
+	ldr	r1, =(0<<8) | (1<<1) | (1<<0)
+	str	r1, [r0,#NFCONT_OFFSET]
+	 
+	mov	pc, lr
+#else
+	/* Setting GPIO for NAND */
+	/* This setting is NAND initialze code at booting time in iROM. */
+
+	ldr	r0, =ELFIN_GPIO_BASE
+
+	ldr	r1, [r0, #MP01CON_OFFSET]
+	bic	r1, r1, #(0xf<<8)
+	orr	r1, r1, #(0x3<<8)
+	str	r1, [r0, #MP01CON_OFFSET]
+
+	ldr	r1, [r0, #MP01PUD_OFFSET]
+	bic	r1, r1, #(0x3<<4)
+	str	r1, [r0, #MP01PUD_OFFSET]
+
+	ldr	r1, [r0, #MP03CON_OFFSET]
+	bic	r1, r1, #0xFFFFFF
+	ldr	r2, =0x22222222
+	orr	r1, r1, r2
+	str	r1, [r0, #MP03CON_OFFSET]
+
+	ldr	r1, [r0, #MP03PUD_OFFSET]
+	ldr	r2, =0x3fff
+	bic	r1, r1, r2
+	str	r1, [r0, #MP03PUD_OFFSET]
+
+	ldr	r0, =ELFIN_NAND_BASE
+
+	ldr	r1, [r0, #NFCONF_OFFSET]
+	ldr	r2, =0x777F
+	bic	r1, r1, r2
+	ldr	r2, =NFCONF_VAL
+	orr	r1, r1, r2
+	str	r1, [r0, #NFCONF_OFFSET]
+
+	ldr	r1, [r0, #NFCONT_OFFSET]
+	ldr	r2, =0x707C7
+	bic	r1, r1, r2
+	ldr	r2, =NFCONT_VAL
+	orr	r1, r1, r2
+	str	r1, [r0, #NFCONT_OFFSET]
+
+	ldr	r1, [r0, #NFCONF_OFFSET]
+	orr	r1, r1, #0x70
+	orr	r1, r1, #0x7700
+	str     r1, [r0, #NFCONF_OFFSET]
+
+	ldr	r1, [r0, #NFCONT_OFFSET]
+	orr	r1, r1, #0x03
+	str     r1, [r0, #NFCONT_OFFSET]
+
+	mov	pc, lr
+
+#endif
+
diff --git a/board/samsung/gec210/mem_init.S b/board/samsung/gec210/mem_init.S
new file mode 100644
index 0000000..2935bfc
--- /dev/null
+++ b/board/samsung/gec210/mem_init.S
@@ -0,0 +1,380 @@
+﻿/*
+ * (C) Copyright 2018 Lucifer Zhu <LuciferZhu@yeah.net>
+ * date: 2018-5-7 21:01:25
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <config.h>
+#include <asm/arch/s5pc110.h>
+
+
+	.globl mem_ctrl_asm_init
+mem_ctrl_asm_init:
+
+	/* DMC0 Drive Strength (Setting 2X) */
+	
+	ldr	r0, =ELFIN_GPIO_BASE
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_0DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_1DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_2DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_3DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_4DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_5DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_6DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_7DRV_SR_OFFSET]
+
+	ldr	r1, =0x00002AAA
+	str	r1, [r0, #MP1_8DRV_SR_OFFSET]
+
+
+	/* DMC1 Drive Strength (Setting 2X) */
+	
+	ldr	r0, =ELFIN_GPIO_BASE
+	
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_0DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_1DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_2DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_3DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_4DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_5DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_6DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_7DRV_SR_OFFSET]
+
+	ldr	r1, =0x00002AAA
+	str	r1, [r0, #MP2_8DRV_SR_OFFSET]
+	
+	/* DMC0 initialization at single Type*/
+	ldr	r0, =APB_DMC_0_BASE
+
+	ldr	r1, =0x00101000				@PhyControl0 DLL parameter setting, manual 0x00101000
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00000086				@PhyControl1 DLL parameter setting, LPDDR/LPDDR2 Case
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00101002				@PhyControl0 DLL on
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00101003				@PhyControl0 DLL start
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+find_lock_val:
+	ldr	r1, [r0, #DMC_PHYSTATUS]		@Load Phystatus register value
+	and	r2, r1, #0x7
+	cmp	r2, #0x7				@Loop until DLL is locked
+	bne	find_lock_val
+	
+	and	r1, #0x3fc0 
+	mov	r2, r1, LSL #18
+	orr	r2, r2, #0x100000
+	orr	r2 ,r2, #0x1000	
+		
+	orr	r1, r2, #0x3				@Force Value locking
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+#if 0	/* Memory margin test 10.01.05 */
+	orr	r1, r2, #0x1				@DLL off
+	str	r1, [r0, #DMC_PHYCONTROL0]
+#endif
+	/* setting DDR2 */
+	ldr	r1, =0x0FFF2010				@ConControl auto refresh off
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r1, =DMC0_MEMCONTROL			@(2016-10-14朱相东修改) =0x00212400  MemControl BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+	str	r1, [r0, #DMC_MEMCONTROL]
+	
+	ldr	r1, =DMC0_MEMCONFIG_0			@MemConfig0 256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
+	str	r1, [r0, #DMC_MEMCONFIG0]
+
+	ldr	r1, =DMC0_MEMCONFIG_1			@MemConfig1
+	str	r1, [r0, #DMC_MEMCONFIG1]
+
+	ldr	r1, =0xFF000000				@PrechConfig
+	str	r1, [r0, #DMC_PRECHCONFIG]
+	
+	ldr	r1, =DMC0_TIMINGA_REF			@TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
+	str	r1, [r0, #DMC_TIMINGAREF]
+	
+	ldr	r1, =DMC0_TIMING_ROW			@TimingRow	for @200MHz
+	str	r1, [r0, #DMC_TIMINGROW]
+
+	ldr	r1, =DMC0_TIMING_DATA			@TimingData	CL=3
+	str	r1, [r0, #DMC_TIMINGDATA]
+	
+	ldr	r1, =DMC0_TIMING_PWR			@TimingPower
+	str	r1, [r0, #DMC_TIMINGPOWER]
+
+	ldr	r1, =0x07000000				@DirectCmd	chip0 Deselect
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00020000				@DirectCmd	chip0 EMRS2
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00030000				@DirectCmd	chip0 EMRS3
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (MEM DLL on, DQS# disable)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00000542				@DirectCmd	chip0 MRS (MEM DLL reset) CL=4, BL=4
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00000442				@DirectCmd	chip0 MRS (MEM DLL unreset)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010780				@DirectCmd	chip0 EMRS1 (OCD default)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (OCD exit)
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x07100000				@DirectCmd	chip1 Deselect
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00120000				@DirectCmd	chip1 EMRS2
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00130000				@DirectCmd	chip1 EMRS3
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00110400				@DirectCmd	chip1 EMRS1 (MEM DLL on, DQS# disable)
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00100542				@DirectCmd	chip1 MRS (MEM DLL reset) CL=4, BL=4
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00100442				@DirectCmd	chip1 MRS (MEM DLL unreset)
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00110780				@DirectCmd	chip1 EMRS1 (OCD default)
+	str	r1, [r0, #DMC_DIRECTCMD]
+		
+	ldr	r1, =0x00110400				@DirectCmd	chip1 EMRS1 (OCD exit)
+	str	r1, [r0, #DMC_DIRECTCMD]
+		
+	ldr	r1, =0x0FF02030				@ConControl	auto refresh on
+	str	r1, [r0, #DMC_CONCONTROL]
+		
+	ldr	r1, =0xFFFF00FF				@PwrdnConfig
+	str	r1, [r0, #DMC_PWRDNCONFIG]
+		
+	ldr	r1, =0x00202400				@MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+	str	r1, [r0, #DMC_MEMCONTROL]
+
+	/* DMC1 initialization */
+	ldr	r0, =APB_DMC_1_BASE
+
+	ldr	r1, =0x00101000				@Phycontrol0 DLL parameter setting
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00000086				@Phycontrol1 DLL parameter setting
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00101002				@PhyControl0 DLL on
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00101003				@PhyControl0 DLL start
+	str	r1, [r0, #DMC_PHYCONTROL0]
+find_lock_val1:
+	ldr	r1, [r0, #DMC_PHYSTATUS]		@Load Phystatus register value
+	and	r2, r1, #0x7
+	cmp	r2, #0x7				@Loop until DLL is locked
+	bne	find_lock_val1
+	
+	and	r1, #0x3fc0 
+	mov	r2, r1, LSL #18
+	orr	r2, r2, #0x100000
+	orr	r2, r2, #0x1000
+		
+	orr	r1, r2, #0x3				@Force Value locking
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+#if 0	/* Memory margin test 10.01.05 */
+	orr	r1, r2, #0x1				@DLL off
+	str	r1, [r0, #DMC_PHYCONTROL0]
+#endif
+
+	/* settinf fot DDR2 */
+	ldr	r0, =APB_DMC_1_BASE
+
+	ldr	r1, =0x0FFF2010				@auto refresh off
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r1, =DMC1_MEMCONTROL			@MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+	str	r1, [r0, #DMC_MEMCONTROL]
+
+	ldr	r1, =DMC1_MEMCONFIG_0			@MemConfig0	512MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
+	str	r1, [r0, #DMC_MEMCONFIG0]
+
+	ldr	r1, =DMC1_MEMCONFIG_1			@MemConfig1
+	str	r1, [r0, #DMC_MEMCONFIG1]
+
+	ldr	r1, =0xFF000000
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	ldr	r1, =DMC1_TIMINGA_REF			@TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4
+	str	r1, [r0, #DMC_TIMINGAREF]
+
+	ldr	r1, =DMC1_TIMING_ROW			@TimingRow	for @200MHz
+	str	r1, [r0, #DMC_TIMINGROW]
+
+	ldr	r1, =DMC1_TIMING_DATA			@TimingData	CL=3
+	str	r1, [r0, #DMC_TIMINGDATA]
+
+	ldr	r1, =DMC1_TIMING_PWR			@TimingPower
+	str	r1, [r0, #DMC_TIMINGPOWER]
+
+
+	ldr	r1, =0x07000000				@DirectCmd	chip0 Deselect
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00020000				@DirectCmd	chip0 EMRS2
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00030000				@DirectCmd	chip0 EMRS3
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (MEM DLL on, DQS# disable)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00000542				@DirectCmd	chip0 MRS (MEM DLL reset) CL=4, BL=4
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00000442				@DirectCmd	chip0 MRS (MEM DLL unreset)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010780				@DirectCmd	chip0 EMRS1 (OCD default)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (OCD exit)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x07100000				@DirectCmd	chip1 Deselect
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00120000				@DirectCmd	chip1 EMRS2
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00130000				@DirectCmd	chip1 EMRS3
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00110440				@DirectCmd	chip1 EMRS1 (MEM DLL on, DQS# disable)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00100542				@DirectCmd	chip1 MRS (MEM DLL reset) CL=4, BL=4
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00100442				@DirectCmd	chip1 MRS (MEM DLL unreset)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00110780				@DirectCmd	chip1 EMRS1 (OCD default)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00110400				@DirectCmd	chip1 EMRS1 (OCD exit)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x0FF02030				@ConControl	auto refresh on
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r1, =0xFFFF00FF				@PwrdnConfig	
+	str	r1, [r0, #DMC_PWRDNCONFIG]
+
+	ldr	r1, =DMC1_MEMCONTROL			@MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+	str	r1, [r0, #DMC_MEMCONTROL]
+	
+
+	mov	pc, lr
+
+
diff --git a/board/samsung/gec210/nand_cp.c b/board/samsung/gec210/nand_cp.c
new file mode 100644
index 0000000..f50e4cf
--- /dev/null
+++ b/board/samsung/gec210/nand_cp.c
@@ -0,0 +1,180 @@
+﻿/*
+ * $Id: nand_cp.c,v 1.1 2008/11/20 01:08:36 boyko Exp $
+ *
+ * (C) Copyright 2006 Samsung Electronics
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * You must make sure that all functions in this file are designed
+ * to load only U-Boot image.
+ *
+ * So, DO NOT USE in common read.
+ *
+ * By scsuh.
+ */
+
+/*
+ * Large block only: Small block is not supported.
+ * No ECC operation: Bit error is not corrected.
+ */
+
+#include <common.h>
+
+#if 1 //def CONFIG_S5PC11X
+//#include <asm/io.h>
+#include <linux/mtd/rawnand.h>
+//#include <regs.h>
+#include <asm/arch/s5pc110.h>
+
+#define NAND_DISABLE_CE()	(NFCONT_REG |= (1 << 1))
+#define NAND_ENABLE_CE()	(NFCONT_REG &= ~(1 << 1))
+#define NF_TRANSRnB()		do { while(!(NFSTAT_REG & (1 << 0))); } while(0)
+
+#define NAND_CONTROL_ENABLE()	(NFCONT_REG |= (1 << 0))
+
+
+static void nand_readpage (ulong col, ulong row, uchar* buf, int len)
+{
+	int i;
+
+	NAND_ENABLE_CE();
+
+	NFCMD_REG = NAND_CMD_READ0;
+
+	/* Write Column Address */
+	NFADDR_REG = (col) & 0xff;
+	NFADDR_REG = (col >> 8) & 0xff;
+
+	/* Write Row Address */
+	NFADDR_REG = (row) & 0xff;
+	NFADDR_REG = (row >> 8) & 0xff;
+	NFADDR_REG = (row >> 16) & 0xff;
+
+	NFCMD_REG = NAND_CMD_READSTART;
+
+	NF_TRANSRnB();
+
+	for (i = 0; i < len; i++) {
+		buf[i] = NFDATA8_REG;
+	}
+
+	NAND_DISABLE_CE();
+}
+
+static int nand_isbad (ulong addr)
+{
+	int page_size = 2048;
+	uchar oob[2];
+
+	if (addr == 0)
+		return 0;
+
+	nand_readpage(page_size, addr, oob, 2);
+
+	if ((oob[0] == 0xFF) && (oob[1] == 0xFF))
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * address format
+ *              17 16         9 8            0
+ * --------------------------------------------
+ * | block(12bit) | page(5bit) | offset(9bit) |
+ * --------------------------------------------
+ */
+
+static int nandll_read_page (uchar *buf, ulong addr)
+{
+	int page_size = 2048;
+
+	nand_readpage(0, addr, buf, page_size);
+
+        return 0;
+}
+
+/*
+ * Read data from NAND.
+ */
+static int nandll_read_blocks (ulong dst_addr, ulong size)
+{
+        uchar *buf = (uchar *)dst_addr;
+        int i;
+
+#if defined(CONFIG_SECURE_BOOT)
+	int skipped_page = 6;
+#else
+	int skipped_page = 0;
+#endif
+
+	uint page_shift = 11;
+
+        /* Read pages */
+        for (i = 0; i < (size>>page_shift); i++, buf+=(1<<page_shift)) {
+		if ((i & (64 - 1)) == 0) {
+			while (nand_isbad(i + skipped_page)) {
+				skipped_page += 64;
+			}
+		}
+                nandll_read_page(buf, i + skipped_page);
+        }
+        return 0;
+}
+
+int copy_uboot_to_ram (void)
+{
+	int i;
+	vu_char id;
+
+	int rv;
+
+	NAND_CONTROL_ENABLE();
+        NAND_ENABLE_CE();
+        NFCMD_REG = NAND_CMD_READID;
+        NFADDR_REG = 0x00;
+
+	/* wait for a while */
+        for (i=0; i<200; i++);
+	id = NFDATA8_REG;
+	id = NFDATA8_REG;
+
+	if (id <= 0x80)
+		return -1;	// Do not support small page (512B) any more
+
+	/* read NAND blocks */
+	rv = nandll_read_blocks(CONFIG_SYS_TEXT_BASE, COPY_BL2_SIZE);
+
+#if defined(CONFIG_SECURE_BOOT)
+	rv = Check_Signature((SecureBoot_CTX *)SECURE_BOOT_CONTEXT_ADDR,
+			(unsigned char *)CFG_PHY_UBOOT_BASE,
+			(1024*512 - 128),
+			(unsigned char *)(CFG_PHY_UBOOT_BASE + (1024*512-128)),
+			128);
+	if (rv != SB_OK)
+		while(1);
+#endif
+
+	return rv;
+}
+ 
+#endif
+
diff --git a/board/samsung/gec210/onenand.c b/board/samsung/gec210/onenand.c
new file mode 100644
index 0000000..994d91d
--- /dev/null
+++ b/board/samsung/gec210/onenand.c
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2008-2009 Samsung Electronics
+ * Kyungmin Park <kyungmin.park@samsung.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <linux/compat.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/onenand.h>
+#include <linux/mtd/samsung_onenand.h>
+
+#include <onenand_uboot.h>
+
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+
+int onenand_board_init(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+	struct s5pc100_clock *clk =
+			(struct s5pc100_clock *)samsung_get_base_clock();
+	struct samsung_onenand *onenand;
+	int value;
+
+	this->base = (void *)S5PC100_ONENAND_BASE;
+	onenand = (struct samsung_onenand *)this->base;
+
+	/* D0 Domain memory clock gating */
+	value = readl(&clk->gate_d01);
+	value &= ~(1 << 2);		/* CLK_ONENANDC */
+	value |= (1 << 2);
+	writel(value, &clk->gate_d01);
+
+	value = readl(&clk->src0);
+	value &= ~(1 << 24);		/* MUX_1nand: 0 from HCLKD0 */
+	value &= ~(1 << 20);		/* MUX_HREF: 0 from FIN_27M */
+	writel(value, &clk->src0);
+
+	value = readl(&clk->div1);
+	value &= ~(3 << 16);		/* PCLKD1_RATIO */
+	value |= (1 << 16);
+	writel(value, &clk->div1);
+
+	writel(ONENAND_MEM_RESET_COLD, &onenand->mem_reset);
+
+	while (!(readl(&onenand->int_err_stat) & RST_CMP))
+		continue;
+
+	writel(RST_CMP, &onenand->int_err_ack);
+
+	/*
+	 * Access_Clock [2:0]
+	 * 166 MHz, 134 Mhz : 3
+	 * 100 Mhz, 60 Mhz  : 2
+	 */
+	writel(0x3, &onenand->acc_clock);
+
+	writel(INT_ERR_ALL, &onenand->int_err_mask);
+	writel(1 << 0, &onenand->int_pin_en);	/* Enable */
+
+	value = readl(&onenand->int_err_mask);
+	value &= ~RDY_ACT;
+	writel(value, &onenand->int_err_mask);
+
+	s3c_onenand_init(mtd);
+
+	return 0;
+}
diff --git a/cmd/Kconfig b/cmd/Kconfig
index c033223..f2883cc 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -774,6 +774,12 @@ config CMD_NAND_TRIMFFS
 	help
 	  Allows one to skip empty pages when flashing something on a NAND.
 
+config CMD_NAND_YAFFS
+	bool "nand write.yaffs2"
+	default y
+	help
+	  Allows one to misalign write pages when flashing something on a NAND.
+
 config CMD_NAND_LOCK_UNLOCK
 	bool "nand lock/unlock"
 	help
diff --git a/cmd/nand.c b/cmd/nand.c
index a22945d..65d3da4 100644
--- a/cmd/nand.c
+++ b/cmd/nand.c
@@ -1,4 +1,4 @@
-/*
+﻿/*
  * Driver for NAND support, Rick Bronson
  * borrowed heavily from:
  * (c) 1999 Machine Vision Holdings, Inc.
@@ -387,6 +387,11 @@ static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	int dev = nand_curr_device;
 	int repeat = flag & CMD_FLAG_REPEAT;
 
+#if defined(CONFIG_S5PC110) && !defined(CONFIG_FUSED) && !defined(CONFIG_SECURE)
+	ulong checksum;
+	uint8_t *ptr;
+#endif
+
 	/* at least two arguments please */
 	if (argc < 2)
 		goto usage;
@@ -611,11 +616,23 @@ static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 				ret = nand_read_skip_bad(mtd, off, &rwsize,
 							 NULL, maxsize,
 							 (u_char *)addr);
-			else
+			else {
+#if defined(CONFIG_S5PC110) && !defined(CONFIG_FUSED) && !defined(CONFIG_SECURE)
+				if (off == 0) {
+					ptr = (u_char *)(addr + 16);
+					for(i = 16, checksum = 0; i < COPY_BL1_SIZE; i++) {
+						checksum += *ptr;
+						ptr++;
+					}
+					*((volatile u32 *)(addr + 0x8)) = checksum;
+					pr_info("BL1's checksum is calculated.\n");
+				}
+#endif
 				ret = nand_write_skip_bad(mtd, off, &rwsize,
 							  NULL, maxsize,
 							  (u_char *)addr,
 							  WITH_WR_VERIFY);
+			}
 #ifdef CONFIG_CMD_NAND_TRIMFFS
 		} else if (!strcmp(s, ".trimffs")) {
 			if (read) {
@@ -626,6 +643,16 @@ static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 						maxsize, (u_char *)addr,
 						WITH_DROP_FFS | WITH_WR_VERIFY);
 #endif
+#ifdef CONFIG_CMD_NAND_YAFFS
+		} else if (!strcmp(s, ".yaffs2")) {
+			if (read) {
+				printf("Unknown nand command suffix '%s'\n", s);
+				return 1;
+			}
+			ret = nand_write_skip_bad(mtd, off, &rwsize, NULL,
+						maxsize, (u_char *)addr,
+						WITH_YAFFS_OOB);
+#endif
 		} else if (!strcmp(s, ".oob")) {
 			/* out-of-band data */
 			mtd_oob_ops_t ops = {
@@ -803,6 +830,11 @@ static char nand_help_text[] =
 	"    'addr', skipping bad blocks and dropping any pages at the end\n"
 	"    of eraseblocks that contain only 0xFF\n"
 #endif
+#ifdef CONFIG_CMD_NAND_YAFFS
+	"nand write.yaffs2 - addr off|partition size\n"
+	"    write ‘size‘ bytes starting at offset ‘off‘ with yaffs format\n"
+	"    from memory address ‘addr‘, skipping bad blocks.\n"
+#endif
 	"nand erase[.spread] [clean] off size - erase 'size' bytes "
 	"from offset 'off'\n"
 	"    With '.spread', erase enough for given file size, otherwise,\n"
diff --git a/common/lcd.c b/common/lcd.c
index 4b3d7dc..15c2893 100644
--- a/common/lcd.c
+++ b/common/lcd.c
@@ -1,4 +1,4 @@
-/*
+﻿/*
  * Common LCD routines
  *
  * (C) Copyright 2001-2002
@@ -27,7 +27,8 @@
 #include <bmp_logo.h>
 #include <bmp_logo_data.h>
 #if (CONSOLE_COLOR_WHITE >= BMP_LOGO_OFFSET) && (LCD_BPP != LCD_COLOR16)
-#error Default Color Map overlaps with Logo Color Map
+/* #error Default Color Map overlaps with Logo Color Map */
+#warning Default Color Map overlaps with Logo Color Map
 #endif
 #endif
 
@@ -349,8 +350,11 @@ void lcd_logo_plot(int x, int y)
 	uchar *bmap = &bmp_logo_bitmap[0];
 	unsigned bpix = NBITS(panel_info.vl_bpix);
 	uchar *fb = (uchar *)(lcd_base + y * lcd_line_length + x * bpix / 8);
+#if 0
 	ushort *fb16;
-
+#else
+	uint *fb32;
+#endif
 	debug("Logo: width %d  height %d  colors %d\n",
 	      BMP_LOGO_WIDTH, BMP_LOGO_HEIGHT, BMP_LOGO_COLORS);
 
@@ -366,6 +370,7 @@ void lcd_logo_plot(int x, int y)
 		}
 	}
 	else { /* true color mode */
+		#if 0
 		u16 col16;
 		fb16 = (ushort *)fb;
 		for (i = 0; i < BMP_LOGO_HEIGHT; ++i) {
@@ -379,6 +384,21 @@ void lcd_logo_plot(int x, int y)
 			bmap += BMP_LOGO_WIDTH;
 			fb16 += panel_info.vl_col;
 		}
+		#else /* for 24bit color */
+		fb32 = (uint *)fb;
+		for (i=0; i < BMP_LOGO_HEIGHT; ++i) {
+			for (j=0; j < BMP_LOGO_WIDTH; j++) {
+				u32 color = bmp_logo_palette[(bmap[j]-BMP_LOGO_OFFSET)];
+				/* RGB-888 */
+				fb32[j] = ((color & 0x000F) << 4) |
+					    ((color & 0x00F0) << 8) |
+					    ((color & 0x0F00) << 12);
+			}
+			bmap += BMP_LOGO_WIDTH;
+			fb32 += panel_info.vl_col;
+		}
+		#endif
+
 	}
 
 	WATCHDOG_RESET();
diff --git a/configs/gec210_defconfig b/configs/gec210_defconfig
new file mode 100644
index 0000000..85f8dd7
--- /dev/null
+++ b/configs/gec210_defconfig
@@ -0,0 +1,934 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2018.01 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="s5pc1xx"
+CONFIG_SYS_VENDOR="samsung"
+CONFIG_SYS_BOARD="gec210"
+CONFIG_SYS_CONFIG_NAME="gec210"
+
+#
+# ARM architecture
+#
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_ARM_SMCCC is not set
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_THUMB_BUILD is not set
+# CONFIG_SPL_SYS_THUMB_BUILD is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK=y
+# CONFIG_ARM_CORTEX_CPU_IS_UP is not set
+CONFIG_USE_ARCH_MEMCPY=y
+# CONFIG_SPL_USE_ARCH_MEMCPY is not set
+CONFIG_USE_ARCH_MEMSET=y
+# CONFIG_SPL_USE_ARCH_MEMSET is not set
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_IMX31_PHYCORE_EET is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_TARGET_BCMNS2 is not set
+# CONFIG_ARCH_EXYNOS is not set
+CONFIG_ARCH_S5PC1XX=y
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX25 is not set
+# CONFIG_ARCH_MX7ULP is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_ARCH_QEMU is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4600 is not set
+# CONFIG_ARCH_VF610 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS1088AQDS is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_LS2081ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_POPLAR is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1088ARDB is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1021AIOT is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+# CONFIG_ARCH_ASPEED is not set
+CONFIG_SYS_MALLOC_F_LEN=0x400
+# CONFIG_TARGET_S5P_GONI is not set
+# CONFIG_TARGET_SMDKC100 is not set
+CONFIG_TARGET_GEC210=y
+CONFIG_IDENT_STRING=" for GEC210"
+# CONFIG_ARMV7_LPAE is not set
+# CONFIG_CMD_DEKBLOB is not set
+# CONFIG_CMD_HDMIDETECT is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEFAULT_DEVICE_TREE="s5pc1xx-gec210"
+CONFIG_DEBUG_UART=y
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SPL_SYS_MALLOC_F_LEN=0x400
+CONFIG_TPL_SYS_MALLOC_F_LEN=0x400
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+# CONFIG_FIT is not set
+# CONFIG_OF_BOARD_SETUP is not set
+# CONFIG_OF_SYSTEM_SETUP is not set
+# CONFIG_OF_STDOUT_VIA_ALIAS is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+CONFIG_ARCH_FIXUP_FDT_MEMORY=y
+
+#
+# API
+#
+# CONFIG_API is not set
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_RECORD_COUNT=30
+CONFIG_SPL_BOOTSTAGE_RECORD_COUNT=5
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=0x1000
+
+#
+# Boot media
+#
+CONFIG_NAND_BOOT=y
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+CONFIG_SD_BOOT=y
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="root=/dev/mtdblock4 rootfstype=yaffs console=ttySAC0,115200n8 mem=512M mtdparts=s5p-nand:1m(boot),5m@0x100000(recovery),5m@0x600000(kernel),3m@0xb00000(ramdisk),-(rootfs)"
+# CONFIG_USE_BOOTCOMMAND is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+CONFIG_LOGLEVEL=8
+CONFIG_SPL_LOGLEVEL=8
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+CONFIG_CONSOLE_MUX=y
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+
+#
+# Logging
+#
+# CONFIG_LOG is not set
+# CONFIG_SPL_LOG is not set
+CONFIG_DEFAULT_FDT_FILE=""
+# CONFIG_VERSION_VARIABLE is not set
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_DISPLAY_BOARDINFO=y
+
+#
+# Start-up hooks
+#
+# CONFIG_ARCH_EARLY_INIT_R is not set
+# CONFIG_ARCH_MISC_INIT is not set
+# CONFIG_BOARD_EARLY_INIT_F is not set
+
+#
+# Security support
+#
+CONFIG_HASH=y
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="GEC210 # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+# CONFIG_CMD_CONFIG is not set
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+# CONFIG_CMD_BOOTMENU is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_FDT=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+# CONFIG_CMD_IMI is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_POWEROFF is not set
+# CONFIG_CMD_THOR_DOWNLOAD is not set
+# CONFIG_CMD_ZBOOT is not set
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+# CONFIG_CMD_ENV_CALLBACK is not set
+# CONFIG_CMD_ENV_FLAGS is not set
+
+#
+# Memory commands
+#
+CONFIG_CMD_CRC32=y
+# CONFIG_CRC32_VERIFY is not set
+# CONFIG_CMD_EEPROM is not set
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MD5SUM is not set
+# CONFIG_CMD_MEMINFO is not set
+CONFIG_CMD_MEMORY=y
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_SHA1SUM is not set
+# CONFIG_CMD_STRINGS is not set
+
+#
+# Compression commands
+#
+# CONFIG_CMD_LZMADEC is not set
+# CONFIG_CMD_UNZIP is not set
+# CONFIG_CMD_ZIP is not set
+
+#
+# Device access commands
+#
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_CLK is not set
+# CONFIG_CMD_DEMO is not set
+# CONFIG_CMD_DFU is not set
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FDC is not set
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_FPGAD is not set
+# CONFIG_CMD_FUSE is not set
+# CONFIG_CMD_GPIO is not set
+# CONFIG_CMD_GPT is not set
+# CONFIG_RANDOM_UUID is not set
+# CONFIG_CMD_IDE is not set
+# CONFIG_CMD_IO is not set
+# CONFIG_CMD_IOTRACE is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+# CONFIG_CMD_MMC is not set
+CONFIG_CMD_NAND=y
+# CONFIG_CMD_NAND_TRIMFFS is not set
+CONFIG_CMD_NAND_YAFFS=y
+# CONFIG_CMD_NAND_LOCK_UNLOCK is not set
+# CONFIG_CMD_NAND_TORTURE is not set
+# CONFIG_CMD_MMC_SPI is not set
+# CONFIG_CMD_ONENAND is not set
+# CONFIG_CMD_PART is not set
+# CONFIG_CMD_PCI is not set
+# CONFIG_CMD_PCMCIA is not set
+# CONFIG_CMD_READ is not set
+# CONFIG_CMD_SATA is not set
+# CONFIG_CMD_SAVES is not set
+# CONFIG_CMD_SDRAM is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SF_TEST is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_TSI148 is not set
+# CONFIG_CMD_UNIVERSE is not set
+# CONFIG_CMD_USB is not set
+# CONFIG_CMD_USB_SDP is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+# CONFIG_CMD_SETEXPR is not set
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+# CONFIG_CMD_DHCP is not set
+# CONFIG_CMD_PXE is not set
+CONFIG_CMD_NFS=y
+# CONFIG_CMD_MII is not set
+# CONFIG_CMD_PING is not set
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+# CONFIG_CMD_ETHSW is not set
+
+#
+# Misc commands
+#
+# CONFIG_CMD_BMP is not set
+# CONFIG_CMD_BSP is not set
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_DISPLAY is not set
+# CONFIG_CMD_LED is not set
+# CONFIG_CMD_DATE is not set
+# CONFIG_CMD_TIME is not set
+# CONFIG_CMD_GETTIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+# CONFIG_CMD_TERMINAL is not set
+# CONFIG_CMD_UUID is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+# CONFIG_CMD_AES is not set
+# CONFIG_CMD_BLOB is not set
+# CONFIG_CMD_HASH is not set
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_BTRFS is not set
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_FS_UUID is not set
+# CONFIG_CMD_JFFS2 is not set
+CONFIG_CMD_MTDPARTS=y
+CONFIG_MTDIDS_DEFAULT="nand0=s5p-nand"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=s5p-nand:1m(boot),5m@0x100000(recovery),5m@0x600000(kernel),3m@0xb00000(ramdisk),-(rootfs)"
+# CONFIG_CMD_MTDPARTS_SPREAD is not set
+# CONFIG_CMD_REISER is not set
+# CONFIG_CMD_SCSI is not set
+# CONFIG_CMD_ZFS is not set
+
+#
+# Debug commands
+#
+# CONFIG_CMD_BEDBUG is not set
+# CONFIG_CMD_DIAG is not set
+# CONFIG_CMD_KGDB is not set
+# CONFIG_CMD_LOG is not set
+# CONFIG_CMD_TRACE is not set
+# CONFIG_CMD_UBI is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITIONS=y
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_DOS_PARTITION is not set
+# CONFIG_ISO_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_PARTITION_UUIDS is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+CONFIG_DTC=y
+
+#
+# Device Tree Control
+#
+CONFIG_OF_CONTROL=y
+# CONFIG_OF_BOARD_FIXUP is not set
+# CONFIG_OF_LIVE is not set
+CONFIG_OF_SEPARATE=y
+# CONFIG_OF_EMBED is not set
+# CONFIG_OF_BOARD is not set
+# CONFIG_MULTI_DTB_FIT is not set
+CONFIG_MKIMAGE_DTC_PATH="dtc"
+
+#
+# Environment
+#
+# CONFIG_ENV_IS_NOWHERE is not set
+# CONFIG_ENV_IS_IN_EEPROM is not set
+# CONFIG_ENV_IS_IN_FAT is not set
+# CONFIG_ENV_IS_IN_FLASH is not set
+# CONFIG_ENV_IS_IN_MMC is not set
+CONFIG_ENV_IS_IN_NAND=y
+# CONFIG_ENV_IS_IN_NVRAM is not set
+# CONFIG_ENV_IS_IN_ONENAND is not set
+# CONFIG_ENV_IS_IN_REMOTE is not set
+# CONFIG_ENV_IS_IN_SPI_FLASH is not set
+# CONFIG_ENV_IS_IN_UBI is not set
+CONFIG_NET=y
+CONFIG_NET_RANDOM_ETHADDR=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_DEVRES is not set
+CONFIG_SIMPLE_BUS=y
+CONFIG_OF_TRANSLATE=y
+CONFIG_DM_DEV_READ_INLINE=y
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_SARADC_ROCKCHIP is not set
+# CONFIG_SATA is not set
+# CONFIG_SCSI_AHCI is not set
+
+#
+# SATA/SCSI device support
+#
+# CONFIG_DWC_AHSATA is not set
+# CONFIG_FSL_SATA is not set
+# CONFIG_MVSATA_IDE is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIL3114 is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+# CONFIG_IDE is not set
+
+#
+# Boot count support
+#
+# CONFIG_BOOTCOUNT is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+# CONFIG_SYS_FSL_SEC_BE is not set
+# CONFIG_SYS_FSL_SEC_LE is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_ALTERA is not set
+# CONFIG_FPGA_SOCFPGA is not set
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+CONFIG_DM_GPIO=y
+# CONFIG_ALTERA_PIO is not set
+# CONFIG_DWAPB_GPIO is not set
+# CONFIG_AT91_GPIO is not set
+# CONFIG_ATMEL_PIO4 is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_INTEL_ICH6_GPIO is not set
+# CONFIG_IMX_RGPIO2P is not set
+# CONFIG_HSDK_CREG_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_MSM_GPIO is not set
+# CONFIG_CMD_PCA953X is not set
+# CONFIG_PCF8575_GPIO is not set
+# CONFIG_ROCKCHIP_GPIO is not set
+# CONFIG_CMD_TCA642X is not set
+# CONFIG_TEGRA_GPIO is not set
+# CONFIG_TEGRA186_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+# CONFIG_DM_74X164 is not set
+# CONFIG_DM_PCA953X is not set
+# CONFIG_MPC85XX_GPIO is not set
+
+#
+# I2C support
+#
+CONFIG_DM_I2C=y
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_I2C_SET_DEFAULT_BUS_NUM is not set
+# CONFIG_DM_I2C_GPIO is not set
+# CONFIG_SYS_I2C_FSL is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_SYS_I2C_INTEL is not set
+# CONFIG_SYS_I2C_IMX_LPI2C is not set
+# CONFIG_SYS_I2C_ROCKCHIP is not set
+# CONFIG_SYS_I2C_MVTWSI is not set
+# CONFIG_I2C_MUX is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+# CONFIG_LED_STATUS is not set
+
+#
+# Mailbox Controller Support
+#
+# CONFIG_DM_MAILBOX is not set
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_DS4510 is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_MMC is not set
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+# CONFIG_MTD_NOR_FLASH is not set
+CONFIG_NAND=y
+# CONFIG_NAND_DENALI_DT is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+# CONFIG_NAND_ZYNQ is not set
+CONFIG_NAND_S5P=y
+CONFIG_S5P_NAND_HWECC=y
+CONFIG_NAND_BL1_8BIT_ECC=y
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_BITBANGMII is not set
+# CONFIG_MV88E6352_SWITCH is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_DM_ETH is not set
+CONFIG_NETDEVICES=y
+# CONFIG_PHY_GIGE is not set
+# CONFIG_BCM_SF2_ETH is not set
+# CONFIG_E1000 is not set
+# CONFIG_ETH_DESIGNWARE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_FTMAC100 is not set
+# CONFIG_RGMII is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_RTL8169 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SUN7I_GMAC is not set
+# CONFIG_PCI is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_PHY is not set
+# CONFIG_SPL_PHY is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_POWER_DOMAIN is not set
+# CONFIG_DM_PMIC is not set
+# CONFIG_PMIC_AS3722 is not set
+# CONFIG_POWER_MC34VR500 is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_PWM_SANDBOX is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+# CONFIG_DM_RESET is not set
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+# CONFIG_RTC_S35392A is not set
+# CONFIG_SCSI is not set
+
+#
+# Serial drivers
+#
+CONFIG_BAUDRATE=115200
+CONFIG_REQUIRE_SERIAL_CONSOLE=y
+CONFIG_SERIAL_PRESENT=y
+CONFIG_SPL_SERIAL_PRESENT=y
+CONFIG_DM_SERIAL=y
+# CONFIG_SERIAL_RX_BUFFER is not set
+# CONFIG_SPL_DM_SERIAL is not set
+# CONFIG_TPL_DM_SERIAL is not set
+# CONFIG_DEBUG_UART_ALTERA_JTAGUART is not set
+# CONFIG_DEBUG_UART_ALTERA_UART is not set
+# CONFIG_DEBUG_UART_ATMEL is not set
+# CONFIG_DEBUG_UART_NS16550 is not set
+CONFIG_DEBUG_UART_S5P=y
+# CONFIG_DEBUG_UART_UARTLITE is not set
+# CONFIG_DEBUG_UART_ARM_DCC is not set
+# CONFIG_DEBUG_MVEBU_A3700_UART is not set
+# CONFIG_DEBUG_UART_ZYNQ is not set
+# CONFIG_DEBUG_UART_PL010 is not set
+# CONFIG_DEBUG_UART_PL011 is not set
+# CONFIG_DEBUG_UART_OMAP is not set
+CONFIG_DEBUG_UART_BASE=0XE2900000
+CONFIG_DEBUG_UART_CLOCK=66000000
+CONFIG_DEBUG_UART_SHIFT=0
+# CONFIG_DEBUG_UART_BOARD_INIT is not set
+# CONFIG_DEBUG_UART_ANNOUNCE is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ALTERA_JTAG_UART is not set
+# CONFIG_ALTERA_UART is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_NULLDEV_SERIAL is not set
+# CONFIG_SYS_NS16550 is not set
+# CONFIG_MSM_SERIAL is not set
+# CONFIG_PXA_SERIAL is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_DM_SPI is not set
+# CONFIG_SOFT_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_ATCSPI200_SPI is not set
+# CONFIG_TI_QSPI is not set
+# CONFIG_OMAP3_SPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_SYSRESET_SYSCON is not set
+# CONFIG_SYSRESET_WATCHDOG is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+# CONFIG_USB is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+CONFIG_SYS_WHITE_ON_BLACK=y
+# CONFIG_NO_FB_CLEAR is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_I2C_EDID is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_TEGRA20 is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_VIDEO is not set
+CONFIG_CONSOLE_SCROLL_LINES=1
+CONFIG_LCD=y
+# CONFIG_VIDEO_SIMPLE is not set
+# CONFIG_VIDEO_DT_SIMPLEFB is not set
+CONFIG_S5P_FB=y
+CONFIG_LCD_AT070TN90=y
+
+#
+# Watchdog Timer Support
+#
+# CONFIG_BCM2835_WDT is not set
+# CONFIG_ULP_WATCHDOG is not set
+# CONFIG_WDT is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+# CONFIG_FS_BTRFS is not set
+# CONFIG_FS_CBFS is not set
+# CONFIG_FS_FAT is not set
+# CONFIG_FS_JFFS2 is not set
+# CONFIG_FS_CRAMFS is not set
+# CONFIG_YAFFS2 is not set
+
+#
+# Library routines
+#
+# CONFIG_BCH is not set
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+# CONFIG_PANIC_HANG is not set
+CONFIG_REGEX=y
+CONFIG_LIB_RAND=y
+# CONFIG_SPL_TINY_MEMSET is not set
+# CONFIG_TPL_TINY_MEMSET is not set
+# CONFIG_BITREVERSE is not set
+# CONFIG_CMD_DHRYSTONE is not set
+
+#
+# Security support
+#
+# CONFIG_AES is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_LZMA is not set
+# CONFIG_LZO is not set
+# CONFIG_SPL_LZO is not set
+# CONFIG_SPL_GZIP is not set
+# CONFIG_ERRNO_STR is not set
+CONFIG_OF_LIBFDT=y
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+# CONFIG_FDT_FIXUP_PARTITIONS is not set
+
+#
+# System tables
+#
+# CONFIG_EFI_LOADER is not set
+# CONFIG_UNIT_TEST is not set
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 78a39ab..077fc5f 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -160,6 +160,24 @@ config NAND_ZYNQ_USE_BOOTLOADER1_TIMINGS
 	  This flag prevent U-boot reconfigure NAND flash controller and reuse
 	  the NAND timing from 1st stage bootloader.
 
+config NAND_S5P
+	bool "Support for Samsung S5PV210 Nand controller"
+	imply CMD_NAND
+	help
+	  This enables Nand driver support for Nand flash controller
+	   on Samsung S5P1XX SoC.
+
+config S5P_NAND_HWECC
+	bool "Enable use of S5P1XX nand flash controller's hardware ecc"
+	depends on NAND_S5P
+
+config NAND_BL1_8BIT_ECC
+	bool "Enable write bootloader stage 1 in nand flash with 8-bit ecc"
+	depends on NAND_S5P
+	help
+	  Soc s5pc11x's BL0 require BL1 which located in block 0 on nand to carry
+	   with 8-bit ecc, otherwise it will be failed when boot the BL1 in nand.
+
 comment "Generic NAND options"
 
 # Enhance depends when converting drivers to Kconfig which use this config
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 9f7d9d6..43efb21 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -66,6 +66,7 @@ obj-$(CONFIG_NAND_OMAP_ELM) += omap_elm.o
 obj-$(CONFIG_NAND_PLAT) += nand_plat.o
 obj-$(CONFIG_NAND_SUNXI) += sunxi_nand.o
 obj-$(CONFIG_NAND_ZYNQ) += zynq_nand.o
+obj-$(CONFIG_NAND_S5P) += s5p_nand.o
 
 else  # minimal SPL drivers
 
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index eb9f121..5383cd5 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -1,4 +1,4 @@
-/*
+﻿/*
  *  Overview:
  *   This is the generic MTD driver for NAND flash devices. It should be
  *   capable of working with almost all NAND chips currently available.
@@ -353,6 +353,11 @@ static int nand_block_bad(struct mtd_info *mtd, loff_t ofs)
 		ofs += mtd->erasesize - mtd->writesize;
 
 	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
+	
+#if defined(CONFIG_NAND_BL1_8BIT_ECC) && defined(CONFIG_S5PC110)
+	if (page < CFG_NAND_PAGES_IN_BLOCK)
+		return 0;
+#endif
 
 	do {
 		if (chip->options & NAND_BUSWIDTH_16) {
@@ -1677,6 +1682,9 @@ static int nand_setup_read_retry(struct mtd_info *mtd, int retry_mode)
 	return chip->setup_read_retry(mtd, retry_mode);
 }
 
+extern int s3c_nand_read_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf);
+
 /**
  * nand_do_read_ops - [INTERN] Read data with ECC
  * @mtd: MTD device structure
@@ -1744,18 +1752,26 @@ read_retry:
 			 * Now read the page into the buffer.  Absent an error,
 			 * the read methods return max bitflips per ecc step.
 			 */
-			if (unlikely(ops->mode == MTD_OPS_RAW))
-				ret = chip->ecc.read_page_raw(mtd, chip, bufpoi,
-							      oob_required,
-							      page);
-			else if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&
-				 !oob)
-				ret = chip->ecc.read_subpage(mtd, chip,
-							col, bytes, bufpoi,
-							page);
-			else
-				ret = chip->ecc.read_page(mtd, chip, bufpoi,
-							  oob_required, page);
+#if defined(CONFIG_NAND_BL1_8BIT_ECC) && defined(CONFIG_S5PC110)
+			if (page < CFG_NAND_PAGES_IN_BLOCK) {
+				ret = s3c_nand_read_page_8bit(mtd, chip, bufpoi);
+			} else
+#endif
+			{
+				if (unlikely(ops->mode == MTD_OPS_RAW))
+					ret = chip->ecc.read_page_raw(mtd, chip, bufpoi,
+								      oob_required,
+								      page);
+				else if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&
+					 !oob)
+					ret = chip->ecc.read_subpage(mtd, chip,
+								col, bytes, bufpoi,
+								page);
+				else
+					ret = chip->ecc.read_page(mtd, chip, bufpoi,
+								  oob_required, page);
+			}
+
 			if (ret < 0) {
 				if (use_bufpoi)
 					/* Invalidate page cache */
@@ -2404,6 +2420,9 @@ static int nand_write_page_syndrome(struct mtd_info *mtd,
 
 	return 0;
 }
+				    
+extern int s3c_nand_write_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+			      const uint8_t *buf);
 
 /**
  * nand_write_page - [REPLACEABLE] write one page
@@ -2431,15 +2450,23 @@ static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 	if (nand_standard_page_accessors(&chip->ecc))
 		chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
 
-	if (unlikely(raw))
-		status = chip->ecc.write_page_raw(mtd, chip, buf,
-						  oob_required, page);
-	else if (subpage)
-		status = chip->ecc.write_subpage(mtd, chip, offset, data_len,
-						 buf, oob_required, page);
-	else
-		status = chip->ecc.write_page(mtd, chip, buf, oob_required,
-					      page);
+#if defined(CONFIG_NAND_BL1_8BIT_ECC) && defined(CONFIG_S5PC110)
+	if (page < CFG_NAND_PAGES_IN_BLOCK) {
+		memset(chip->oob_poi, 0xff, mtd->oobsize);
+		status = s3c_nand_write_page_8bit(mtd, chip, buf);
+	} else
+#endif
+	{
+		if (unlikely(raw))
+			status = chip->ecc.write_page_raw(mtd, chip, buf,
+							  oob_required, page);
+		else if (subpage)
+			status = chip->ecc.write_subpage(mtd, chip, offset, data_len,
+							 buf, oob_required, page);
+		else
+			status = chip->ecc.write_page(mtd, chip, buf, oob_required,
+						      page);
+	}
 
 	if (status < 0)
 		return status;
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index 4009d64..af83901 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -1,4 +1,4 @@
-/*
+﻿/*
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
  *
  * This program is free software; you can redistribute it and/or modify
@@ -49,9 +49,11 @@ struct nand_flash_dev nand_flash_ids[] = {
 	{"TC58NVG2S0H 4G 3.3V 8-bit",
 		{ .id = {0x98, 0xdc, 0x90, 0x26, 0x76, 0x16, 0x08, 0x00} },
 		  SZ_4K, SZ_512, SZ_256K, 0, 8, 256, NAND_ECC_INFO(8, SZ_512) },
+#if 0	/* ignore this incompatible NAND chips */
 	{"TC58NVG3S0F 8G 3.3V 8-bit",
 		{ .id = {0x98, 0xd3, 0x90, 0x26, 0x76, 0x15, 0x02, 0x08} },
 		  SZ_4K, SZ_1K, SZ_256K, 0, 8, 232, NAND_ECC_INFO(4, SZ_512) },
+#endif
 	{"TC58NVG5D2 32G 3.3V 8-bit",
 		{ .id = {0x98, 0xd7, 0x94, 0x32, 0x76, 0x56, 0x09, 0x00} },
 		  SZ_8K, SZ_4K, SZ_1M, 0, 8, 640, NAND_ECC_INFO(40, SZ_1K) },
diff --git a/drivers/mtd/nand/nand_util.c b/drivers/mtd/nand/nand_util.c
index 9c8a373..1e94f23 100644
--- a/drivers/mtd/nand/nand_util.c
+++ b/drivers/mtd/nand/nand_util.c
@@ -1,4 +1,4 @@
-/*
+﻿/*
  * drivers/mtd/nand/nand_util.c
  *
  * Copyright (C) 2006 by Weiss-Electronic GmbH.
@@ -581,7 +581,22 @@ int nand_write_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
 	if (actual)
 		*actual = 0;
 
-	blocksize = mtd->erasesize;
+#ifdef CONFIG_CMD_NAND_YAFFS
+	if (flags & WITH_YAFFS_OOB) {
+		if (flags & ~WITH_YAFFS_OOB)
+			return -EINVAL;
+
+		int pages;
+		pages = mtd->erasesize / mtd->writesize;
+		blocksize = (pages * mtd->oobsize) + mtd->erasesize;
+		if (*length % (mtd->writesize + mtd->oobsize)) {
+			printf ("Attempt to write incomplete page"
+				" in yaffs mode\n");
+			return -EINVAL;
+		}
+	} else
+#endif
+		blocksize = mtd->erasesize;
 
 	/*
 	 * nand_write() handles unaligned, partial page writes.
@@ -617,7 +632,7 @@ int nand_write_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
 		return -EFBIG;
 	}
 
-	if (!need_skip && !(flags & WITH_DROP_FFS)) {
+	if (!need_skip && !(flags & WITH_DROP_FFS) && !(flags & WITH_YAFFS_OOB)) {
 		rval = nand_write(mtd, offset, length, buffer);
 
 		if ((flags & WITH_WR_VERIFY) && !rval)
@@ -650,22 +665,52 @@ int nand_write_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
 		else
 			write_size = blocksize - block_offset;
 
-		truncated_write_size = write_size;
+#ifdef CONFIG_CMD_NAND_YAFFS
+		if (flags & WITH_YAFFS_OOB) {
+			int page, pages;
+			size_t pagesize = mtd->writesize;
+			size_t pagesize_oob = pagesize + mtd->oobsize;
+			struct mtd_oob_ops ops;
+
+			ops.len = pagesize;
+			ops.ooblen = mtd->oobsize;
+			ops.mode = MTD_OPS_AUTO_OOB;
+			ops.ooboffs = 0;
+
+			pages = write_size / pagesize_oob;
+			for (page = 0; page < pages; page++) {
+				WATCHDOG_RESET();
+
+				ops.datbuf = p_buffer;
+				ops.oobbuf = ops.datbuf + pagesize;
+
+				rval = mtd->_write_oob(mtd, offset, &ops);
+				if (rval != 0)
+					break;
+
+				offset += pagesize;
+				p_buffer += pagesize_oob;
+			}
+		} else
+#endif
+		{
+			truncated_write_size = write_size;
 #ifdef CONFIG_CMD_NAND_TRIMFFS
-		if (flags & WITH_DROP_FFS)
-			truncated_write_size = drop_ffs(mtd, p_buffer,
-					&write_size);
+			if (flags & WITH_DROP_FFS)
+				truncated_write_size = drop_ffs(mtd, p_buffer,
+						&write_size);
 #endif
 
-		rval = nand_write(mtd, offset, &truncated_write_size,
-				p_buffer);
+			rval = nand_write(mtd, offset, &truncated_write_size,
+					p_buffer);
 
-		if ((flags & WITH_WR_VERIFY) && !rval)
-			rval = nand_verify(mtd, offset,
-				truncated_write_size, p_buffer);
+			if ((flags & WITH_WR_VERIFY) && !rval)
+				rval = nand_verify(mtd, offset,
+					truncated_write_size, p_buffer);
 
-		offset += write_size;
-		p_buffer += write_size;
+			offset += write_size;
+			p_buffer += write_size;
+		}
 
 		if (rval != 0) {
 			printf("NAND write to offset %llx failed %d\n",
diff --git a/drivers/mtd/nand/s5p_nand.c b/drivers/mtd/nand/s5p_nand.c
new file mode 100644
index 0000000..7374d45
--- /dev/null
+++ b/drivers/mtd/nand/s5p_nand.c
@@ -0,0 +1,1051 @@
+﻿/*
+ * (C) Copyright 2006 DENX Software Engineering
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include <nand.h>
+#include <asm/arch/s5pc110.h>
+
+#include <asm/io.h>
+#include <errno.h>
+
+/* Nand flash definition values by jsgood */
+#define S3C_NAND_TYPE_UNKNOWN	0x0
+#define S3C_NAND_TYPE_SLC	0x1
+#define S3C_NAND_TYPE_MLC	0x2
+#undef	S3C_NAND_DEBUG
+
+/* Nand flash global values by jsgood */
+int cur_ecc_mode = 0;
+int nand_type = S3C_NAND_TYPE_UNKNOWN;
+
+#if defined(CONFIG_S5P_NAND_HWECC)
+/* Nand flash oob definition for SLC 512b page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_16 = {
+	.eccbytes = 4,
+	.eccpos = {1, 2, 3, 4},
+	.oobfree = {
+		{.offset = 6,
+		 . length = 10}}
+};
+
+/* Nand flash oob definition for SLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_64 = {
+	.eccbytes = 16,
+	.eccpos = {40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 38}}
+};
+ 
+/* Nand flash oob definition for MLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_mlc_64 = {
+	.eccbytes = 32,
+	.eccpos = {
+		   32, 33, 34, 35, 36, 37, 38, 39,
+		   40, 41, 42, 43, 44, 45, 46, 47,
+ 		   48, 49, 50, 51, 52, 53, 54, 55,
+   		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 28}}
+};
+
+#if 0
+/* Nand flash oob definition for 4Kb page size with 8_bit ECC */
+static struct nand_ecclayout s3c_nand_oob_128 = {
+        .eccbytes = 104,
+        .eccpos = {
+                   24, 25, 26, 27, 28, 29, 30, 31,
+                   32, 33, 34, 35, 36, 37, 38, 39,
+                   40, 41, 42, 43, 44, 45, 46, 47,
+                   48, 49, 50, 51, 52, 53, 54, 55,
+                   56, 57, 58, 59, 60, 61, 62, 63,
+                   64, 65, 66, 67, 68, 69, 70, 71,
+                   72, 73, 74, 75, 76, 77, 78, 79,
+                   80, 81, 82, 83, 84, 85, 86, 87,
+                   88, 89, 90, 91, 92, 93, 94, 95,
+                   96, 97, 98, 99, 100, 101, 102, 103,
+                   104, 105, 106, 107, 108, 109, 110, 111,
+                   112, 113, 114, 115, 116, 117, 118, 119,
+                   120, 121, 122, 123, 124, 125, 126, 127},
+        .oobfree = {
+                {.offset = 2,
+                 .length = 22}}
+};
+#endif
+#endif
+
+#if defined(S3C_NAND_DEBUG)
+/*
+ * Function to print out oob buffer for debugging
+ * Written by jsgood
+ */
+static void print_oob(const char *header, struct mtd_info *mtd)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	printk("%s:\t", header);
+
+	for(i = 0; i < 64; i++)
+		printk("%02x ", chip->oob_poi[i]);
+
+	printk("\n");
+}
+#endif
+
+/*
+ * Hardware specific access to control-lines function
+ * Written by jsgood
+ */
+static void s3c_nand_hwcontrol(struct mtd_info *mtd, int dat, unsigned int ctrl)
+{
+	unsigned int cur;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_NCE) {
+			if (dat != NAND_CMD_NONE) {
+				cur = readl(NFCONT);
+				/* Forced Enable CS */
+				cur &= ~NFCONT_CS;
+
+				writel(cur, NFCONT);
+			}
+		} else {
+			cur = readl(NFCONT);
+			/* Forced Enable CS */
+			cur &= ~NFCONT_CS;
+
+			writel(cur, NFCONT);
+		}
+	}
+
+	if (dat != NAND_CMD_NONE) {
+		if (ctrl & NAND_CLE)
+			writeb(dat, NFCMMD);
+		else if (ctrl & NAND_ALE)
+			writeb(dat, NFADDR);
+	}
+}
+
+/*
+ * Function for checking device ready pin
+ * Written by jsgood
+ */
+static int s3c_nand_device_ready(struct mtd_info *mtdinfo)
+{
+	while (!(readl(NFSTAT) & NFSTAT_RnB)) {}
+	return 1;
+}
+
+#if defined(CONFIG_S5P_NAND_HWECC)
+
+/*
+ * Function for checking ECCEncDone in NFSTAT
+ * Written by jsgood
+ */
+static void s3c_nand_wait_enc(void)
+{
+	while (!(readl(NFECCSTAT) & NFSTAT_ECCENCDONE)) {}
+}
+
+/*
+ * Function for checking ECCDecDone in NFSTAT
+ * Written by jsgood
+ */
+static void s3c_nand_wait_dec(void)
+{
+	while (!(readl(NFECCSTAT) & NFSTAT_ECCDECDONE)) {}
+}
+
+/*
+ * Function for checking ECC Busy
+ * Written by jsgood
+ */
+static void s3c_nand_wait_ecc_busy(void)
+{
+	while (readl(NFECCSTAT) & NFESTAT0_ECCBUSY) {}
+}
+
+/*
+ * This function is called before encoding ecc codes to ready ecc engine.
+ * Written by jsgood
+ */
+static void s3c_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	u_long nfcont, nfconf;
+
+	cur_ecc_mode = mode;
+
+	nfconf = readl(NFCONF);
+
+ 	if (nand_type == S3C_NAND_TYPE_SLC)
+		nfconf &= ~NFCONF_ECC_MLC;	/* SLC */
+	else
+		nfconf |= NFCONF_ECC_MLC;	/* MLC */
+
+	writel(nfconf, NFCONF);
+
+	/* Initialize & unlock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_INITMECC;
+	nfcont &= ~NFCONT_MECCLOCK;
+
+	if (nand_type == S3C_NAND_TYPE_MLC) {
+		if (mode == NAND_ECC_WRITE)
+			nfcont |= NFCONT_ECC_ENC;
+		else if (mode == NAND_ECC_READ)
+			nfcont &= ~NFCONT_ECC_ENC;
+	}
+
+	writel(nfcont, NFCONT);
+}
+
+/*
+ * This function is called immediately after encoding ecc codes.
+ * This function returns encoded ecc codes.
+ * Written by jsgood
+ */
+static int s3c_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	u_long nfcont, nfmecc0, nfmecc1;
+
+	/* Lock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_MECCLOCK;
+	writel(nfcont, NFCONT);
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		nfmecc0 = readl(NFMECC0);
+
+		ecc_code[0] = nfmecc0 & 0xff;
+		ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+		ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+		ecc_code[3] = (nfmecc0 >> 24) & 0xff;
+	} else {
+		if (cur_ecc_mode == NAND_ECC_READ)
+			s3c_nand_wait_dec();
+		else {
+			s3c_nand_wait_enc();
+
+			nfmecc0 = readl(NFMECC0);
+			nfmecc1 = readl(NFMECC1);
+
+			ecc_code[0] = nfmecc0 & 0xff;
+			ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+			ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+			ecc_code[3] = (nfmecc0 >> 24) & 0xff;
+			ecc_code[4] = nfmecc1 & 0xff;
+			ecc_code[5] = (nfmecc1 >> 8) & 0xff;
+			ecc_code[6] = (nfmecc1 >> 16) & 0xff;
+			ecc_code[7] = (nfmecc1 >> 24) & 0xff;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * This function determines whether read data is good or not.
+ * If SLC, must write ecc codes to controller before reading status bit.
+ * If MLC, status bit is already set, so only reading is needed.
+ * If status bit is good, return 0.
+ * If correctable errors occured, do that.
+ * If uncorrectable errors occured, return -1.
+ * Written by jsgood
+ */
+static int s3c_nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret = -1;
+	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;
+	u_char err_type;
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		/* SLC: Write ecc to compare */
+		nfmeccdata0 = (read_ecc[1] << 16) | read_ecc[0];
+		nfmeccdata1 = (read_ecc[3] << 16) | read_ecc[2];
+		writel(nfmeccdata0, NFMECCDATA0);
+		writel(nfmeccdata1, NFMECCDATA1);
+
+		/* Read ecc status */
+		nfestat0 = readl(NFESTAT0);
+		err_type = nfestat0 & 0x3;
+
+		switch (err_type) {
+		case 0: /* No error */
+			ret = 0;
+			break;
+
+		case 1: /* 1 bit error (Correctable)
+			   (nfestat0 >> 7) & 0x7ff	:error byte number
+			   (nfestat0 >> 4) & 0x7	:error bit number */
+			printk("s3c-nand: 1 bit error detected at byte %ld, correcting from "
+					"0x%02x ", (nfestat0 >> 7) & 0x7ff, dat[(nfestat0 >> 7) & 0x7ff]);
+			dat[(nfestat0 >> 7) & 0x7ff] ^= (1 << ((nfestat0 >> 4) & 0x7));
+			printk("to 0x%02x...OK\n", dat[(nfestat0 >> 7) & 0x7ff]);
+			ret = 1;
+			break;
+
+		case 2: /* Multiple error */
+		case 3: /* ECC area error */
+			printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+		}
+	} else {
+		/* MLC: */
+		s3c_nand_wait_ecc_busy();
+
+		nfestat0 = readl(NFESTAT0);
+		nfestat1 = readl(NFESTAT1);
+		nfmlcbitpt = readl(NFMLCBITPT);
+
+		err_type = (nfestat0 >> 26) & 0x7;
+
+		/* No error, If free page (all 0xff) */
+		if ((nfestat0 >> 29) & 0x1) {
+			err_type = 0;
+		} else {
+			/* No error, If all 0xff from 17th byte in oob (in case of JFFS2 format) */
+			if (dat) {
+				if (dat[17] == 0xff && dat[26] == 0xff && dat[35] == 0xff && dat[44] == 0xff && dat[54] == 0xff)
+					err_type = 0;
+			}
+		}
+
+		switch (err_type) {
+		case 5: /* Uncorrectable */
+			printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+
+		case 4: /* 4 bit error (Correctable) */
+			dat[(nfestat1 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 24) & 0xff);
+
+		case 3: /* 3 bit error (Correctable) */
+			dat[nfestat1 & 0x3ff] ^= ((nfmlcbitpt >> 16) & 0xff);
+
+		case 2: /* 2 bit error (Correctable) */
+			dat[(nfestat0 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 8) & 0xff);
+
+		case 1: /* 1 bit error (Correctable) */
+			printk("s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
+			dat[nfestat0 & 0x3ff] ^= (nfmlcbitpt & 0xff);
+			ret = err_type;
+			break;
+
+		case 0: /* No error */
+			ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+#if defined(CONFIG_NAND_BL1_8BIT_ECC) && defined(CONFIG_S5PC110)
+/***************************************************************
+ * jsgood: Temporary 8 Bit H/W ECC supports for BL1 (6410/6430 only)
+ ***************************************************************/
+static void s3c_nand_wait_ecc_busy_8bit(void)
+{
+	while (readl(NFECCSTAT) & NFESTAT0_ECCBUSY) {
+	}
+}
+
+void s3c_nand_enable_hwecc_8bit(struct mtd_info *mtd, int mode)
+{
+	u_long nfreg;
+	
+	cur_ecc_mode = mode;
+
+	if(cur_ecc_mode == NAND_ECC_WRITE){
+
+	/* 8 bit selection */
+	nfreg = readl(NFCONF);
+	nfreg &= ~(0x3 << 23);
+	nfreg |= (0x3<< 23);
+	writel(nfreg, NFCONF);
+	
+	/* Set ECC type */
+	nfreg = readl(NFECCCONF);
+	nfreg &= 0xf;
+	nfreg |= 0x3;
+	writel(nfreg, NFECCCONF);
+
+	/* set 8/12/16bit Ecc direction to Encoding */
+	nfreg = readl(NFECCCONT);
+	nfreg &= ~(0x1 << 16);
+	nfreg |= (0x1 << 16);
+	writel(nfreg, NFECCCONT);
+
+	/* set 8/12/16bit ECC message length  to msg */
+	nfreg = readl(NFECCCONF);
+	nfreg &= ~((0x3ff<<16));
+	nfreg |= (0x1ff << 16);
+	writel(nfreg, NFECCCONF);
+
+	/* write '1' to clear this bit. */
+	/* clear illegal access status bit */
+	nfreg = readl(NFSTAT);
+	nfreg |= (0x1 << 4);
+	nfreg |= (0x1 << 5);
+	writel(nfreg, NFSTAT);
+
+	/* clear 8/12/16bit ecc encode done */
+	nfreg = readl(NFECCSTAT);
+	nfreg |= (0x1 << 25);
+	writel(nfreg, NFECCSTAT);
+
+	nfreg = readl(NFCONT);
+	nfreg &= ~(0x1 << 1);
+	writel(nfreg, NFCONT);
+	
+	/* Initialize & unlock */
+	nfreg = readl(NFCONT);
+	nfreg &= ~NFCONT_MECCLOCK;
+	nfreg |= NFCONT_INITECC;	
+	writel(nfreg, NFCONT);
+
+	/* Reset ECC value. */
+	nfreg = readl(NFECCCONT);
+	nfreg |= (0x1 << 2);
+	writel(nfreg, NFECCCONT);
+	
+	}else{
+
+	/* set 8/12/16bit ECC message length  to msg */
+	nfreg = readl(NFECCCONF);
+	nfreg &= ~((0x3ff<<16));
+	nfreg |= (0x1ff << 16);
+	writel(nfreg, NFECCCONF);
+	
+	/* set 8/12/16bit Ecc direction to Decoding */
+	nfreg = readl(NFECCCONT);
+	nfreg &= ~(0x1 << 16);
+	writel(nfreg, NFECCCONT);
+	
+	/* write '1' to clear this bit. */
+	/* clear illegal access status bit */
+	nfreg = readl(NFSTAT);
+	nfreg |= (0x1 << 4);
+	nfreg |= (0x1 << 5);
+	writel(nfreg, NFSTAT);
+
+	/* Lock */
+	nfreg = readl(NFCONT);
+	nfreg |= NFCONT_MECCLOCK;
+	writel(nfreg, NFCONT);
+
+	nfreg = readl(NFCONT);
+	nfreg &= ~(0x1 << 1);
+	writel(nfreg, NFCONT);
+
+	/* clear 8/12/16bit ecc decode done */
+	nfreg = readl(NFECCSTAT);
+	nfreg |= (0x1 << 24);
+	writel(nfreg, NFECCSTAT);
+	
+	/* Initialize & lock */
+	nfreg = readl(NFCONT);
+	nfreg &= ~NFCONT_MECCLOCK;
+	nfreg |= NFCONT_MECCLOCK;
+	writel(nfreg, NFCONT);
+
+	/* write '1' to clear this bit. */
+	nfreg = readl(NFSTAT);
+	nfreg &= ~(1<<4);
+	nfreg |= (1<<4);
+	writel(nfreg, NFSTAT);
+
+	while(!(nfreg &(1<<4))){
+		nfreg = readl(NFSTAT);
+		}
+
+	/* write '1' to clear this bit. */
+	nfreg = readl(NFSTAT);
+	nfreg &= ~(1<<4);
+	nfreg |= (1<<4);
+	writel(nfreg, NFSTAT);
+	
+	/* Initialize & unlock */
+	nfreg = readl(NFCONT);
+	nfreg &= ~NFCONT_MECCLOCK;
+	nfreg |= NFCONT_INITECC;	
+	writel(nfreg, NFCONT);
+
+	/* Reset ECC value. */
+	nfreg = readl(NFECCCONT);
+	nfreg |= (0x1 << 2);
+	writel(nfreg, NFECCCONT);
+	}
+
+}
+
+int s3c_nand_calculate_ecc_8bit(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	u_long nfcont, nfeccprgecc0, nfeccprgecc1, nfeccprgecc2, nfeccprgecc3;
+
+	if (cur_ecc_mode == NAND_ECC_READ) {
+		/* Lock */
+		nfcont = readl(NFCONT);
+		nfcont |= NFCONT_MECCLOCK;
+		writel(nfcont, NFCONT);
+		
+		s3c_nand_wait_dec();
+
+		/* clear 8/12/16bit ecc decode done */
+		nfcont = readl(NFECCSTAT);
+		nfcont |= (1<<24);
+		writel(nfcont, NFECCSTAT);
+
+		s3c_nand_wait_ecc_busy_8bit();
+
+		if(readl(NFSTAT)&(1<<5))
+		{
+			/* clear illegal access status bit */
+			nfcont = readl(NFSTAT);
+			nfcont |= (1<<5);
+			writel(nfcont, NFSTAT);
+
+			printf("\n Accessed locked area!! \n");
+			
+			nfcont = readl(NFCONT);
+			nfcont |= (1<<1);
+			writel(nfcont, NFCONT);
+			
+			return -1;
+		}
+		
+		nfcont = readl(NFCONT);
+		nfcont |= (1<<1);
+		writel(nfcont, NFCONT);
+
+		
+	} else {
+		/* Lock */
+		nfcont = readl(NFCONT);
+		nfcont |= NFCONT_MECCLOCK;
+		writel(nfcont, NFCONT);
+		
+		s3c_nand_wait_enc();
+
+		/* clear 8/12/16bit ecc encode done */
+		nfcont = readl(NFECCSTAT);
+		nfcont |= (1<<25);
+		writel(nfcont, NFECCSTAT);
+
+		nfeccprgecc0 = readl(NFECCPRGECC0);
+		nfeccprgecc1 = readl(NFECCPRGECC1);
+		nfeccprgecc2 = readl(NFECCPRGECC2);
+		nfeccprgecc3 = readl(NFECCPRGECC3);
+	
+		ecc_code[0] = nfeccprgecc0 & 0xff;
+		ecc_code[1] = (nfeccprgecc0 >> 8) & 0xff;
+		ecc_code[2] = (nfeccprgecc0 >> 16) & 0xff;
+		ecc_code[3] = (nfeccprgecc0 >> 24) & 0xff;
+		ecc_code[4] = nfeccprgecc1 & 0xff;
+		ecc_code[5] = (nfeccprgecc1 >> 8) & 0xff;
+		ecc_code[6] = (nfeccprgecc1 >> 16) & 0xff;
+		ecc_code[7] = (nfeccprgecc1 >> 24) & 0xff;
+		ecc_code[8] = nfeccprgecc2 & 0xff;
+		ecc_code[9] = (nfeccprgecc2 >> 8) & 0xff;
+		ecc_code[10] = (nfeccprgecc2 >> 16) & 0xff;
+		ecc_code[11] = (nfeccprgecc2 >> 24) & 0xff;
+		ecc_code[12] = nfeccprgecc3 & 0xff;
+
+		
+
+	}
+
+	return 0;
+}
+
+int s3c_nand_correct_data_8bit(struct mtd_info *mtd, u_char *dat)
+{
+	int ret = -1;
+	u_long nf8eccerr0, nf8eccerr1, nf8eccerr2, nf8eccerr3, nf8eccerr4, nfmlc8bitpt0, nfmlc8bitpt1;
+	u_char err_type;
+
+	s3c_nand_wait_ecc_busy_8bit();
+
+	nf8eccerr0 = readl(NFECCSECSTAT);
+	nf8eccerr1 = readl(NFECCERL0);
+	nf8eccerr2 = readl(NFECCERL1);
+	nf8eccerr3 = readl(NFECCERL2);
+	nf8eccerr4 = readl(NFECCERL3);
+	nfmlc8bitpt0 = readl(NFECCERP0);
+	nfmlc8bitpt1 = readl(NFECCERP1);
+
+	err_type = (nf8eccerr0) & 0xf;
+
+	/* No error, If free page (all 0xff) */
+	if ((nf8eccerr0 >> 29) & 0x1)
+		err_type = 0;
+
+	switch (err_type) {
+	case 9: /* Uncorrectable */
+		printk("s3c-nand: ECC uncorrectable error detected\n");
+		ret = -1;
+		break;
+
+	case 8: /* 8 bit error (Correctable) */
+		dat[(nf8eccerr4 >> 16) & 0x3ff] ^= ((nfmlc8bitpt1 >> 24) & 0xff);
+
+	case 7: /* 7 bit error (Correctable) */
+		dat[(nf8eccerr4) & 0x3ff] ^= ((nfmlc8bitpt1 >> 16) & 0xff);
+
+	case 6: /* 6 bit error (Correctable) */
+		dat[(nf8eccerr3 >> 16) & 0x3ff] ^= ((nfmlc8bitpt1 >> 8) & 0xff);
+
+	case 5: /* 5 bit error (Correctable) */
+		dat[(nf8eccerr3) & 0x3ff] ^= ((nfmlc8bitpt1) & 0xff);
+
+	case 4: /* 8 bit error (Correctable) */
+		dat[(nf8eccerr2 >> 16) & 0x3ff] ^= ((nfmlc8bitpt0 >> 24) & 0xff);
+
+	case 3: /* 7 bit error (Correctable) */
+		dat[(nf8eccerr2) & 0x3ff] ^= ((nfmlc8bitpt0>> 16) & 0xff);
+
+	case 2: /* 6 bit error (Correctable) */
+		dat[(nf8eccerr1 >> 16) & 0x3ff] ^= ((nfmlc8bitpt0>> 8) & 0xff);
+
+	case 1: /* 1 bit error (Correctable) */
+		printk("s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
+		dat[(nf8eccerr1) & 0x3ff] ^= ((nfmlc8bitpt0) & 0xff);
+		ret = err_type;
+		break;
+
+	case 0: /* No error */
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+int s3c_nand_write_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{	
+	int i, eccsize = 512;
+	int eccbytes = 13;
+	int eccsteps = mtd->writesize / eccsize;
+	int badoffs = mtd->writesize == 512 ? NAND_SMALL_BADBLOCK_POS : NAND_LARGE_BADBLOCK_POS;
+
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+	
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		s3c_nand_enable_hwecc_8bit(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		s3c_nand_calculate_ecc_8bit(mtd, p, &ecc_calc[i]);
+	}
+
+	chip->oob_poi[badoffs] = 0xff;
+	for (i = 0; i <= eccbytes * (mtd->writesize / eccsize); i++) {
+		chip->oob_poi[i+12] = ecc_calc[i];
+	}
+
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+int s3c_nand_read_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf)
+{
+	int i, stat, eccsize = 512;
+	int eccbytes = 13;
+	int eccsteps = mtd->writesize / eccsize;
+	int col = 0;
+	uint8_t *p = buf;
+	
+	/* Step1: read whole oob */
+	col = mtd->writesize;
+
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col+12, -1);
+
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	col = 0;
+
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		s3c_nand_enable_hwecc_8bit(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->write_buf(mtd, chip->oob_poi + (((mtd->writesize / eccsize) - eccsteps) * eccbytes), eccbytes);
+		s3c_nand_calculate_ecc_8bit(mtd, 0, 0);
+		stat = s3c_nand_correct_data_8bit(mtd, p);
+
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * ((mtd->writesize / eccsize) + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+int s3c_nand_read_oob_8bit(struct mtd_info *mtd, struct nand_chip *chip, int page, int sndcmd)
+{
+        if (sndcmd) {
+                chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+                sndcmd = 0;
+        }
+
+        chip->read_buf(mtd, chip->oob_poi, 0); //secc_start);
+        return sndcmd;
+}
+
+int s3c_nand_write_oob_8bit(struct mtd_info *mtd, struct nand_chip *chip, int page)
+{
+        int status = 0;
+
+        chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+        /* spare area */
+        chip->write_buf(mtd, chip->oob_poi, 0); //secc_start);
+
+        /* Send command to program the OOB data */
+        chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+        status = chip->waitfunc(mtd, chip);
+        return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/********************************************************/
+#endif
+
+static int s3c_nand_write_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+			      int page)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int status = 0;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+	int i;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+static int s3c_nand_read_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+			     int page)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+#if 0
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+#endif
+
+	return 0;
+}
+
+static int s3c_nand_write_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf, int oob_required, int page)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[eccpos[i]] = ecc_calc[i];
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	return 0;
+}
+
+static int s3c_nand_read_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int oob_required, int page)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	int col = 0;
+	uint8_t *p = buf;
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+#if 0
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+#endif
+
+	col = 0;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+
+		stat = chip->ecc.correct(mtd, p, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), 0);
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+/*
+ * Hardware specific page read function for MLC.
+ * Written by jsgood
+ */
+static int s3c_nand_read_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int oob_required, int page)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int col = 0;
+	uint8_t *p = buf;
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+
+	/* Step1: read whole oob */
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	col = 0;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->write_buf(mtd, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), eccbytes);
+		chip->ecc.calculate(mtd, 0, 0);
+		stat = chip->ecc.correct(mtd, p, 0, 0);
+
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+/*
+ * Hardware specific page write function for MLC.
+ * Written by jsgood
+ */
+static int s3c_nand_write_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf, int oob_required, int page)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const uint8_t *p = buf;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+
+	/* Step1: write main data and encode mecc */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	/* Step2: save encoded mecc */
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[mecc_pos[i]] = ecc_calc[i];
+
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+#endif
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+#if defined(CONFIG_S5P_NAND_HWECC)
+	int i;
+	u_char tmp, cellinfo;
+	struct nand_flash_dev *type = NULL;
+#endif
+	pr_debug("%s() in\n", __func__);
+
+	NFCONT_REG 		&= ~NFCONT_WP;
+	nand->IO_ADDR_R		= (void __iomem *)(NFDATA);
+	nand->IO_ADDR_W		= (void __iomem *)(NFDATA);
+	nand->cmd_ctrl		= s3c_nand_hwcontrol;
+	nand->dev_ready		= s3c_nand_device_ready;
+	nand->options		= 0;
+
+#if defined(CFG_NAND_FLASH_BBT)
+		nand->options 		|= NAND_USE_FLASH_BBT;
+#else
+		nand->options		|= NAND_SKIP_BBTSCAN;
+#endif
+
+#if defined(CONFIG_S5P_NAND_HWECC)
+	nand->ecc.mode		= NAND_ECC_HW;
+	nand->ecc.hwctl		= s3c_nand_enable_hwecc;
+	nand->ecc.calculate	= s3c_nand_calculate_ecc;
+	nand->ecc.correct	= s3c_nand_correct_data;
+
+	s3c_nand_hwcontrol(0, NAND_CMD_READID, NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+	s3c_nand_hwcontrol(0, 0x00, NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE);
+	s3c_nand_hwcontrol(0, 0x00, NAND_NCE | NAND_ALE);
+	s3c_nand_hwcontrol(0, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+	s3c_nand_device_ready(0);
+
+	tmp = readb(nand->IO_ADDR_R); /* Maf. ID */
+	tmp = readb(nand->IO_ADDR_R); /* Device ID */
+
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (tmp == nand_flash_ids[i].dev_id) {
+			type = &nand_flash_ids[i];
+			break;
+		}
+	}
+
+	pr_debug("type->name=\"%s\"\n", type->name);
+
+	cellinfo = readb(nand->IO_ADDR_R);		/* 3rd byte */
+	tmp = readb(nand->IO_ADDR_R);			/* 4th byte */
+
+	if (!type->pagesize) {
+		if (((cellinfo >> 2) & 0x3) == 0) {
+			nand_type = S3C_NAND_TYPE_SLC;
+			nand->ecc.size = 512;
+			nand->ecc.bytes	= 4;
+			nand->ecc.strength = 1;
+
+			if ((1024 << (tmp & 0x3)) > 512) {
+				nand->ecc.read_page = s3c_nand_read_page_1bit;
+				nand->ecc.write_page = s3c_nand_write_page_1bit;
+				nand->ecc.read_oob = s3c_nand_read_oob_1bit;
+				nand->ecc.write_oob = s3c_nand_write_oob_1bit;
+				nand->ecc.layout = &s3c_nand_oob_64;
+				nand->ecc.hwctl = s3c_nand_enable_hwecc;
+                                nand->ecc.calculate = s3c_nand_calculate_ecc;
+                                nand->ecc.correct = s3c_nand_correct_data;
+                                nand->options |= NAND_NO_SUBPAGE_WRITE;
+			} else {
+				nand->ecc.layout = &s3c_nand_oob_16;
+			}
+		} else {
+			nand_type = S3C_NAND_TYPE_MLC;
+			nand->options |= NAND_NO_SUBPAGE_WRITE;	/* NOP = 1 if MLC */
+			nand->ecc.read_page = s3c_nand_read_page_4bit;
+			nand->ecc.write_page = s3c_nand_write_page_4bit;
+			nand->ecc.size = 512;
+			nand->ecc.bytes = 8;	/* really 7 bytes */
+			nand->ecc.layout = &s3c_nand_oob_mlc_64;
+			nand->ecc.strength = 1;
+		}
+	} else {
+		nand_type = S3C_NAND_TYPE_SLC;
+		nand->ecc.size = 512;
+		nand->ecc.bytes = 4;
+		nand->ecc.layout = &s3c_nand_oob_16;
+		nand->ecc.strength = 1;
+	}
+#else
+	nand->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+	return 0;
+}
+
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 45a105d..8b12213 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -658,4 +658,16 @@ config VIDEO_DT_SIMPLEFB
 	  The video output is initialized by U-Boot, and kept by the
 	  kernel.
 
+config S5P_FB
+	bool "Enable s5pc11x's fimd lcd driver support"
+	help
+	  Enable soc s5pc11x lcd driver without driver model.
+
+config LCD_AT070TN90
+	bool "support lcd model named AT070TN90"
+	default y
+	depends on S5P_FB
+	help
+	  support the lcd model AT070TN90
+
 endmenu
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index dfafe08..242f5a7 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -53,6 +53,8 @@ obj-$(CONFIG_LG4573) += lg4573.o
 obj-$(CONFIG_AM335X_LCD) += am335x-fb.o
 obj-$(CONFIG_VIDEO_DW_HDMI) += dw_hdmi.o
 obj-$(CONFIG_VIDEO_SIMPLE) += simplefb.o
+obj-${CONFIG_S5P_FB} += s5p_fb.o
+
 obj-${CONFIG_VIDEO_TEGRA124} += tegra124/
 obj-${CONFIG_EXYNOS_FB} += exynos/
 obj-${CONFIG_VIDEO_ROCKCHIP} += rockchip/
diff --git a/drivers/video/s5p_fb.c b/drivers/video/s5p_fb.c
new file mode 100644
index 0000000..d6933e3
--- /dev/null
+++ b/drivers/video/s5p_fb.c
@@ -0,0 +1,680 @@
+﻿/*
+ * Copyright (c) 2010 Samsung Electronics Co., Ltd.
+ *              http://www.samsung.com/
+ *
+ * S5PC110 - LCD Driver for U-Boot
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <lcd.h>
+#include <asm/arch/s5pc110.h>
+
+
+#define LCD_BGCOLOR		0x0//0x1428A0
+
+#if 0
+static unsigned int gFgColor = 0xFF00;
+static unsigned int gLeftColor = LCD_BGCOLOR;
+#endif
+
+#define Inp32(_addr)		readl(_addr)
+#define Outp32(addr, data)	(*(volatile u32 *)(addr) = (data))
+#define Delay(_a)		udelay(_a*1000)
+
+
+#if defined(CFG_LCD_TL2796)
+/*
+ * TL2796
+ */
+
+#define LCD_WIDTH		480
+#define LCD_HEIGHT		800
+
+#define IIC_SDA_GPIO_ADDRESS		(0xE02000C0)	//GPB
+#define IIC_SDA_GPIO_BIT			(0)		//GPB[7]
+#define IIC_SCL_GPIO_ADDRESS		(0xE02000C0)	//GPB
+#define IIC_SCL_GPIO_BIT			(1)		//GPB[4]
+#define SDA_GPIO_ADDRESS			(0xE0200040)	//GPB
+#define SDA_GPIO_BIT				(7)		//GPB[7]
+#define SCL_GPIO_ADDRESS			(0xE0200040)	//GPB
+#define SCL_GPIO_BIT				(4)		//GPB[4]
+#define CS_GPIO_ADDRESS				(0xE0200040)	//GPB
+#define CS_GPIO_BIT					(5)		//GPB[5]
+#define BACKLIGHT_GPIO_ADDRESS		(0xE02000A0)	//GPD0
+#define BACKLIGHT_GPIO_BIT			(3)		//GPD0[3]
+#define RESET_GPIO_ADDRESS			(0xE0200C00)	//GPH0
+#define RESET_GPIO_BIT				(6)		//GPH0.6
+#define POWER_GPIO_ADDRESS			(0xE0200040)
+#define POWER_GPIO_BIT				(6)
+#define POWER_GPIO_ADDRESS2			(0xE0200040)
+#define POWER_GPIO_BIT2				(7)
+#define BACKLIGHT_ACTIVE 			HIGH_ACTIVE
+#define RESET_ACTIVE 				LOW_ACTIVE
+#define POWER_ACTIVE 				HIGH_ACTIVE
+
+//do not modify
+#define LCDM_SDA_HIGH			Outp32(SDA_GPIO_ADDRESS+4,(Inp32(SDA_GPIO_ADDRESS+4) |= (1<<SDA_GPIO_BIT)))
+#define LCDM_SDA_LOW			Outp32(SDA_GPIO_ADDRESS+4,(Inp32(SDA_GPIO_ADDRESS+4) &= ~(1<<SDA_GPIO_BIT)))
+#define LCDM_SCL_HIGH			Outp32(SCL_GPIO_ADDRESS+4,(Inp32(SCL_GPIO_ADDRESS+4) |= (1<<SCL_GPIO_BIT)))
+#define LCDM_SCL_LOW			Outp32(SCL_GPIO_ADDRESS+4,(Inp32(SCL_GPIO_ADDRESS+4) &= ~(1<<SCL_GPIO_BIT)))
+#define LCDM_CS_HIGH			Outp32(CS_GPIO_ADDRESS+4,(Inp32(CS_GPIO_ADDRESS+4) |=(1<<CS_GPIO_BIT)))
+#define LCDM_CS_LOW				Outp32(CS_GPIO_ADDRESS+4,(Inp32(CS_GPIO_ADDRESS+4) &= ~(1<<CS_GPIO_BIT)))
+#define LCDM_BACKLIGHT_HIGH 	Outp32(BACKLIGHT_GPIO_ADDRESS+4,(Inp32(BACKLIGHT_GPIO_ADDRESS+4) |= (1<<BACKLIGHT_GPIO_BIT)))
+#define LCDM_BACKLIGHT_LOW	Outp32(BACKLIGHT_GPIO_ADDRESS+4,(Inp32(BACKLIGHT_GPIO_ADDRESS+4) &= ~(1<<BACKLIGHT_GPIO_BIT)))
+#define LCDM_RESET_HIGH		 	Outp32(RESET_GPIO_ADDRESS+4,(Inp32(RESET_GPIO_ADDRESS+4) |= (1<<RESET_GPIO_BIT)))
+#define LCDM_RESET_LOW			Outp32(RESET_GPIO_ADDRESS+4,(Inp32(RESET_GPIO_ADDRESS+4) &= ~(1<<RESET_GPIO_BIT)))
+#define LCDM_POWER_HIGH		 	Outp32(POWER_GPIO_ADDRESS+4,(Inp32(POWER_GPIO_ADDRESS+4) |= (1<<POWER_GPIO_BIT)))
+#define LCDM_POWER_LOW			Outp32(POWER_GPIO_ADDRESS+4,(Inp32(POWER_GPIO_ADDRESS+4) &= ~(1<<POWER_GPIO_BIT)))
+#define LCDM_POWER2_HIGH	 	Outp32(POWER_GPIO_ADDRESS+4,(Inp32(POWER_GPIO_ADDRESS+4) |= (1<<POWER_GPIO_BIT)))
+#define LCDM_POWER2_LOW	 		Outp32(POWER_GPIO_ADDRESS+4,(Inp32(POWER_GPIO_ADDRESS+4) &= ~(1<<POWER_GPIO_BIT)))
+#define LCDM_IIC_SCL_HIGH		Outp32(SCL_GPIO_ADDRESS+4,(Inp32(SCL_GPIO_ADDRESS+4) |= (1<<SCL_GPIO_BIT)))
+#define LCDM_IIC_SCL_LOW		Outp32(SCL_GPIO_ADDRESS+4,(Inp32(SCL_GPIO_ADDRESS+4) &= ~(1<<SCL_GPIO_BIT)))
+#define LCDM_IIC_SDA_HIGH		Outp32(SDA_GPIO_ADDRESS+4,(Inp32(SDA_GPIO_ADDRESS+4) |= (1<<SDA_GPIO_BIT)))
+#define LCDM_IIC_SDA_LOW		Outp32(SDA_GPIO_ADDRESS+4,(Inp32(SDA_GPIO_ADDRESS+4) &= ~(1<<SDA_GPIO_BIT)))
+
+
+void Write_LDI_TL2796(u16 uAddr, u16 uData)
+{
+	s32 j;
+
+	if(uAddr != 0x0000)
+	{
+		LCDM_CS_HIGH;
+		LCDM_SCL_HIGH;
+		LCDM_SDA_HIGH;
+
+		LCDM_CS_LOW;
+		LCDM_SCL_LOW;
+
+	    // Command
+	    for (j = 15 ; j >= 0; j--)
+		{
+			LCDM_SCL_LOW;
+
+			if ((uAddr >> j) & 0x0001)
+			{
+				LCDM_SDA_HIGH;
+			}
+			else
+			{
+				LCDM_SDA_LOW;
+			}
+			LCDM_SCL_HIGH;
+		}
+	}
+
+	if (uAddr == 0x0000)
+	{
+		LCDM_SDA_HIGH;
+	}
+
+	LCDM_CS_HIGH;
+	LCDM_SCL_HIGH;
+	LCDM_CS_LOW;
+	LCDM_SCL_LOW;
+
+	// parameter
+	for (j = 15 ; j >= 0; j--)
+	{
+		LCDM_SCL_LOW;
+
+		if ((uData >> j) & 0x0001)
+		{
+			LCDM_SDA_HIGH;
+		}
+		else
+		{
+			LCDM_SDA_LOW;
+		}
+		LCDM_SCL_HIGH;
+	}
+}
+
+void LCDM_InitTL2796(void)
+{
+    Delay(50); // more than 20ms
+
+	//[1] Panel Condition Set
+	Write_LDI_TL2796(0x7031, 0x7208);
+	Write_LDI_TL2796(0x7032, 0x7214);
+	Write_LDI_TL2796(0x7030, 0x7202);
+
+#if 1
+	Write_LDI_TL2796(0x7027, 0x7203);
+#else
+	Write_LDI_TL2796(0x7027, 0x7201);
+#endif
+
+	//[2] Display Condition Set(RGB Data Interface)
+	Write_LDI_TL2796(0x7012, 0x7208); //0x7208
+	Write_LDI_TL2796(0x7013, 0x7208);
+#if 1
+	Write_LDI_TL2796(0x7015, 0x7210); //0x10
+#else
+	Write_LDI_TL2796(0x7015, 0x7200); //0x00
+#endif
+	Write_LDI_TL2796(0x7016, 0x7200);	//00 24bit 02 16bit RGB interface 
+	Write_LDI_TL2796(0x70ef, 0x72d0);
+	Write_LDI_TL2796(0x0000, 0x72e8);
+
+	// set gamma control 230cd
+	Write_LDI_TL2796(0x7039, 0x7244);
+	Write_LDI_TL2796(0x7040, 0x7200);
+	Write_LDI_TL2796(0x7041, 0x723F);
+	Write_LDI_TL2796(0x7042, 0x722B);
+	Write_LDI_TL2796(0x7043, 0x721f);
+	Write_LDI_TL2796(0x7044, 0x7224);
+	Write_LDI_TL2796(0x7045, 0x721b);
+	Write_LDI_TL2796(0x7046, 0x7229);
+	Write_LDI_TL2796(0x7050, 0x7200);
+	Write_LDI_TL2796(0x7051, 0x7200);
+	Write_LDI_TL2796(0x7052, 0x7200);
+	Write_LDI_TL2796(0x7053, 0x721b);
+	Write_LDI_TL2796(0x7054, 0x7222);
+	Write_LDI_TL2796(0x7055, 0x721b);
+	Write_LDI_TL2796(0x7056, 0x722a);
+	Write_LDI_TL2796(0x7060, 0x7200);
+	Write_LDI_TL2796(0x7061, 0x723F);
+	Write_LDI_TL2796(0x7062, 0x7225);
+	Write_LDI_TL2796(0x7063, 0x721c);
+	Write_LDI_TL2796(0x7064, 0x7221);
+	Write_LDI_TL2796(0x7065, 0x7218);
+	Write_LDI_TL2796(0x7066, 0x723e);
+
+	//Analog Power Condition Set
+	Write_LDI_TL2796(0x7017, 0x7222);	//Boosting Freq
+	Write_LDI_TL2796(0x7018, 0x7233);	//power AMP Medium
+	Write_LDI_TL2796(0x7019, 0x7203);	//Gamma Amp Medium
+	Write_LDI_TL2796(0x701a, 0x7201);	//Power Boosting
+	Write_LDI_TL2796(0x7022, 0x72a4);	//Vinternal = 0.65*VCI
+	Write_LDI_TL2796(0x7023, 0x7200);	//VLOUT1 Setting = 0.98*VCI
+	Write_LDI_TL2796(0x7026, 0x72a0);	//Display Condition LTPS signal generation : Reference= DOTCLK
+
+	//Stand-by Off Comman
+	Write_LDI_TL2796(0x701d, 0x72a0);
+
+	Delay(500); // more than 250ms
+
+	//LCD ON
+	Write_LDI_TL2796(0x7014, 0x7203);
+}
+
+void LCD_Initialize_TL2796(void)
+{
+	u32 uFbAddr = CFG_LCD_FBUFFER;
+
+	u32 i,uTmpReg;
+	u32* pBuffer = (u32*)uFbAddr;
+
+
+	LCD_setprogress(0);
+
+
+	uTmpReg = Inp32(0xE0107008);		// need to be changed later (09.01.23 WJ.Kim)	
+	uTmpReg = (uTmpReg & ~(0x3)) | 0x2 ;
+	Outp32(0xE0107008, uTmpReg);
+
+	uTmpReg = Inp32(0xf800027c);
+	uTmpReg = (uTmpReg & ~(0x3)) | 0 ;
+	Outp32(0xf800027c,uTmpReg);
+
+
+	Outp32(0xE0200120, 0x22222222);	//set GPF0 as LVD_HSYNC,VSYNC,VCLK,VDEN,VD[3:0]
+	Outp32(0xE0200128,0x0);			//set pull-up,down disable
+	Outp32(0xE0200140, 0x22222222);	//set GPF1 as VD[11:4]
+	Outp32(0xE0200148,0x0);			//set pull-up,down disable
+	Outp32(0xE0200160, 0x22222222);	//set GPF2 as VD[19:12]
+	Outp32(0xE0200168,0x0);			//set pull-up,down disable
+	Outp32(0xE0200180, 0x00002222);	//set GPF3 as VD[23:20]
+	Outp32(0xE0200188,0x0);			//set pull-up,down disable
+
+	Outp32(0xe02000A0, 0x11111111);	//set GPF0 as LVD_HSYNC,VSYNC,VCLK,VDEN,VD[3:0]
+	Outp32(0xe02000A8,0x0);			//set pull-up,down disable
+	Outp32(0xe02000A4,(1<<3));
+
+	Outp32(0xE0200040, 0x11111111);	//set GPF0 as LVD_HSYNC,VSYNC,VCLK,VDEN,VD[3:0]
+	Outp32(0xE0200048,0x0);			//set pull-up,down disable
+	Outp32(0xE0200044,0);
+
+	Outp32(0xE02000c0, 0x11111111);	//set GPF0 as LVD_HSYNC,VSYNC,VCLK,VDEN,VD[3:0]
+	Outp32(0xE02000c8,0x0);			//set pull-up,down disable
+	Outp32(0xE02000c4,0);
+
+	Outp32(0xE0200C00, 0x11111111);	//set GPF0 as LVD_HSYNC,VSYNC,VCLK,VDEN,VD[3:0]
+	Outp32(0xE0200C08,0x0);			//set pull-up,down disable
+	Outp32(0xE0200C04,0);
+	Delay(50);
+	Outp32(0xE0200C04,0xffffffff);
+
+	Outp32(SDA_GPIO_ADDRESS+4,(Inp32(SDA_GPIO_ADDRESS+4) |= (1<<SDA_GPIO_BIT)));
+	Outp32(SCL_GPIO_ADDRESS+4,(Inp32(SCL_GPIO_ADDRESS+4) |= (1<<SCL_GPIO_BIT)));
+	Outp32(CS_GPIO_ADDRESS+4,(Inp32(CS_GPIO_ADDRESS+4) |=(1<<CS_GPIO_BIT)));
+	Outp32(SCL_GPIO_ADDRESS+4,(Inp32(SCL_GPIO_ADDRESS+4) |= (1<<SCL_GPIO_BIT)));
+	Outp32(SDA_GPIO_ADDRESS+4,(Inp32(SDA_GPIO_ADDRESS+4) |= (1<<SDA_GPIO_BIT)));
+
+	Outp32(0xf8000004, 0xf0);
+	Outp32(0xf8000010, 0x50505);
+	Outp32(0xf8000014, 0x50505);
+	Outp32(0xf8000170, 0x0);
+	Outp32(0xf8000018, 0x18f9df);
+	Outp32(0xf8000000, 0x0);
+	Outp32(0xf8000000, 0x190);
+	Outp32(0xf8000130, 0x20);
+	Outp32(0xf8000020, 0x0);
+	Outp32(0xf8000024, 0x0);
+	Outp32(0xf8000028, 0x0);
+	Outp32(0xf800002c, 0x0);
+	Outp32(0xf8000030, 0x0);
+	Outp32(0xf8000034, 0x0);
+	Outp32(0xf8000180, 0x0);
+	Outp32(0xf8000184, 0x0);
+	Outp32(0xf8000188, 0x0);
+	Outp32(0xf800018c, 0x0);
+	Outp32(0xf8000190, 0x0);
+	Outp32(0xf8000140, 0x0);
+	Outp32(0xf8000148, 0x0);
+	Outp32(0xf8000150, 0x0);
+	Outp32(0xf8000158, 0x0);
+	Outp32(0xf8000058, 0x0);
+	Outp32(0xf8000208, 0x0);
+	Outp32(0xf800020c, 0x0);
+	Outp32(0xf8000068, 0x0);
+	Outp32(0xf8000210, 0x0);
+	Outp32(0xf8000214, 0x0);
+	Outp32(0xf8000078, 0x0);
+	Outp32(0xf8000218, 0x0);
+	Outp32(0xf800021c, 0x0);
+	Outp32(0xf8000088, 0x0);
+	Outp32(0xf8000220, 0x0);
+	Outp32(0xf8000224, 0x0);
+	Outp32(0xf8000260, 0x1);
+	Outp32(0xf8000034, 0x0);
+	Outp32(0xf80000a4, uFbAddr + 0x0);
+	Outp32(0xf80000d4, uFbAddr + 0x177000);
+	Outp32(0xf80000a0, uFbAddr + 0x0);
+	Outp32(0xf80000d0, uFbAddr + 0x177000);
+	Outp32(0xf80020a0, uFbAddr + 0x0);
+	Outp32(0xf80020d0, uFbAddr + 0x177000);
+	Outp32(0xf8000100, 0x780);
+	Outp32(0xf8000020, 0x8000);
+	Outp32(0xf8000020, 0x802c);
+	Outp32(0xf8000040, 0x0);
+	Outp32(0xf8000044, 0xefb1f);
+	Outp32(0xf8000200, 0xffffff);
+	Outp32(0xf8000204, 0xffffff);
+	Outp32(0xf8000034, 0x400);
+	Outp32(0xf8000020, 0x802d);
+	Outp32(0xf8000034, 0x1);
+	Outp32(0xf8000034, 0x1);
+	Outp32(0xf8000034, 0x401);
+	Outp32(0xf8000020, 0x802d);
+	Outp32(0xf8000034, 0x1);
+	Outp32(0xf8000034, 0x1);
+
+	Outp32(0xf8000000, 0x193);
+
+//	LCDM_InitLdi(LCD_TL2796, 0);
+	LCDM_InitTL2796();
+}
+#elif defined(CFG_LCD_NONAME1)
+/*
+ *
+ */
+
+#define LCD_WIDTH		1366
+#define LCD_HEIGHT		500	//766
+
+void LCD_Initialize_NONAME1(void)
+{
+	u32 uFbAddr = CFG_LCD_FBUFFER;
+
+	u32 i;
+	u32* pBuffer = (u32*)uFbAddr;
+
+	Outp32(0xe0200040, 0x10000000);
+	Outp32(0xe0200048, 0x1555);
+	Outp32(0xe020004c, 0xc000);
+	Outp32(0xe0200040, 0x10010000);
+	Outp32(0xe0200048, 0x1455);
+	Outp32(0xe020004c, 0xc300);
+	Outp32(0xe0200040, 0x10110000);
+	Outp32(0xe0200048, 0x1055);
+	Outp32(0xe020004c, 0xcf00);
+	Outp32(0xe02000c0, 0x1);
+	Outp32(0xe02000c8, 0x54);
+	Outp32(0xe02000cc, 0x3);
+	Outp32(0xe02000c0, 0x11);
+	Outp32(0xe02000c8, 0x50);
+	Outp32(0xe02000cc, 0xf);
+	Outp32(0xe02000a0, 0x1001);
+	Outp32(0xe02000a8, 0x15);
+	Outp32(0xe02000ac, 0xc0);
+	Outp32(0xe0200c00, 0x1000010);
+	Outp32(0xe0200c08, 0x4455);
+	Outp32(0xe0200c0c, 0x3000);
+	Outp32(0xe0200040, 0x11110000);
+	Outp32(0xe0200048, 0x55);
+	Outp32(0xe020004c, 0xff00);
+	Outp32(0xe0200040, 0x11110100);
+	Outp32(0xe0200048, 0x55);
+	Outp32(0xe020004c, 0xff00);
+	Outp32(0xe0200044, 0x80);
+	Outp32(0xe0200044, 0x98);
+	Outp32(0xe0200044, 0xb9);
+	Outp32(0xe0200044, 0xbb);
+	Outp32(0xe0200044, 0xbb);
+	Outp32(0xe02000a4, 0xd);
+	Outp32(0xe0200c04, 0xd1);
+	Outp32(0xe0200044, 0xfb);
+	Outp32(0xe0200044, 0xff);
+	Outp32(0xe0200c04, 0x91);
+	Outp32(0xe0200c04, 0xd1);
+	Outp32(0xe0200c04, 0xd3);
+
+
+	Outp32(0xe0200120, 0x22222222);	//set GPF0 as LVD_HSYNC,VSYNC,VCLK,VDEN,VD[3:0]
+	Outp32(0xe0200128,0x0);			//set pull-up,down disable
+	Outp32(0xe0200140, 0x22222222);	//set GPF1 as VD[11:4]
+	Outp32(0xe0200148,0x0);			//set pull-up,down disable
+	Outp32(0xe0200160, 0x22222222);	//set GPF2 as VD[19:12]
+	Outp32(0xe0200168,0x0);			//set pull-up,down disable
+	Outp32(0xe0200180, 0x00002222);	//set GPF3 as VD[23:20]
+	Outp32(0xe0200188,0x0);			//set pull-up,down disable
+
+	//--------- S5PC110 EVT0 needs MAX drive strength	---------//
+	Outp32(0xe020012c,0xffffffff);			//set GPF0 drive strength max by WJ.KIM(09.07.17)
+	Outp32(0xe020014c,0xffffffff);			//set GPF1 drive strength max by WJ.KIM(09.07.17)
+	Outp32(0xe020016c,0xffffffff);			//set GPF2 drive strength max by WJ.KIM(09.07.17)
+	Outp32(0xe020018c,0x3ff);					//set GPF3 drive strength max by WJ.KIM(09.07.17)
+
+	Outp32(0xf8000004, 0x60);
+	Outp32(0xf8000010, 0xe0e0305);
+	Outp32(0xf8000014, 0x3103020);
+	Outp32(0xf8000170, 0x0);
+	Outp32(0xf8000018, 0x17fd55);
+	Outp32(0xf8000000, 0x0);
+	Outp32(0xf8000000, 0x254);
+	Outp32(0xf8000130, 0x20);
+	Outp32(0xf8000020, 0x0);
+	Outp32(0xf8000024, 0x0);
+	Outp32(0xf8000028, 0x0);
+	Outp32(0xf800002c, 0x0);
+	Outp32(0xf8000030, 0x0);
+	Outp32(0xf8000034, 0x0);
+	Outp32(0xf8000180, 0x0);
+	Outp32(0xf8000184, 0x0);
+	Outp32(0xf8000188, 0x0);
+	Outp32(0xf800018c, 0x0);
+	Outp32(0xf8000190, 0x0);
+	Outp32(0xf8000140, 0x0);
+	Outp32(0xf8000148, 0x0);
+	Outp32(0xf8000150, 0x0);
+	Outp32(0xf8000158, 0x0);
+	Outp32(0xf8000058, 0x0);
+	Outp32(0xf8000208, 0x0);
+	Outp32(0xf800020c, 0x0);
+	Outp32(0xf8000068, 0x0);
+	Outp32(0xf8000210, 0x0);
+	Outp32(0xf8000214, 0x0);
+	Outp32(0xf8000078, 0x0);
+	Outp32(0xf8000218, 0x0);
+	Outp32(0xf800021c, 0x0);
+	Outp32(0xf8000088, 0x0);
+	Outp32(0xf8000220, 0x0);
+	Outp32(0xf8000224, 0x0);
+	Outp32(0xf8000260, 0x1);
+	Outp32(0xf8000048, 0x100200);
+	Outp32(0xf8000200, 0xffffff);
+	Outp32(0xf8000204, 0xffffff);
+	Outp32(0xf8000034, 0x0);
+	Outp32(0xf8000020, 0x802c);
+	Outp32(0xf80000a0, uFbAddr + 0x00000000);
+	Outp32(0xf80000d0, uFbAddr + 0x00400800);
+	Outp32(0xf80000a4, uFbAddr + 0x00000000);
+	Outp32(0xf80000d4, uFbAddr + 0x00400800);
+	Outp32(0xf80020a0, uFbAddr + 0x00000000);
+	Outp32(0xf80020d0, uFbAddr + 0x00400800);
+	Outp32(0xf8000100, 0x1558);
+	Outp32(0xf8000040, 0x0);
+	Outp32(0xf8000044, 0x2aaaff);
+	Outp32(0xf8000020, 0x802d);
+	Outp32(0xf8000034, 0x1);
+	Outp32(0xf8000020, 0x802d);
+	Outp32(0xf8000034, 0x1);
+//	Outp32(0xf8000000, 0x257);
+//	Outp32(0xf8000000, 0x57); //===> MPLL should be 667 !!!!
+	Outp32(0xf8000000, 0x53);
+	Outp32(0xf8000010, 0x60400);
+	Outp32(0xf80001a4, 0x3);
+
+	Outp32(0xe0107008,0x2); //syscon output path
+	Outp32(0xe0100204,0x700000); //syscon fimdclk = mpll
+
+	LCD_setprogress(0);
+}
+#elif defined(CONFIG_LCD_AT070TN90)
+
+static void *fb_base;				/* Start of framebuffer memory	*/
+
+vidinfo_t panel_info = {
+	.vl_col = 800,		/* Number of columns (i.e. 160) */
+	.vl_row = 480,		/* Number of rows (i.e. 100) */
+	.vl_bpix = LCD_BPP,			/* Bits per pixel, 0 = 1, 1 = 2, 2 = 4, 3 = 8 */
+} ;
+
+
+static void LCD_Initialize_AT070TN90(void *lcdbase)
+{
+	/* 1.配置引脚
+	 *   LCD_HSYNC LCD_VSYNC LCD_VDEN LCD_VCLK
+	 *  LCD_VD[0] LCD_VD[1] LCD_VD[2] LCD_VD[3]
+	 */
+	Outp32(GPF0CON, 0x22222222);
+
+	/* 2.配置引脚
+	 *   LCD_VD[4] LCD_VD[5] LCD_VD[6] LCD_VD[7]
+	 *    LCD_VD[8] LCD_VD[9] LCD_VD[10] LCD_VD[11]
+	 */
+	Outp32(GPF1CON, 0x22222222);
+
+	/* 3.配置引脚
+	   LCD_VD[12] LCD_VD[13] LCD_VD[14] LCD_VD[15]
+	   LCD_VD[16] LCD_VD[17] LCD_VD[18] LCD_VD[19]
+	*/
+	Outp32(GPF2CON, 0x22222222);
+
+	/* 4.配置引脚
+	    LCD_VD[20] LCD_VD[21] LCD_VD[22] LCD_VD[23]
+	*/
+	Outp32(GPF3CON, Inp32(GPF3CON) & (~((0xF<<12)|(0xF<<8)|(0xF<<4)|(0xF<<0))));
+	Outp32(GPF3CON, Inp32(GPF3CON) | ((0x2<<12)|(0x2<<8)|(0x2<<4)|(0x2<<0)));
+
+	/* 5.VIDCON0
+	   Note:ENVID and ENVID_F are set to “1”
+	   [0]:1 Display On必须置1
+	   [1]:1 Display On必须置1
+	   [4]:1 因为显示的时钟需要用到33.3MHz的频率，那么要进行分频
+	   [6]:4 显示主区域的HCLK时钟为166MHz，为了得到33.3MHz左右的频率，当前的值要设置为4
+	   [18]:0 因为我们当前是RGB并行接口，意思就是说一次发送3个字节，什么是串行接口，3个字节分3次来发送
+	   [26]:0 配置为RGB接口
+	*/
+	//rVIDCON0=(0<<26)|(0<<18)|(4<<6)|(1<<4)|(1<<1)|(1<<0);
+	Outp32(ELFIN_LCD_BASE, (0<<26)|(0<<18)|(4<<6)|(1<<4)|(1<<1)|(1<<0));
+
+	/* 6.VIDCON1，通过观看S70-AT070TN92(GEC210).pdf中的13页发现VSYNC和HSYNC信号发现与210手册的1207页极性相反，需要进行配置
+	   [5]:1 VSYNC极性取反
+	   [6]:1 HSYNC极性取反
+	*/
+	//rVIDCON1=(1<<6)|(1<<5);
+	Outp32( ELFIN_LCD_BASE+0x4, (1<<6)|(1<<5));
+
+	/* 7.配置rVIDTCON0，这部分要查看S70-AT070TN92(GEC210).pdf中的14页中3.3.3Timing
+	   [7:0]:9+1	VSPW垂直同步信号宽度，这是VSYNC同步信号的高电平持续时间
+	   [8:15]:21+1	VFPD
+	   [16:23]:12+1 VBPD
+	*/
+	//rVIDTCON0=(12<<16)|(21<<8)|(9<<0);
+	Outp32(ELFIN_LCD_BASE+0x10, (12<<16)|(21<<8)|(9<<0));
+
+	/* 8.配置rVIDTCON1，这部分要查看S70-AT070TN92(GEC210).pdf中的14页中3.3.3 Timing
+	   [7:0]:19+1	 HSPW水平同步信号宽度，这是VSYNC同步信号的高电平持续时间
+	   [8:15]:209+1  HFPD
+	   [16:23]:25+1  HBPD
+	*/
+	//rVIDTCON1=(25<<16)|(209<<8)|(19<<0);
+	Outp32(ELFIN_LCD_BASE+0x14, (25<<16)|(209<<8)|(19<<0));
+
+	/* 9.配置rVIDTCON2，这个要看LCD的分辨率，800x480
+	   [10:0]:799+1   一行有多少个像素点
+	   [11:21]:479+1  有多少行
+	*/
+	//rVIDTCON2 = (479<<11)|(799<<0);
+	Outp32(ELFIN_LCD_BASE+0x18, (479<<11)|(799<<0));
+
+	/* 10.配置rWINCON0
+	    [0]:1	     使能视频输出
+	    [5:2]:1011	 显示格式是24位色，R:8 G:8 B:8
+	    [15]:1	 发现EN_LOCAL=0，因为我们待会使用显存即DMA,使能字交换
+			 即每次DMA传输数据最小单元为字传输
+	    [22]:0	使用DMA（直接内存访问:直接向某一地址写数据的时候会自动操作硬件，不需要CPU进行干预）
+	*/
+	//rWINCON0=(1<<15)|(0xB<<2)|(1<<0);
+	Outp32(ELFIN_LCD_BASE+0x20, (1<<15)|(0xB<<2)|(1<<0));
+
+	/* 11.配置rVIDW00ADD0B0，用于设置显示缓存的起始地址
+	*/
+	//rVIDW00ADD0B0=0x48000000;
+	Outp32(ELFIN_LCD_BASE+0xA0, (u32)lcdbase);
+
+	/* 12.rVIDW00ADD1B0，用于配置显示缓存的结束地址，告诉CPU我要占用多大的空间
+	    公式如下:VBASEL = VBASEU +(PAGEWIDTH+OFFSIZE) x (LINEVAL+1)
+			    = 0x48000000+(800+0)x(479+1)x4
+		800x480*4[A:R:G:B]
+	*/
+	//rVIDW00ADD1B0=0x48000000+800*4*480;
+	Outp32(ELFIN_LCD_BASE+0xD0, ((u32)lcdbase)+800*4*480);
+
+	/* 13.rVIDW00ADD2:用于配置窗口的偏移值还有一行占用多少字节
+	   [12:0]  : 800*4 因为Linux显示是32位色，为了兼容以后的Linux驱动部分，增加它的空间
+					   字对齐
+	   [13:25] : 因为当前显示不需要偏移，设置为0就可以了。
+	 */
+	//rVIDW00ADD2  = (0<<13)|((800*4)<<0);
+	Outp32(ELFIN_LCD_BASE+0x100, (0<<13)|((800*4)<<0));
+
+	/* 14.rSHADOWCON 使能Channel 0
+	   [0]:1
+	 */
+	//rSHADOWCON|=(1<<0);
+	Outp32(ELFIN_LCD_BASE+0x34, Inp32(ELFIN_LCD_BASE+0x34) | (1<<0));
+
+	/* 15.rVIDOSD0A 配置显示区域的左上角x/y坐标值
+	    [10:0] :0  左上角的Y坐标值
+	    [21:11]:0  左上角的X坐标值
+	*/
+	//rVIDOSD0A = (0<<11)|(0<<0);
+	Outp32(ELFIN_LCD_BASE+0x40, (0<<11)|(0<<0));
+
+	/* 16.rVIDOSD0B 配置显示区域的右下角x/y坐标值
+	    [10:0] :479  右下角的Y坐标值
+	    [21:11]:799  右下角的X坐标值
+	*/
+	//rVIDOSD0B = (799<<11)|(479<<0);
+	Outp32(ELFIN_LCD_BASE+0x44, (799<<11)|(479<<0));
+
+	/* 17.rVIDOSD0C 配置窗口的大小也就是窗口的分辨率
+	    [23:0] :800*480  For example, Height * Width
+	*/
+	//rVIDOSD0C = 800*480;
+	Outp32(ELFIN_LCD_BASE+0x48, 800*480);
+
+	/* 18.配置FIMD一定要为RGB接口
+	 */
+	//rDISPLAY_CONTROL=2<<0;
+	Outp32(0xe0107008, 2<<0);
+
+}
+
+void lcd_ctrl_init(void *lcdbase)
+{
+	fb_base = lcdbase;
+	LCD_Initialize_AT070TN90(lcdbase);
+
+	/* Enable flushing if we enabled dcache for staying dma coherent */
+	lcd_set_flush_dcache(1);
+}
+
+void lcd_enable (void)
+{
+	return;
+}
+
+void lcd_setcolreg(ushort regno, ushort red, ushort green, ushort blue)
+{
+	return;
+}
+
+
+#else
+//# error "No LCD Type is defined!"
+
+#endif
+
+
+#if 0
+void LCD_turnon(void)
+{
+#if defined(CFG_LCD_TL2796)
+	LCD_Initialize_TL2796();
+#elif defined(CFG_LCD_NONAME1)
+	LCD_Initialize_NONAME1();
+#elif defined(CONFIG_LCD_AT070TN90)
+	LCD_Initialize_AT070TN90((void *)CFG_LCD_FBUFFER);
+#endif
+}
+
+void LCD_setfgcolor(unsigned int color)
+{
+	gFgColor = color;
+}
+
+void LCD_setleftcolor(unsigned int color)
+{
+	gLeftColor = color;
+}
+
+void LCD_setprogress(int percentage)
+{
+#if defined(CFG_LCD_TL2796) || defined(CFG_LCD_NONAME1) || defined(CONFIG_LCD_AT070TN90)
+	u32 i, j;
+	u32* pBuffer = (u32*)fb_base;
+
+	for (i=0; i < panel_info.vl_row*percentage/100; i++)
+	{
+		for (j=0; j < panel_info.vl_col; j++)
+		{
+			*pBuffer++ = gFgColor;
+		}
+	}
+
+	for (; i < panel_info.vl_row; i++)
+	{
+		for (j=0; j < (panel_info.vl_col >> 5); j++)
+		{
+			*pBuffer++ = gLeftColor;
+		}
+		for (; j < panel_info.vl_col; j++)
+		{
+			*pBuffer++ = LCD_BGCOLOR;
+		}
+	}
+#endif
+}
+#endif
+
diff --git a/include/configs/gec210.h b/include/configs/gec210.h
new file mode 100644
index 0000000..c05bcb2
--- /dev/null
+++ b/include/configs/gec210.h
@@ -0,0 +1,278 @@
+﻿/*
+ * (C) Copyright 2009 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * HeungJun Kim <riverful.kim@samsung.com>
+ * Inki Dae <inki.dae@samsung.com>
+ *
+ * Configuation settings for the SAMSUNG SMDKC100 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_SAMSUNG		1	/* in a SAMSUNG core */
+#define CONFIG_S5P		1	/* which is in a S5P Family */
+#define CONFIG_S5PC110		1	/* which is in a S5PC110 / S5PV210 */
+#if 0
+#define CONFIG_GEC210		1	/* working with GEC210 */
+#endif
+#define CONFIG_MACH_TYPE		MACH_TYPE_SMDKV210
+
+
+#include <asm/arch/cpu.h>		/* get chip and board defs */
+#include <asm/arch/s5pc110.h>
+
+#define CONFIG_ARCH_CPU_INIT
+
+/* the SMDK6400 has 24MHz input clock */
+#define CONFIG_SYS_CLK_FREQ	24000000
+
+
+/* DRAM Base */
+#define CONFIG_SYS_SDRAM_BASE		0x30000000
+
+/* Text Base */
+#define CONFIG_SYS_TEXT_BASE		0x34800000
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_INITRD_TAG
+#define CONFIG_CMDLINE_EDITING
+
+/*
+ * Size of malloc() pool
+ * 1MB = 0x100000, 0x100000 = 1024 * 1024
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (1 << 20))
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL0			1	/* use SERIAL 0 on SMDKC100 */
+
+/* PWM */
+#define CONFIG_PWM			1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+
+#define CONFIG_BOOTCOMMAND	"run bootk"
+
+#define CONFIG_RAMDISK_BOOT	"root=/dev/ram0 rw rootfstype=ext2" \
+				" console=ttySAC0,115200n8" \
+				" mem=512M"
+
+#define CONFIG_COMMON_BOOT	"console=ttySAC0,115200n8" \
+				" mem=512M " \
+				" " CONFIG_MTDPARTS_DEFAULT
+
+#define CONFIG_UPDATEB	"updateb=tftp 0x40000000 u-boot.bin;" \
+			"nand erase.part boot;" \
+			"nand write 0x40000000 boot\0"
+
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	CONFIG_UPDATEB \
+	"updatek=" \
+		"tftp 0x40000000 uImage;" \
+		"nand erase.part kernel;" \
+		"nand write 0x40000000 kernel\0" \
+	"updateu=" \
+		"onenand erase block 147-4095;" \
+		"onenand write 0x32000000 0x1260000 0x8C0000\0" \
+	"bootk=" \
+		"nand read 0x30007FC0 kernel;" \
+		"bootm 0x30007FC0\0" \
+	"flashboot=" \
+		"set bootargs root=/dev/mtdblock${bootblock} " \
+		"rootfstype=${rootfstype} " \
+		"ubi.mtd=${ubiblock} ${opts} " CONFIG_COMMON_BOOT ";" \
+		"run bootk\0" \
+	"ubifsboot=" \
+		"set bootargs root=ubi0!rootfs rootfstype=ubifs " \
+		" ubi.mtd=${ubiblock} ${opts} " CONFIG_COMMON_BOOT "; " \
+		"run bootk\0" \
+	"boottrace=setenv opts initcall_debug; run bootcmd\0" \
+	"android=" \
+		"set bootargs root=ubi0!ramdisk ubi.mtd=${ubiblock} " \
+		"rootfstype=ubifs init=/init.sh " CONFIG_COMMON_BOOT "; " \
+		"run bootk\0" \
+	"nfsboot=" \
+		"set bootargs root=/dev/nfs ubi.mtd=${ubiblock} " \
+		"nfsroot=${nfsroot},nolock " \
+		"ip=${ipaddr}:${serverip}:${gatewayip}:" \
+		"${netmask}:nowplus:usb0:off " CONFIG_COMMON_BOOT "; " \
+		"run bootk\0" \
+	"ramboot=" \
+		"set bootargs " CONFIG_RAMDISK_BOOT \
+		" initrd=0x33000000,8M ramdisk=8192\0" \
+	"rootfstype=cramfs\0" \
+	"mtdparts=" CONFIG_MTDPARTS_DEFAULT "\0" \
+	"meminfo=mem=512M\0" \
+	"nfsroot=/nfsroot/arm\0" \
+	"bootblock=5\0" \
+	"ubiblock=4\0" \
+	"ubi=enabled"
+
+#define CONFIG_NETMASK          255.255.255.0
+#define CONFIG_IPADDR		192.168.1.48
+#define CONFIG_SERVERIP		192.168.1.46
+#define CONFIG_GATEWAYIP	192.168.1.1
+
+/*-----------------------------------------------------------------------
+ * System clock configuration
+ */
+#define APLL_MDIV       0x7d
+#define APLL_PDIV       0x3
+#define APLL_SDIV       0x1
+
+#define APLL_LOCKTIME_VAL	0x2cf
+
+/* Set AFC value */
+#define AFC_ON		0x00000000
+#define AFC_OFF		0x10000010
+
+
+#define MPLL_MDIV	0x29b
+#define MPLL_PDIV	0xc
+#define MPLL_SDIV	0x1
+
+#define EPLL_MDIV	0x60
+#define EPLL_PDIV	0x6
+#define EPLL_SDIV	0x2
+
+#define VPLL_MDIV	0x6c
+#define VPLL_PDIV	0x6
+#define VPLL_SDIV	0x3
+
+/* CLK_DIV0 */
+#define APLL_RATIO	0
+#define A2M_RATIO	4
+#define HCLK_MSYS_RATIO	8
+#define PCLK_MSYS_RATIO	12
+#define HCLK_DSYS_RATIO	16
+#define PCLK_DSYS_RATIO 20
+#define HCLK_PSYS_RATIO	24
+#define PCLK_PSYS_RATIO 28
+
+#define CLK_DIV0_MASK	0x7fffffff
+
+#define set_pll(mdiv, pdiv, sdiv)	(1<<31 | mdiv<<16 | pdiv<<8 | sdiv)
+
+#define APLL_VAL	set_pll(APLL_MDIV,APLL_PDIV,APLL_SDIV)
+#define MPLL_VAL	set_pll(MPLL_MDIV,MPLL_PDIV,MPLL_SDIV)
+#define EPLL_VAL	set_pll(EPLL_MDIV,EPLL_PDIV,EPLL_SDIV)
+#define VPLL_VAL	set_pll(VPLL_MDIV,VPLL_PDIV,VPLL_SDIV)
+
+#define CLK_DIV0_VAL    ((0<<APLL_RATIO)|(4<<A2M_RATIO)|(4<<HCLK_MSYS_RATIO)|(1<<PCLK_MSYS_RATIO)\
+			|(3<<HCLK_DSYS_RATIO)|(1<<PCLK_DSYS_RATIO)|(4<<HCLK_PSYS_RATIO)|(1<<PCLK_PSYS_RATIO))
+
+#define CLK_DIV1_VAL	((1<<16)|(1<<12)|(1<<8)|(1<<4))
+#define CLK_DIV2_VAL	(1<<0)
+
+
+/*-----------------------------------------------------------------------
+ * memory configuration
+ */
+#define MEMORY_BASE_ADDRESS1	0x40000000	//(2016-10-12 20:26:04 zxd modify)
+#define DMC0_MEMCONTROL		0x00202400	//(2016-10-12 20:26:04 zxd modify)
+#define DMC0_MEMCONFIG_0	0x30F00313	// MemConfig0	256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed,(2016-10-12 20:19:53 zxd modify)
+#define DMC0_MEMCONFIG_1	0x00F00313	// MemConfig1 (2016-10-12 20:19:53 zxd modify)
+#define DMC0_TIMINGA_REF	0x00000618	// TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
+#define DMC0_TIMING_ROW		0x28233287	// TimingRow	for @200MHz
+#define DMC0_TIMING_DATA	0x23240304	// TimingData	CL=3
+#define	DMC0_TIMING_PWR		0x09C80232	// TimingPower
+	
+#define	DMC1_MEMCONTROL		0x00202400	// MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+#define DMC1_MEMCONFIG_0	0x40F00313	// MemConfig0	512MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
+#define DMC1_MEMCONFIG_1	0x00F00313	// MemConfig1 (2016-10-12 20:19:53 zxd modify)
+#define DMC1_TIMINGA_REF	0x00000618	// TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4
+#define DMC1_TIMING_ROW		0x28233289	// TimingRow	for @200MHz
+#define DMC1_TIMING_DATA	0x23240304	// TimingData	CL=3
+#define	DMC1_TIMING_PWR		0x08280232	// TimingPower
+
+
+#define CONFIG_NR_DRAM_BANKS    2          	/* we have 2 bank of DRAM */
+#define SDRAM_BANK_SIZE         0x10000000	/* 256MB */
+#define PHYS_SDRAM_1            CONFIG_SYS_SDRAM_BASE /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE       SDRAM_BANK_SIZE
+#define PHYS_SDRAM_2            (MEMORY_BASE_ADDRESS1) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_2_SIZE       SDRAM_BANK_SIZE
+
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_PBSIZE	384	/* Print Buffer Size */
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x5e00000)
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_TEXT_BASE
+
+#define CONFIG_SYS_MONITOR_BASE	0x00000000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0xb0e00010
+#define CFG_NAND_PAGES_IN_BLOCK		64
+
+#define CONFIG_SYS_MONITOR_LEN		(256 << 10)	/* 256 KiB */
+
+#if !defined(CONFIG_NAND_SPL) && (CONFIG_SYS_TEXT_BASE >= 0xc0000000)
+#define CONFIG_ENABLE_MMU
+#endif
+
+#ifdef CONFIG_ENABLE_MMU
+#define CONFIG_SYS_MAPPED_RAM_BASE	0xc0000000
+#else
+#define CONFIG_SYS_MAPPED_RAM_BASE	CONFIG_SYS_SDRAM_BASE
+#endif
+
+/*-----------------------------------------------------------------------
+ * Boot configuration
+ */
+#define BOOT_ONENAND		0x1
+#define BOOT_NAND		0x2
+#define BOOT_MMCSD		0x3
+#define BOOT_NOR		0x4
+#define BOOT_SEC_DEV		0x5
+
+#define CONFIG_ENV_SIZE			(128 << 10)	/* 128KiB, 0x20000 */
+#define CONFIG_ENV_ADDR			(512 << 10)	/* 512KiB, 0x80000 */
+#define CONFIG_ENV_OFFSET		(512 << 10)	/* 512KiB, 0x80000 */
+
+/* nand copy size from nand to DRAM.*/
+#define	COPY_BL1_SIZE		(8 << 10)	/* for irom's BL0 copy */
+#define	COPY_BL2_SIZE		0x80000
+
+#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_LOAD_ADDR - 0x1000000)
+
+/*
+ * Ethernet Contoller driver
+ */
+#define CONFIG_DRIVER_DM9000		1
+#define CONFIG_DM9000_BASE		(0x88000000)
+#define DM9000_IO			(CONFIG_DM9000_BASE)
+#define DM9000_DATA			(CONFIG_DM9000_BASE+8)
+
+#ifdef CONFIG_CMD_NET
+#define CONFIG_ENV_SROM_BANK   1       /* Select SROM Bank-1 for Ethernet*/
+#endif /* CONFIG_CMD_NET */
+
+#define CONFIG_LCD_LOGO			1
+#define LCD_BPP				LCD_COLOR32
+
+
+#endif	/* __CONFIG_H */
diff --git a/include/nand.h b/include/nand.h
index cead563..40ad5bf 100644
--- a/include/nand.h
+++ b/include/nand.h
@@ -1,4 +1,4 @@
-/*
+﻿/*
  * (C) Copyright 2005
  * 2N Telekomunikace, a.s. <www.2n.cz>
  * Ladislav Michl <michl@2n.cz>
@@ -103,6 +103,7 @@ int nand_read_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
 
 #define WITH_DROP_FFS	(1 << 0) /* drop trailing all-0xff pages */
 #define WITH_WR_VERIFY	(1 << 1) /* verify data was written correctly */
+#define WITH_YAFFS_OOB	(1 << 2)
 
 int nand_write_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
 			size_t *actual, loff_t lim, u_char *buffer, int flags);
diff --git a/tools/Makefile b/tools/Makefile
index 4d32fe5..0a27b04 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -219,6 +219,8 @@ LOGO-$(CONFIG_VIDEO_LOGO) += $(LOGO_H)
 LOGO-$(CONFIG_VIDEO_LOGO) += $(LOGO_DATA_H)
 
 # Generic logo
+LOGO_BMP= $(srctree)/$(src)/logos/zhoumou.bmp
+
 ifeq ($(LOGO_BMP),)
 LOGO_BMP= $(srctree)/$(src)/logos/denx.bmp
 
diff --git a/tools/bmp_logo.c b/tools/bmp_logo.c
index 55f833f..47d9ecc 100644
--- a/tools/bmp_logo.c
+++ b/tools/bmp_logo.c
@@ -1,4 +1,4 @@
-#include "compiler.h"
+﻿#include "compiler.h"
 
 enum {
 	MODE_GEN_INFO,
@@ -12,7 +12,7 @@ typedef struct bitmap_s {		/* bitmap description */
 	uint8_t	*data;
 } bitmap_t;
 
-#define DEFAULT_CMAP_SIZE	16	/* size of default color map	*/
+#define DEFAULT_CMAP_SIZE	8	/* size of default color map	*/
 
 void usage(const char *prog)
 {
diff --git a/tools/logos/zhoumou.bmp b/tools/logos/zhoumou.bmp
new file mode 100644
index 0000000000000000000000000000000000000000..bf0c7d660a4ddabe7378befe86fc32a32f271ca6
GIT binary patch
literal 27878
zcmeHP&u=3~c5VX!NKvwQ2;jZM0FU_#a&AeUQFpVuDT!qFW|0~4;&l!I@-Ofd403a9
zZ-BKa6YHVoFtR6yjdY5|W01dK0^~qrZC^xb78r5}A&1HLz3Ogulif{<^4Q*BOM2|;
z>guZZz4z+Zt0H%u@BcxQ@Hc;<X@8B_e}euA^p;kX^nd$%P5aADMUoJGbTkeBTBoBf
z_(W723<lcZe+Jqg|La84DmthQ!h=c=Gyn}XP1isb5F&aT)B*KC1JF>@+8U?=(m}Xs
zcR)SR05lBht>CJI+Mo`o2O5Benue&>tAKP+8`J^yKm*VaOlqJCNC&k+9Z(N601Y(_
z|Jtwu(m`!d2h;-%KtoN}z@}CK@vjZ)fO?<-XsDo7D!A&PHmC#Yfd-(Vf~{9@)j@4g
z2h;-%Ktm;xb_G`*)CP4xJ<tF&RO0GXaMeL=PzTfl4M0OB%3cLm9n=POKt0d^G*n_9
zRB+WnZBPf)0}Vh!QGq_J;Hrb#pbn@98i0mc2lzW$1w`a+5dV6h0cfaoDjKK)(m`!d
z2h;-%KtrWAy@IO_YJ)nU9%uj>DwVb?xay!br~~SO2B4u*H!A6LbWj`A0rfxw&`_B|
zuY#)%YJ)nU9%uj>Dl-{WaMeL=PzTfl4M0ONq0X>^s}5>|I-nkC02*oo;2&rekPd2t
zI-nkie?w(jl?tvps153XdY}PlsLW2U;Hrb#pbn@98i0n%B-<5Sbx<4B0rfxw&`_Cc
zr-G{vYJ)nU9%uj>DpT%NaMeL=PzTfl4M0O>=7S2ZI;aimfO^^=|M#`_82LIVPt#t@
zzxMhyV<7x7i64Isf0n>EuP;jfKcsN^kAJE-o})FszQE`#;ZbqxPZG!@1wr3<SFx{e
zeDLORd_&REgc*6TK@)f+3Hk;SbxF`DUt0MkKhzsY`2hEnd6XKyKF2mn64ivIu>24B
zQuMmi72Ro3eT>W%mL-vI0`)(~3;M=u;CRlDM}HN=!DredsTepywgf?lWA-|sqo7w?
zz^fX@qoQagEJb8<Nx4Lv&*2DjhGNX(J)R!okTM^kW+@XnW;g<+2;b~_m`jC-5yg@`
zU~53j){C$v)xy8IpjM+&9=(RW&2i4+qQat_sA)xQz)F-p6!$D4e0PRJDi+4Yg7D6(
zpy9@<ro{;Z&o4^SGM*!o&K8d5@f?*zrKskTu&bc(K)F%Qh!=UD|B-@2HP1K>7&OAW
z5E=EMgvm%6j&FcNvHvb1z)oLn5g1zq!@D&4i_KgdVa`ydtZPYFz!CN?aU9exrKI>~
zT<JRt2it=v<r4XX<516mtkHnt?L&Bs3R9&sXIRe?41An|BPMjQ6lHU?lgrSc0?U$n
zK2})*yV{g?L3xCvbi#633WK~5y)H@7-K@U5;D8Y3`zsbFJYK$17!?~3HAf27Rq;W9
znsTJ|@FiYFIUk5{6;dckIE-FbIKskaIq!r6wR5zfRM_JSDs_R0{I`rF?3`&?mlu1;
zE1gk<0~#)Ylh^E|sO-pGn5cR>jzH}4qSqCUurQ*O441eB7A!gPJ_5VS$RhGfeI`~A
zwwFYX**igFNIZ?-q`n@{aC?2k-;Tv+JjD_vDo@fG(Kl2hxTHnph4j~BZ~PEARBKDA
zD(pa^@sy{+g~~$H$qiYrM=ynaXOyr;MB!iuDU+kr5|%QO`c{;9$Je8BG9#O0-I33f
zJdW>YLrcm3QzbPm>&QfCmNef>VZt&@yXpHWPkvrWtybMQI5;p2!!$K}kvFG-$A-Dn
z(wv_;7`J5t2!ml9*0q+lnb3=W1dIp2G!7d`PCQuz{S&A7RdC9G{NdWrl9I<0^}xiF
z6cbCP;V$|5j|uLGwnc7vg^9t8q5y@+Gr~DEO>4(%wOX2O<Fi$5J!~4*Ap*0&{tgfE
zZ`JFP$#qi{=r~cyKX}CR6#`*~AHOt?v{ukh`D`H)l-7V#BD_eTDkYH@#+X^295pnJ
zpf|P6%`MQT*7BQ;M!kVv<%bFh?fZ3ML9rXKVtTL-)JGh`TKIJ3s~`d()2=tYlIArV
zCJPeSR*I_DfYz!Xn!1NhNNL$`Dk%mms@jZd%eFPg3%h}p`In5~pI0eLT?1IWL27jk
zuIFCagox2Mp**u5$h@Aw!HR?dzr=1Cf62#WaP@$ag4e@hn8KRx7)lMzqgg@A#(~*H
z%%{SWyb2V{hcbxh2MDoZq_TuzuZsvHp0m|zvTVcjC8AUiXBbc{$&o}D&$4bD#hRXb
zx4z5qv`w^Mknbrr4{=H36?Tx8ye{*J_gH1!W2d<8;L35?YicFm_t3skc+dhC6+)AG
zGeB4>Wn@Lxb<5`Bv`q6bV9r7-k)ALis2}ylIH-#+qE)TyzVb?}(o{;mbWBRj5C=s<
zjr=r0DWwrC3@pruTB~VA#_d3(YqG8yjEF#$KxXa~j(jz^`$sUf<|>WFk&afBux8DQ
z=SYVN!`*-whR?CsaeNC*8O_+tF2llHG-~5-l`*Y{BLEOnL4+ZS+^%H4cE~QP&gB7v
z?JeoRJj<|}81g*eUZYl2VcE7_ty-oj6&j{hwQa|7UDvj#X@uK>2y(~XLJ`a7D^S@M
zW}Y&CjlH|HZsx^Yua*+ZwOYB1kDFR;yTNQr3!BfN-iV2y?m*Z}!X{Qoi!+e<qUY~X
zmFW^hxxBx>53aL<jhy^fyv-N0+Pz`OBs(8SNli0WD>2LkSvin+dE0CDzx}rV8+SVf
zWq*GL3W}-T1p+Iid0I<4UmFW?=Htg9FDq7R@87)B>|RYaHZ}^y$;Nov^%VOzWv|<f
zE2vy^Ij<C*tXOy`t?){|nkoK{n1Z6Q+ibL?k6Wp#otppI)nrmE6bk1T5(<;?=yCI%
zcbcDFjYgw>Ogk_=QOT+j3Ykw{4XnBHg3m>?fyo&>0n$p6uczJ_@BL;po&ZDPOo33J
zlgrD|_~isJMpJ1zGwZ4W2?ey0kQVF2YX(=LIYAbvHfDz&=ZDMcq4^yc_fN*t0(5b9
zQH<lbD4qda@sv0c`lz{333bAk7r9(1#S9z+nNUiG(Ig56HPg*0myB5ZCzq!S%20sL
z0gpJ6cBS-Eb_GaI={b)u%gRKc9&9#^5C(u?G|MXuFr0FKG$M>bQW+P;!ueUTFa?Uy
z$V=)&0jasrMsE4(RTKU)vmzE7OAe(E5AK6Z95O7~`##tdb%ZVa;-ZMKQMjH=Cli73
zvL7%$e}U6$4IE@CXW@>OpYNBr4i7;rwJWPkWgvVh3MrhOqlFaD&kBWpb<eW)_V(;g
zy8UAxBYA4D**-D_m97n@!b_An<@G!W7=CE83eUN;bC^|LErxOL=Aod#hw82rn#rhZ
z>LGWAq3_xYy;Xn;IMxds(9?s1dG6s67J-C&U^(n}vtbD28=8~~<CDjuX%Nt=x9UgM
z4)f4^x@+y2Ryvd_MZ1<|84uFic}asuglb@CE3yO&qK#0nbAmJMnldQ@nSTCOH$Wtp
z@#yO6s^3NEcaQu1lNS5gL{RtZ>H|EP7(Y^Mt5vV66;~-()r#S!ii&O1Fz$OH<7mp=
zU4uBJQ3uHrHul0~g8!?R)A(#l@Hh@HGG|P!WKL=+x9K}A@NEY36-V=BqL}h(m;`a$
zJAN7B7>y=7hsFb37&bs-TvR8_iArJe)r}HAC&S>rTy|?vCjxP-5r7<$)Y5(OGbPFB
zmt6y`%{hJ<6aL3$)u{Koby+|isbHErmbF`N*bTe-9#&PBRYj0yQg%(-XjlqIc0G9j
zsYA1rKQqym%tu&6En!0sHsN5=^=9)3!={cP0>cGS={STXBvz{?*td<QX*3MrsEYOG
zF`W4fT-4K>deo2Q?g3C6hT9*V&dh3b)%A8LSNr(ntHSjO8u(|Qe){oe{ps|?!*ceB
zyEav)493d<fmJE^KdKT30cWzB{{U}B9H&M~8rny0>82Y4!DylQtZwcCi*6dn_0Iud
zIxZGp6)>*2WFJdfx8`uw&Z(!_z-&gfbLn^U`OSI?9`o0>=z?=mK<<f7R%TaU7mMe=
zwqZ(Dv%b5lTh*%q<|n74kqZRS$-$9y9>Ge0Ye(W!{Z$sHx#@th#QozxSfY*t_sfJn
z&?SY_^%u=eu*yx7slqYcuF1SMl#F3H+f^s(zsL>8-CGA5q*2dp=)sm{deN*hX;!D`
zTSFMQKH0K#6I-24biA;u<1(9sjoCf>DtCT@g4RM5YXAWsSnQ=Xj3BYJWQ)wG`eAQ%
zI+aym493N)i;EYHJ>97S$8>bH4eP1eTUFIeaFYyWSr#s{<1CRj@_h{=ooo>qZa2Vj
zt>%T{y5npz{*SMT>D9%n^Ya20AeUX@U?|IH$_IS_>jdgC7e}xLOvgdVnXVcFr$x-q
zXKkbSbo4EHT<AciB$$*G`s3q}|9OK75tVCd7Pl4@FVC*Hy@^uOaqxi^^txhFv!*c}
zb#EAI{_%I;pFDe5=1m9#Y{#M@2z6y2cIzN4<~Q@YV8|@osCo3{jGn@;z-3byrlWFq
zWBlExhNh#T9esk?aKG!7F`2@i#Q_Gw^r<`WS*Y;#O$6gmUMtr$buu9p2NKnKoJ-jd
zKyWRLw!u0^jL{cg5a%WS$D^rN+b`dL3ohz(->;|yNF#;Z0+5m0%+>yEnq8p^<G{Z8
zgj{lXNQUC+bc)vURRJ!=$>jR_{Gu>@I)V$U|2|eA{i`QQYnr<Y58<$i8K?+dS_BKG
zT!moTPPs3>${Nht+hf4Ep4n4`=K2y&tmsZ6aA5uW@5h+N)88<iV?B8bhX$6RYU;RH
z^+F1lKu1e($UgJJn`-2B%H$~NHw<{^EMx(RJj0}=csWk@{e)<+#67^8goFQz!Qff1
z?7*$7l(HnrFl$}dd}08fX`t}*k^{@{lS(NTulf&~O+UNC5-3%}bkQl)(CSwRVlk=e
zz<HsqE$rZU!De|{VOT$*uZoQsGYk^LIu<rJ8U?OuNxMG1U%rX$8-((ozlKwmvaH!t
z1UbhLjBrsG@LG9IoOx<sCd?uTH!T=096ht4Zw`jSGC56H-N>8gIP1Qw9yqjyjQZm|
z;S5c3{BX4gYWonmWUd;|9gm}(JMPuxRfbump~BQXYb4Kt<E#V&ywsCtZCedYP9HWJ
zcFV8k&k#{TwfrTUN3sQ^0tga|kF)sAN?*O9`z1%)3=ibN$YQ5A)bZB15)yF(gE^hK
z@dl8G0!yiG7Qb2PtKz`fFyGZ0c4}+)TRbm`zB$2uaD!B%3h!IIzdAd;Dx6`yc!tk3
zM3V>QEQZt5%eB<H7y01`a(L8e+Uec~_o2+&(h8H#&M6Z|!1LsbKYSJ0STRjY(`+0W
z0NG!q)jp3zWQ`rn%vn~c8g6<l7RLd-8}_`##Yxu1yizW+?8>pLRx?c{Y@>@6CsByO
zAQKFP=RDJcy;ag0N3vI&d|TZa?iCbLxZ0S0H>K<I`|ij8{Lur1zkC1L`Rl7`q#v4D
z;c{+AEylTvlPuL=)ZmARg)+OVr8tnoti#{eXtc7vIw06Q4d*CYoGL5^!|IQ)MjF{~
z?HFctXXjVHJ1zc>J~wz1?Y;Wr5tp`MC_E(&hfYu#tV5<baNpq1G;G9X0n?I9T|oGX
z8$_`6M;0|VT@}exY}m@H@sbg*Vp&_9cDu)zqr%R->sOCi@_}(#z`5x<7KAe(g;9UI
zRx{`Wt>M(kQT-#F4unlt;U?v5s^-MCfwc-7XEqe#FwDjwx~ep1dy@U=&e@DM)8lHf
zTbxBrFGtct8i!_8|Lqs525_*4MabjGwt%BXQ{nv2Xu=9jU2^s(Ut-(n0NWz&+cRx&
zwwsMY#A(!9tt}sC^dc@-iTLpRh1!gu81@M#QH8?PzZY!Q(4z~_E<B!1Kpb6#W_3{*
zL*6{S;M5$PrTADkeoJW^M*kD;4I*M#R!k+rYgE%>#Aqo?N_VwqK=N>4X5N!5mA^-S
zBHB9S`{d;0L8FdP{iq9f=oOc|T)2x1;vB99oWdY;7Hmk4V|+*$6gnZyFLjX>$&2iV
zDdyaiDueNqWNfXm-bBE(7Y;=X>%p4v6}N1PlT$#DfG1zd5+10y=pb`wA#h<~0c##|
z3&FPU?ayYx$fNualv;LR>&5}lTj?T%<jCT19*Xm?<MAonJCXe`A_o@~kW&Q+pR^es
zNuxey!GCy+4aLb6D~?$rVtKj%Lg>mcTDhyIkne>ndyqLHp)lKSqQiPd(?SpwX!s+n
zu@nNV)u+=_z~Mm#*pqP(YXr60!+yX2(A$odC9VSybezmrHK!cosJXsnsc)#vN))N^
z!`#`czIV@Q9v`24|9$_vY4@{wxd|lG>2(2315IRlI)a~?mIe2njYt^w;o2(miJX$F
znz(T}TrJ3KRxM*jHP`jFpoDlr;Fn7l2o;O$LS?hV()AtpJ17PG2lj>o0asnHSc9J$
z+2L#F4MXIka~;lt&^J?OOHc?4I6!v0J~zO^;{oJiAw;&!hsa{=dB^C*0tnHiczuGi
zarfWb+m#ofMYMC-E0m*{eAjSmF$dN{Mezg-g7sXlZd?QLxXrTw5zAqbu{5O-bNAkp
z^WsLteLRBp^L63;*^`#DhfX6XjKWdH!gqm@lJSLV!s>!6Ghtr1PJdOBsmZ)L$OFI4
z#ehB7?d|<vJe$o$;uzv_bO@MUj=uQtLynk=X{g6R3+GX+`AX(Ms9WS)%c}5|D5+wx
zk}5pXwDKDa15eUc9&rdNjsb^2aNzIdA3pt;Lr4MxAzaxGM*P))P-!_Qed30ch}+@>
zT9gc=>6ATms|eW9T&@cOfi}>GVFZ;h9&hw{49GRB9Pt+gwOA`tkTdBeN${I-<7?^K
zrdZry_uw=+7%pldN+FKmSQ$r}lYMr*rr~2=&jQo=PNYg6<Mv<2^E0QP7}tU$OHWtE
z!6}y-CdZ@x!*bbyA`W;OfW!ET8bLPf(%yPRmmVS^lJG`6ax{?3RdI0linA_^FvsN^
zOcRVI#KaYrC?j3-VRgY(@RpXHu$;H9O`a^vQn($S_nAh9lOMqd58oGnbhmFfUZ_*f
zqK(W-=3oe5^VaR7q|UuAS}x7m3Xfl{+Ca{*3k?{37iX(gk@z&#oMnOE>;$f8ZyPqr
zaC*;<j(?vsLxk&mJp@nB&^D%{mnZvd+$dAEi7FwjWKs$lzA2S|96S}Gw>a0G2@1Ym
zfiYT5A@EF~mui+_Na4-^M07+*s{v8@tlKsY0hal#SsI2_3&w)e6%=w-I0X)I%Eb=z
ziN04<h-ht<W4kFTu}fq)B~UmAH7JA)_jIxx2w`AH3Tr|P7Bs3LNI~IE?v<u!;!DeG
zg;a+Lsv{qmZeyKJt6$i=UBFeC0`Mm=sxprF1X{@DdhsFOTBD6C*x6@hC{lADP96zM
zb`r#>-Y?fg8;dNilEV6owWjPuqP`KCT8{$ae>=W}$&8-jI0lxoXY{(yjf}-2_Mb;D
z`}=Svu6eLhdIBi2v_@y86e8zw(s77=*tK`2(W+eOW^~HcIVK@8QHRw5=Xi>?!E=0K
zk*Ve7CQ6Gk)?d_WTyIkH>48o5Ud=xdFHeAC{=#QhIG+Kdq95V*NLUG9wAOYpD8tGT
zA-OV)-TV9g@pLlg0fG52emQ=8jEM-m)I4D+`O{^Rm8!&O9D3`l1C>$X(+f-?QzfjP
zp27RB3%|+9S9JKy!pTES%P~Q(!4H<jXihp6L2a1wa~2U(>qHzi`sQ&Vm7%^J1b&+n
zU*8PFy|*13-{X|MnY<#huqYgL?Jg#zP}`VfE#n~hoaPe?WRY@BX3Anbk<Pd9J?*tT
z3ky2)xR^>5pLY|_DOPctm*)!>3F1pN3p}lr;NsACoW1$l68Dmotr^&bjg{X_6cgRR
zt#GII9Y?$+9?O*&LX(umu;Qc2<<d&;MSRC1w9ViL4dUF~A&yafWq!EfCvzyv2^QWl
z)@~K01a{W{p^Ox~rQi(dayC%4S=%mezjqJo47Jc$Pak*->c~H6oWkj{BnRglR<IEA
zY&gZ&FA7h}H}G~6_<A__rfL0PO(TX+{h*SxT~@LX2$SY#y?s%5Q7FE6Cfgp&whj_B
zH0#z5g&4QlQT#3rdCJ!c&YzUa=dWHDUcA6aj=8{E0d?@W1rD`kvvY?h4pxWqm%^T;
zW9L=A@%U@+`o-s1G}Ufoo}Q9D9Ug>)y!be*TWc=-R)U8gp%5UcmJ+bQ{f+%?cYB``
z6xVHrPK9*Nqf|l=y!bfG|9;9!tmbEOJvr8tiUTYKg6FqX0;fpGTEuT!BmzKPSPlQy
z4#Rw=)1EpSexr>1LNS2=<D4n0!_EwL(pCsWIV0n!zSF`_o2AwJM$#H4e?ls&$)l$^
zaO4}=xky9|#4QCu4NHEf;0++z#8*PYpIC!Ukd=7Ay~T~0g$Kz@0_5;lIHFp@kM+rK
z^}PXJmlf%_tzB+Zg131bl0X;>4+ID;@}RDn5BXbzKZ}43;HE6|<~inlItU`+@rt=0
z!~DtNY(l7h^N1pjz|0WPbfUW;iitRns;=dxebaDV&2H^j_yse7A>VQK#g>9}>}>kM
z!J{|L()#7|m_f5q=kF{L3i&6VARvBdVx7Hy`9JELIQ7V1#=~KG1pF>S6c8`H!SU_?
E083Q<Z~y=R

literal 0
HcmV?d00001

